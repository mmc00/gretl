<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="R2_decompose" ID="1435724365" minver="1.8.4">
<author email="aeibagnez@gmail.com">Alejandra Enr√≠quez</author>
<version>1.0</version>
<date>2015-05-09</date>
<description>R2_decompose</description>
<help>
This function reports the decomposition of the R-squared of a regression. It assesses the explanatory power of each regressor.
In other words, this lets the practitioner know how much a particular regressor contributes to the overall explanation of variation in the model.

The arguments of the function are:
A boolean variable to decide whether the practitioner wants a constant term.
Please note that the decomposition does not properly work without the constant term.
List X where the practitioner chooses the regressors
Series Y where the practitioner chooses the regressand


The formula to compute the decomposition is: 
Rj=[(coeff of xj)*(std_err of xj)*(corr xj,y)]/(std_err of Y).


Warning: if you have selected the &quot;constant&quot; field you shouldn't add a constant to the explanatory variables, otherwise it will print error.

The output of the function is a regression and the decomposed R-squared.  It also returns a matrix, (which can be named by you) with the corresponding R-squared (one per explanatory variable in the same order of list X); the last number is the R-squared of the regression which is the sum of all the other R-squared.
</help>
<gretl-function name="R2_decompose" type="matrix">
 <params count="3">
  <param name="constant" type="bool" default="1">
<description>Add constant?</description>
  </param>
  <param name="X" type="list">
<description>Explanatory Variables</description>
  </param>
  <param name="Y" type="series">
<description>Explained variable</description>
  </param>
 </params>
<code>if constant
  ols Y const X
  matrix b=$coeff
  string h=varname(X)
  scalar n=nelem(b)-1
  matrix cor=zeros(n,1)
  loop foreach i X
    scalar gi=corr(Y,X.$i)
    cor[i,1]=gi
  endloop
  matrix SD=zeros(n,1)
  loop foreach i X
    scalar ti=sd(X.$i)
    SD[i,1]=ti
  endloop
  scalar s=sd(Y)
  #decomposed R
  scalar R2=$rsq
  matrix Rd=zeros(n+1,1)
  print &quot;Each Ri corresponds to each explanatory variable in order of appeareance&quot;
  print h
  loop i=1..n
    scalar Ri=(b[i+1,1]*SD[i,1]*cor[i,1])/s
    print Ri
    Rd[i,1]=Ri
    Rd[i+1,1]=R2
  endloop
  print &quot;This is the usual R2, check that the sum of Ri equals R2&quot;
  print R2
else
  ols Y X
  matrix b=$coeff
  string h=varname(X)
  scalar n=nelem(b)
  matrix cor=zeros(n,1)
  loop foreach i X
    scalar gi=corr(Y,X.$i)
    cor[i,1]=gi
  endloop
  matrix SD=zeros(n,1)
  loop foreach i X
    scalar ti=sd(X.$i)
    SD[i,1]=ti
  endloop
  scalar s=sd(Y)
  #r desagregada
  matrix Rd=zeros(n+1,1)
  scalar R2=$rsq
  print &quot;Each Ri corresponds to each explanatory variable in order of appeareance&quot;
  print h
  loop i=1..n
    scalar Ri=(b[i,1]*SD[i,1]*cor[i,1])/s
    print Ri
    Rd[i,1]=Ri
    Rd[i+1,1]=R2
  endloop
  print &quot;Remember that for a regression through the origin the usual R2 does not always fit&quot;
  print R2
endif
return Rd
</code>
</gretl-function>
<sample-script>
include R2_decompose.gfn
open np.gdt --quiet
#y is the explained variable and X are the explaining variables
series Y = rgnp
list X = unemp money rwage

#adding 1 as if the constant where selected

matrix r = R2_decompose(1,X,Y)
</sample-script>
</gretl-function-package>
</gretl-functions>

