<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="Threshold_Panel" ID="1440408373" needs-panel-data="true" minver="1.9.9" lives-in-subdir="true">
<author email="artur.tarassow@googlemail.com">Artur Tarassow</author>
<version>0.921</version>
<date>2015-08-24</date>
<description>Threshold model for static panel, Hansen (1999)</description>
<help>
##############################################################
#		Threshold Panel Model
##############################################################
#
# This function computes for a static panel A) the threshold
# effects and B) the FE-estimation coefficients for up to three
# thresholds (4 regimes).
#
# Only one threshold variable (trigger) can be used.
# At the moment only a single regime-depnendent variable can be
# defined. However, this could be extended in future versions.
#
# MAIN FUNCTION:
# 	Format: {BUNDLE} = THRESH_SETUP(ENDO,EXO,REXO,THRESH, strY, strEXO, \
#  						nthresh, opt_const, max_lag, t, qn, \
#						nrep, trim_1, trim_2, \
#  					trim_3, conf_lev)
#
#	Input:
#			ENDO 		- matrix (n*t)x1 of the endogenous
#			EXO			- matrix (n*t)xk of k exogenous (without constant)
#			REXO		- matrix (n*t)x1 of the regime-dependend exogenous
# 			THRESH		- matrix (n*t)x1 of the regime-dependend exogenous
#			strEXO		- string name of the regressors in EXO
#			strTHRESH	- string name if the threshold variable
#			nthresh		- scalar number of regimes to test (up to 3)
#			opt_const 	- scalar &quot;0=no constant, 1=fixed constant, 2=regime dependent constant
#			max_lag		- scalar maximum lag of EXO, REXO or THRESH (for adjusting sample accordingly)
#			t			- scalar number of time periods (full sample)
#			qn			- scalar number of quintiles to examine
# 			nrep		- scalar number of bootstrap replications
#			trim_1		- scalar percentage to trim before search, single
#			trim_2		- scalar percentage to trim before search, double
#			trim_3		- scalar percentage to trim before search, triple
#			conf_level	- scalar confidence interal for threshold test
#
#	Output: {BUNDLE}
#			beta_lin			- matrix of estim. coefficients of linear benchmark model
#			sehomo_lin			- matrix of S.E. of estimated linear benachmark model
#			sehomo_lin			- matrix of HC-robust S.E. of estimated linear benachmark model
#			SSElin				- scalar of SSE of linear benchmark model
#			beta_indep_Tx		- matrix k by 1 of regime-independent coeff. for regime model x
#			sehet_indep_Tx		- matrix of HC-robust S.E. of reg.-indep. coeff. of threshold model with x thresholds
#			sehomo_indep_Tx		- matrix of S.E. of reg.-indep. coeff. of threshold model with x thresholds
#			beta_dep_Tx			- matrix k by 1 of regime-dependent coeff. for regime model x
#			sehet_dep_Tx		- matrix of HC-robust S.E. of reg.-dep. coeff. of threshold model with x thresholds
#			sehomo_dep_Tx		- matrix of S.E. of reg.-dep. coeff. of threshold model with x thresholds
#			SSE					- matrix nr by 1 of SSE of nr threshold models
#			rhats_Tx			- matrix of estimated thresholds for model with x thresholds
#			lrstats				- matrix qn by nthres storing likelihood ratio over potential thresholds for each model
#			lrtest				- matrix nr by 1 holding the LR-test statistics for nr threshold models
#			lrprob				- matrix nr by 1 holding the bootstrap pvalues of the LR-test for nr threshold models
#			lrcrit				- matrix nr by 3 holding the bootstrap criticial values: (10 pct~5pct~1pct)
#			N					- scalar of the cross-section units
#			T					- scalar of the number of valid (actually used) observations
#			qq1
#
#
#	This gretl code was written by:
#           Artur Tarassow
#           University of Hamburg, GER
#           artur.tarassow@wiso.uni-hamburg.de
#           artur.tarassow@googlemail.com
#
#   The original GAUSS code was written by:
#           Brucen E. Hansen
#			http://www.ssc.wisc.edu/~bhansen/progs/joe_99.html
#
#
# CHANGELOG:
# ----------
# 0.921 (August 2015)
#	- cleanining up the code
#	- get rid of the seqa() function
# 0.92 (August 2015)
#	- cleanining up the code
#	- solve some bugs which let to collinearity issues
#	- speeding-up by vectorizing stuff and using internal functions
#	- bug in the resamling procedure to bootstrap the test statistics
#
# TODO:
#		- Setup the regime-dependent intercept case (opt_const=2)
#		- Allow for more than a single regime-dependent variable
#		- Multicore-bootstrap
#
############################################################################
</help>
<data-files count="1">
invest_joe99.gdt </data-files>
<gretl-function name="SSE_CALC" type="matrix">
 <params count="2">
  <param name="y" type="matrix"/>
  <param name="x" type="matrix"/>
 </params>
<code>catch b = mols(y,x)				# internal function may be faster
scalar error = $error
if error==0
  e = y - x*b
  return (e'e)~{error}
else
  return zeros(1,1)~{error}
endif
</code>
</gretl-function>
<gretl-function name="R_EST" type="matrix">
 <params count="13">
  <param name="y" type="matrix"/>
  <param name="xt" type="matrix"/>
  <param name="ct" type="matrix"/>
  <param name="cf" type="matrix"/>
  <param name="THRESH" type="matrix"/>
  <param name="r" type="matrix">
<description>Vector of threshold values</description>
  </param>
  <param name="trim" type="scalar">
<description>Trimming percentage</description>
  </param>
  <param name="qq1" type="matrix"/>
  <param name="qn1" type="int"/>
  <param name="qn" type="int"/>
  <param name="tt" type="int"/>
  <param name="n" type="int"/>
  <param name="opt_const" type="int"/>
 </params>
<code>if maxc(r) == 0
  qq = qq1
  matrix rr = 0
else
  matrix rr = msortby(r,1)
  #matrix i = seqa(1,1,qn1)
  matrix i = 1 + 1*seq(0, qn1-1)'
  nn = sumc(qq1.&lt; (rr'))
  qnt = qn*trim
  ii = ((i .&lt;= (nn+qnt))-(i .&lt;= (nn-qnt)))*ones(rows(rr),1)
  if ii!=0
    ii=ii.-1
    qq = selifr(qq1,ii)
  else
    qq = qq1
  endif
endif
sse = THR_SSE(y,xt,ct,cf,THRESH,qq,rr,tt,n,opt_const)
rihat = iminc(sse)'
mout = sse[rihat]|qq[rihat]
return mout
</code>
</gretl-function>
<gretl-function name="THRESH_SETUP" type="bundle">
 <params count="18">
  <param name="ENDO" type="matrix">
<description>Matrix of endogeneous variable</description>
  </param>
  <param name="EXO" type="matrix">
<description>Matrix of exogenous regime-indepent</description>
  </param>
  <param name="REXO" type="matrix">
<description>Matrix of exogenous regime-dependent</description>
  </param>
  <param name="THRESH" type="matrix">
<description>Matrix of threshold variable</description>
  </param>
  <param name="strY" type="string"/>
  <param name="strEXO" type="string">
<description>Names of EXO</description>
  </param>
  <param name="strREXO" type="string">
<description>Names of REXO</description>
  </param>
  <param name="strTHRESH" type="string">
<description>Threshold var.</description>
  </param>
  <param name="nthresh" type="int" min="1" max="3" default="2">
<description>Number of thresholds to test</description>
  </param>
  <param name="opt_const" type="int" min="0" max="2" default="1">
<description>0=no constant, 1=regime-independent constant, 2=regime-dependent constant</description>
  </param>
  <param name="max_lag" type="int">
<description>Maximum lag order of variables considered</description>
  </param>
  <param name="t" type="int">
<description>Number of time periods</description>
  </param>
  <param name="qn" type="int" min="50" default="200">
<description>Number of quantiles to examine</description>
  </param>
  <param name="nrep" type="int" min="10" default="399">
<description>Number of bootstrap replications</description>
  </param>
  <param name="trim_1" type="scalar" default="0.01">
<description>percentage to trim before search, single</description>
  </param>
  <param name="trim_2" type="scalar" default="0.01">
<description>percentage to trim before search, double</description>
  </param>
  <param name="trim_3" type="scalar" default="0.05">
<description>percentage to trim before search, triple</description>
  </param>
  <param name="conf_lev" type="scalar" default="0.95">
<description>confidence level for threshold</description>
  </param>
 </params>
<code>set warnings off
set seed 1234
bundle OUT = null
# Prepare matrices to store some stuf for bundle output
matrix lrtest = zeros(nthresh,1)
matrix lrprob = zeros(nthresh,1)			# lr-test prob values: M1|M2|M3
matrix lrcrit = zeros(nthresh,3)      		# lr-test bootstrapped criticial values: (10 pct~5pct~1pct)
matrix SSE = zeros(nthresh,1)
scalar k = cols(EXO)
if opt_const!=0
  scalar k = k+1
endif
loop i=1..nthresh -q
  matrix beta_indep_T$i = zeros(k,1)
  matrix sehet_indep_T$i = zeros(k,1)
  matrix sehomo_indep_T$i = zeros(k,1)
endloop
scalar tt = t-max_lag
scalar n = rows(ENDO)/tt				# No. of cross-sectional units
scalar ty = n*(t-max_lag-1)
# Specify deviation from mean	#
# Endogenous
matrix y  = ENDO			# No dynamics for the endogeneous allowed, yet!
matrix yt = TR(y,tt,n)
#	Regime-dependent variable, henceforth named cf anc ct (mean deviation)
matrix cf = REXO
matrix ct = TR(cf,tt,n)
#	Define regressors apart from THRESH-Variable and regime-dependent
matrix x = EXO
scalar k = cols(x)
matrix xt = zeros(rows(yt),k)
loop j=1..k -q
  xt[,j] = TR(x[,j],tt,n)
endloop
# Threshold space
dd = values(THRESH)
qnt1 = qn*trim_1
scalar inc = 1/qn
scalar ende = qn-2*qnt1+1
#sq = seqa(trim_1,1/qn,qn-2*qnt1+1)
matrix sq = trim_1 + 1/qn*seq(0, (qn-2*qnt1+1)-1)'
qq1 = dd[floor(sq*rows(dd))]		# vector of quintile values
qn1 = rows(qq1)						# number of quintiles
cc = -2*ln(1-sqrt(conf_lev))
printf &quot;Number of Individuals \t %d\n&quot;, n
printf &quot;Number of Years used \t %d\n&quot;, tt
printf &quot;Total Observations \t %d\n&quot;, ty
printf &quot;Number of Quantiles \t %d\n&quot;, qn
printf &quot;Confidence Level  \t %.3f\n&quot;, conf_lev
printf &quot;\n&quot;
printf &quot;*******************************************************\n&quot;
printf &quot;\n&quot;
#	BASELINE LINEAR MODEL	#
xx=xt~ct
if opt_const&gt;0
  xx = ones(rows(xx),1) ~ xx
endif
xxi = inv(xx'*xx)
matrix v = zeros(cols(xx),cols(xx))
matrix e = zeros(rows(xx),1)
#matrix blin = inv(xx'*xx)*xx'*yt
matrix blin = mols(yt,xx,&amp;e,&amp;v)			# internal function may be faster
#matrix e = yt - xx*blin
xxe = xx.*e
catch sehet = sqrt(diag(xxi*(xxe'*xxe)*xxi))				# White std err
if $error
  print xxi xxe
  stop
endif
catch sehomo = sqrt(diag(xxi*(e'e)/(ty-n-cols(xx))))		# std err
if $error
  print xxi e
  stop
endif
OUT.beta_lin = blin
OUT.sehet_lin = sehet
OUT.sehomo_lin = sehomo
sse0 = SSE_CALC(yt,xx)					# baseline linear model
sse0 = sse0[,1]
OUT.SSElin=sse0
# PRINTOUT LINEAR MODEL RESULTS
linprintout(blin, sehet, sehomo, sse0, strY, strEXO, strREXO, opt_const)
# LOOP over THRESHOLDS
loop lreg=1..nthresh -q					# Loop over specified number of maximum thresholds
  # Matrices to store information
  scalar nrexo = $lreg+1
  if opt_const==2
    scalar nrexo = nrexo+1		# FIXME: The number depends on the number of regimes!in case of regime-dependent intercept
  endif
  matrix beta_dep_T$lreg = zeros(nrexo,1)
  matrix sehet_dep_T$lreg = zeros(nrexo,1)
  matrix sehomo_dep_T$lreg = zeros(nrexo,1)
  # FIRST ITERATION
  if lreg==1
    matrix rhat0 = 0				# for initial run assume a zero threshold which will be then estimated in the next step
    matrix rhattmp = zeros(1,3)		#rhat0
    matrix rhatall = {}
    matrix rhats = zeros(nthresh,3)			# M1: (min~point~max) | M2: (min~point~max) | ...
    matrix lrstats = zeros(rows(qq1),nthresh)	# Store likelihood ratio over potential thresholds for each model
  elif lreg&gt;1
    sprintf stmp &quot;%d&quot;, ($lreg-1)
    matrix rhatall = rhats[1:(lreg-1),]		#rhatall | rhat@stmp
    rhattmp = rhatall
  endif
  if lreg==1 &amp;&amp; opt_const &gt; 0
    xt = ones(rows(xx),1)~xt				# add intercept
  endif
  printf &quot;\n*************************************\n&quot;
  printf &quot;\nThreshold Model with %d Threshold(s)\n&quot;, $lreg
  flush
  bundle m$lreg = MODEL(rhattmp[,2],trim_$lreg, nrep, qn, qq1, cc, yt,xt,cf,ct,THRESH, ty, tt, n, k, opt_const)
  #matrix rhat$lreg = m$lreg.rhatCI					# new conditional rhat estimate
  rhats[lreg,] = m$lreg.rhatCI
  matrix lr = m$lreg.lrstat
  matrix lrstats[,lreg] = lr
  matrix lrprob[lreg] = m$lreg.lrprob					# bootstrap is donce in first iteration phase
  matrix lrtest[lreg] = m$lreg.lrtest
  matrix lrcrit[lreg,] = m$lreg.lrcrit
  SSE[lreg] = m$lreg.sse
  # Store matrices and print stuff
  beta_indep_T$lreg[1:] = m$lreg.beta_regindep
  sehet_indep_T$lreg[1:] = m$lreg.sehet_regindep
  sehomo_indep_T$lreg[1:] = m$lreg.sehomo_regindep
  beta_dep_T$lreg[1:] = m$lreg.beta_regdep
  sehet_dep_T$lreg[1:] = m$lreg.sehet_regdep
  sehomo_dep_T$lreg[1:] = m$lreg.sehomo_regdep
  printout(beta_indep_T$lreg, sehet_indep_T$lreg, sehomo_indep_T$lreg, beta_dep_T$lreg, sehet_dep_T$lreg, sehomo_dep_T$lreg, rhats[1:lreg,], SSE[lreg], lrtest[lreg], lrcrit[lreg,], lrprob[lreg], nrep, strY, strEXO, strREXO, strTHRESH, $lreg, 1, trim_$lreg, opt_const)
  # SECOND ITERATION: Refinement estimate #
  # no bootstrapping needed, as critical values are already obtained in first iteration #
  if lreg &gt; 1
    if lreg==2
      #matrix rhattmp=rhat$lreg
      matrix rhattmp = rhats[lreg,2]
    elif lreg==3
      sprintf stmp &quot;%d&quot;, ($lreg-1)
      matrix rhattmp = rhats[(lreg-1):(lreg-1),2] | rhat@stmp_2[,2]
    endif
    bundle m$lreg_2 = MODEL(rhattmp,trim_$lreg,0,qn,qq1,cc, yt, xt, cf, ct, THRESH, ty, tt, n, k, opt_const)
    rhat$lreg_2 = m$lreg_2.rhatCI
    beta_indep_T$lreg[1:] = m$lreg_2.beta_regindep
    sehet_indep_T$lreg[1:] = m$lreg_2.sehet_regindep
    sehomo_indep_T$lreg[1:] = m$lreg_2.sehomo_regindep
    beta_dep_T$lreg[1:] = m$lreg_2.beta_regdep
    sehet_dep_T$lreg[1:] = m$lreg_2.sehet_regdep
    sehomo_dep_T$lreg[1:] = m$lreg_2.sehomo_regdep
    printout(beta_indep_T$lreg, sehet_indep_T$lreg, sehomo_indep_T$lreg, beta_dep_T$lreg, sehet_dep_T$lreg, sehomo_dep_T$lreg, rhats[1:lreg,], SSE[lreg], lrtest[lreg], lrcrit[lreg,], lrprob[lreg], nrep, strY, strEXO, strREXO, strTHRESH, $lreg, 2, trim_$lreg, opt_const)
  endif
  # Temporary BUNDLE output
  OUT.beta_indep_T$lreg = beta_indep_T$lreg
  OUT.sehet_indep_T$lreg = sehet_indep_T$lreg
  OUT.sehomo_indep_T$lreg = sehomo_indep_T$lreg
  OUT.beta_dep_T$lreg = beta_dep_T$lreg
  OUT.sehet_dep_T$lreg = sehet_dep_T$lreg
  OUT.sehomo_dep_T$lreg = sehomo_dep_T$lreg
  OUT.rhats_T$lreg = rhats
endloop
# BUNDLE elements for output:
OUT.lrstats = lrstats
OUT.lrtest = lrtest
OUT.lrprob = lrprob
OUT.lrcrit = lrcrit
OUT.qq1 = qq1
OUT.SSE = SSE
OUT.T = tt
OUT.N = n
return OUT
</code>
</gretl-function>
<gretl-function name="LAG_V" type="matrix">
 <params count="5">
  <param name="x" type="matrix"/>
  <param name="lagn" type="int"/>
  <param name="t" type="scalar"/>
  <param name="n" type="scalar"/>
  <param name="max_lag" type="scalar"/>
 </params>
<code>matrix y = mshape(x,t,n)'
y = y[,1+max_lag-lagn:t-lagn]
return (vec(y'))
</code>
</gretl-function>
<gretl-function name="THR_SSE" type="matrix">
 <params count="10">
  <param name="y" type="matrix"/>
  <param name="xt" type="matrix">
<description>Already includes fixed-constant</description>
  </param>
  <param name="ct" type="matrix"/>
  <param name="cf" type="matrix"/>
  <param name="THRESH" type="matrix"/>
  <param name="q" type="matrix"/>
  <param name="r" type="matrix"/>
  <param name="tt" type="scalar"/>
  <param name="n" type="scalar"/>
  <param name="opt_const" type="int"/>
 </params>
<code>scalar nq = rows(q)
matrix sse = zeros(nq,1)
loop qi=1..nq -q
  scalar error = 0
  if r==0
    matrix rr = q[qi]
  else
    matrix rr = r|q[qi]
    matrix muni = uniq(rr)
    if rows(muni)&lt;rows(rr)	# CHECK WHETHER IDENTIFIED THRESHOLDS COINCIDE!
      # THIS SHOULD NOT BE THE CASE, OTHERWISE COLLINEARITY ISSUES ARISE!
      error = 1				# FALG ERROR
      sse[qi]= NA #$huge
      error = 1
    endif
  endif
  if error==0
    rr = msortby(rr,1)
    xx = xt~ct
    loop j=1..rows(rr) -q
      d = (THRESH .&lt; rr[j])
      xx = xx~TR(cf.*d,tt,n)						# add interaction-term
      if opt_const==2
        xx = xx ~ TR(d,tt,n)					# add regime-dep. intercept
      endif
    endloop
    mtmp = SSE_CALC(y,xx)
    sse[qi] = mtmp[,1]
  endif
endloop
return sse
</code>
</gretl-function>
<gretl-function name="MODEL" type="bundle">
 <params count="16">
  <param name="r" type="matrix"/>
  <param name="trim" type="scalar"/>
  <param name="nrep" type="int"/>
  <param name="qn" type="scalar"/>
  <param name="qq1" type="matrix"/>
  <param name="cc" type="scalar"/>
  <param name="yt" type="matrix"/>
  <param name="xt" type="matrix">
<description>Already includes the fixed intercept</description>
  </param>
  <param name="cf" type="matrix"/>
  <param name="ct" type="matrix"/>
  <param name="THRESH" type="matrix"/>
  <param name="ty" type="scalar"/>
  <param name="tt" type="scalar"/>
  <param name="n" type="scalar"/>
  <param name="k" type="scalar"/>
  <param name="opt_const" type="int"/>
 </params>
<code>bundle mout = null
scalar qn1 = rows(qq1)
if maxc(r)==0						# Single threshold case
  qq = qq1
  matrix rr = 0					# rr are the fixed thresholds
else								# Multiple threshold case
  matrix rr = msortby(r,1)
  #matrix i = seqa(1,1,qn1)
  matrix i = 1 + 1*seq(0, qn1-1)'
  nn = sumc(qq1 .&lt; (rr'))
  qnt = qn*trim
  ii=((i.&lt;=(nn+qnt))-(i.&lt;=(nn-qnt)))*ones(rows(rr),1)
  if ii!=0
    ii=ii.-1
    qq = selifr(qq1,ii)
  else
    qq = qq1
  endif
endif
sse = THR_SSE(yt,xt,ct,cf,THRESH,qq,rr,tt,n,opt_const)
rihat = iminc(sse)'
matrix rhat = qq[rihat]							# Estimated threshold value
matrix sse1 = sse[rihat]						# SSE conditional on previously determined thresholds
lr = (sse/sse1- 1)*ty
rhats = selifr(qq,(lr .&lt; cc))
mout.sse = sse1
if maxc(r) != 0
  matrix rrr = msortby((rr|rhat),1)
else
  matrix rrr = rhat							# rrr are the rr + rhat thresholds
endif
mout.lrstat = lr
mout.rhatCI = (minc(rhats)|rhat|maxc(rhats))'
scalar nr = rows(rrr)
xx = xt
dd = zeros(rows(THRESH),nr)
loop j=1..nr -q									# nr=number of thresholds
  dd[,j] = (THRESH .&lt; rrr[j])					# indicator term THRESH&lt;gamma
  d = dd[,j]
  if j&gt;1										# Only for more than one threshold
    d = d - dd[,j-1]
  endif
  xx = xx~TR(cf.*d,tt,n)						# add interaction-term
endloop
d = 1-dd[,nr]											# indicator term q&gt;gamma
if opt_const==2
  xx = xx ~TR(cf.*d,tt,n) ~ TR(d,tt,n)				# add-regime-dependent intercept unlike in Hansen(1999)
else
  xx = xx~TR(cf.*d,tt,n)								# add constant [ones(rows(xx),1)] unlike in Hansen's code
endif
xxi = inv(xx'*xx)
matrix e = zeros(rows(xx),1)
matrix beta = mols(yt,xx,&amp;e)								# const | beta(X) | beta(RX) | const(R)
xxe = xx.*e
catch sehet = sqrt(diag(xxi*(xxe'*xxe)*xxi))				# White std err
if $error
  print xxi xxe
  stop
endif
catch sehomo = sqrt(diag(xxi*(e'e)/(ty-n-cols(xx))))		# std err
if $error
  print xxi e
  stop
endif
beta = beta~(beta./sehet)~sehomo~sehet				# add t-val. (based on White S.E.)
trrr = rrr'
if opt_const&gt;0
  mattmp = beta[1:(k+1),]							# k+1 for added constant
else
  mattmp = beta[1:k,]
endif
mout.beta_regindep = mattmp[,1]
mout.sehet_regindep = mattmp[,4]
mout.sehomo_regindep = mattmp[,3]
if opt_const==1
  mattmp = beta[k+2:,]							# regime-dependent constant case
  nm = rows(beta[k+2:,])
else
  mattmp = beta[k+1:,]
  nm = rows(beta[k+1:,])
endif
mout.beta_regdep = mattmp[,1]
mout.sehet_regdep = mattmp[,4]
mout.sehomo_regdep = mattmp[,3]
#############
# BOOTSTRAP #
#############
if nrep &gt; 0
  xx = xt~ct
  if abs(maxc(rr))&gt;0
    #if abs(maxc(r))&gt;0
    loop j=1..rows(rr) -q
      matrix tmp = (THRESH .&lt; rr[j])
      xx = xx~TR(cf.*tmp,tt,n) 			# cf refers to the regime-dependent variable
    endloop
    if opt_const==2
      xx = xx ~ TR(tmp,tt,n)				# add-regime-dependent intercept unlike in Hansen(1999)
    endif
  endif
  # START THE BOOTSTRAP PART
  matrix e = zeros(rows(xx),1)
  behat = mols(yt,xx,&amp;e)
  yp = xx*behat				# fitted value
  matrix sse0 = e'e			# SSE based on bootstrap sample and newly determined threshold
  lrt = (sse0/sse1-1)*ty
  # ACTUAL BOOTSTRAP
  matrix stats = zeros(nrep,1)
  # Resids
  e = mshape(e,tt-1,n)
  scalar j=1
  loop while j &lt;= nrep -q
    #####################################################################
    # TODO:																#
    # - IMPLEMENT PARALELLIZATION, atm one iteration takes ca. 1 second!#
    # HANSEN'S PROCEDURE												#
    #	- Draw with uniform probability N rows from the estimated		#
    #		residuals e (N by T)										#
    #####################################################################
    eb = vec(resample(e')')			# Hansen resamples
    # .*mnormal( rows(e),cols(e) )  # wild bootstrap
    yb = yp + eb
    sse0 = SSE_CALC(yb,xt~ct)		# Null model with no thresholds
    sse0 = sse0[1]
    matrix mnull = zeros(1,1)		#
    matrix mrestA = R_EST(yb,xt,ct,cf,THRESH,mnull,trim,qq1,qn1,qn,tt,n,opt_const)
    matrix sse1 = mrestA[1]
    rhat_b = mrestA[2]
    rrr = rhat_b					# estimated threshold based on bootstrap sample
    if abs(maxc(r))&gt;0				# Refinement estimation
      loop jj=1..rows(r) -q
        sse0 = sse1
        # Alternative model allowing for threshold
        matrix mrestB = R_EST(yb,xt,ct,cf,THRESH,rrr,trim,qq1,qn1,qn,tt,n, opt_const)
        sse1 = mrestB[1]
        rhat_b = mrestB[2]
        rrr = rrr|rhat_b
      endloop
    endif
    stats[j] = (sse0/sse1-1)*ty
    #printf &quot;\nIteration %d of %d\n&quot;, j, nrep
    #flush
    j++
  endloop
  /*
  if (failed/nrep)&gt;0
    printf &quot;\n&quot;
    printf &quot;*********************************************************\n&quot;
    printf &quot;Fraction of failed bootstrap iteration = %.4f pct.\n&quot;, failed/nrep*100
    printf &quot;*********************************************************\n&quot;
    flush
  endif
  */
  crits = quantile(stats,0.9)~quantile(stats,0.95)~quantile(stats,0.99)
  #scalar pv = meanc(stats .&gt; lrt)
  scalar pv = sum(stats.&gt;lrt)/nrep
  mout.lrtest = lrt
  mout.lrcrit = crits
  mout.lrprob = pv
endif
return mout
</code>
</gretl-function>
<gretl-function name="printout" type="void">
 <params count="20">
  <param name="beta_indep" type="matrix"/>
  <param name="sehet_indep" type="matrix"/>
  <param name="sehomo_indep" type="matrix"/>
  <param name="beta_dep" type="matrix"/>
  <param name="sehet_dep" type="matrix"/>
  <param name="sehomo_dep" type="matrix"/>
  <param name="rhats" type="matrix"/>
  <param name="sse" type="matrix"/>
  <param name="lrt" type="matrix"/>
  <param name="lrcrits" type="matrix"/>
  <param name="lrprob" type="scalar"/>
  <param name="nrep" type="int"/>
  <param name="strY" type="string"/>
  <param name="strEXO" type="string"/>
  <param name="strREXO" type="string"/>
  <param name="strTHRESH" type="string"/>
  <param name="lreg" type="int"/>
  <param name="iterat" type="int"/>
  <param name="trim" type="scalar"/>
  <param name="opt_const" type="int"/>
 </params>
<code>printf &quot;\n&quot;
if opt_const==1
  printf &quot;Regression with regime-independent constant\n&quot;
elif opt_const==2
  printf &quot;Regression with regime-dependent constant\n&quot;
elif opt_const==0
  printf &quot;Regression without constant\n&quot;
  printf &quot;\n&quot;
endif
if lreg==1
  printf &quot;*******************************************************************************\n&quot;
  printf &quot;*************************\n&quot;
  printf &quot;Single Threshold Model  *\n&quot;
  printf &quot;*************************\n&quot;
elif lreg==2
  printf &quot;*******************************************************************************\n&quot;
  printf &quot;*************************\n&quot;
  printf &quot;Double Threshold Model *\n&quot;
  printf &quot;*************************\n&quot;
  printf &quot;Trimming Percentage \t %.3f\n&quot;, trim
  printf &quot;\n&quot;
  if iterat==1
    printf &quot;First Iteration\n&quot;
  else
    printf &quot;Second Iteration\n&quot;
  endif
elif lreg==3
  printf &quot;*******************************************************************************\n&quot;
  printf &quot;*************************\n&quot;
  printf &quot;Triple Threshold Model  *\n&quot;
  printf &quot;*************************\n&quot;
  printf &quot;Trimming Percentage \t %.3f&quot;, trim
  printf &quot;\n&quot;
  if iterat==1
    printf &quot;First Iteration\n&quot;
  else
    printf &quot;Second Iteration\n&quot;
  endif
endif
if iterat==1
  if lreg&gt;1
    printf &quot;\nFixed Threshold(s) = %12.5f\n&quot;, sort(rhats[1:lreg-1,2])'
    printf &quot;Threshold Estimate = %12.5f\n&quot;, rhats[lreg,2]
  else
    printf &quot;Threshold Estimate = %12.5f\n&quot;, rhats[lreg,2]
  endif
  printf &quot;Confidence Region: \t MIN: %4.5f \t MAX: %4.5f\n&quot;, minr(rhats[lreg,]), maxr(rhats[lreg,])
  printf &quot;Sum of Squared Errors: %12.5f\n&quot;, sse
  printf &quot;Trimming Percentage = %12.3f\n&quot;, trim
  printf &quot;LR-test statistics = %12.3f\n&quot;, lrt
  printf &quot;Number of bootstrap replications = %d\n&quot;, nrep
  printf &quot;Bootstrap p-value: \t %.3f\n&quot;, lrprob
  rownames(lrcrits, &quot;10pct 5pct 1pct&quot;)
  printf &quot;Critical Values: \t 10pct.=%4.3f\t5pct.=%4.3f\t1pct.=%4.3f\n&quot;, lrcrits[1], lrcrits[2], lrcrits[3]
  printf &quot;*******************************************************************************\n&quot;
endif
printf &quot;\nDependent variable: \t %s \n&quot;, strY
printf &quot;Threshold variable: \t %s \n&quot;, strTHRESH
if iterat==1
  printf &quot;First Iteration\n&quot;
else
  printf &quot;Refinement estimations\n&quot;
endif
if opt_const==2
  printf &quot;Regime-dependent variable: %s + const\n&quot;, strREXO
else
  printf &quot;Regime-dependent variable: %s\n&quot;, strREXO
endif
printf &quot;\nRegime-independent Coefficients\n&quot;
matrix mtmp = beta_indep ~ (beta_indep./sehet_indep) ~ sehomo_indep ~ sehet_indep
colnames(mtmp, &quot;Coeff t-val(het) OLS_SE White_SE&quot;)
if opt_const&gt;0
  string rname = &quot;const @strEXO&quot;
else
  string rname = &quot;@strEXO&quot;
endif
rownames(mtmp, &quot;@rname&quot;)
printf &quot;%12.4f\n&quot;, mtmp
printf &quot;\n&quot;
rsorted = sort(rhats[,2])
printf &quot;Regime-dependent Coefficients\n&quot;
if lreg == 1			# single threshold
  sprintf rname &quot;@strREXO*I*(@strTHRESH&lt;=%2.3f) @strREXO*I*(@strTHRESH&gt;%2.3f)&quot;, rsorted, rsorted
elif lreg == 2 			# double threshold
  sprintf rname &quot;@strREXO*I*(@strTHRESH&lt;=%2.3f) @strREXO*I*(%2.3f&lt;@strTHRESH&lt;=%2.3f)            @strREXO*I*(%2.3f&lt;@strTHRESH)&quot;, rsorted[1], rsorted[1], rsorted[2], rsorted[2]
elif lreg == 3			# triple threshold
  sprintf rname &quot;@strREXO*I*(@strTHRESH&lt;=%2.3f) @strREXO*I*(%2.3f&lt;@strTHRESH&lt;=%2.3f)            @strREXO*I*(%2.3f&lt;@strTHRESH&lt;=%2.3f) @strREXO*I*(%2.3f&lt;@strTHRESH)&quot;, rsorted[1], rsorted[1], rsorted[2], rsorted[2], rsorted[3], rsorted[3]
endif
matrix mtmp = beta_dep ~ (beta_dep./sehet_dep) ~ sehomo_dep ~ sehet_dep
colnames(mtmp, &quot;Coeff t-val(het) OLS_SE White_SE&quot;)
rownames(mtmp,&quot;@rname&quot;)
printf &quot;%12.4f\n&quot;, mtmp
printf &quot;\n&quot;
flush
printf &quot;*******************************************************************************\n&quot;
</code>
</gretl-function>
<gretl-function name="linprintout" type="void">
 <params count="8">
  <param name="beta_lin" type="matrix"/>
  <param name="sehet_lin" type="matrix"/>
  <param name="sehomo_lin" type="matrix"/>
  <param name="sse" type="matrix"/>
  <param name="strY" type="string"/>
  <param name="strEXO" type="string"/>
  <param name="strREXO" type="string"/>
  <param name="opt_const" type="int"/>
 </params>
<code>printf &quot;\n&quot;
printf &quot;**********************\n&quot;
printf &quot;Linear Model  *\n&quot;
printf &quot;**********************\n&quot;
printf &quot;\n&quot;
if opt_const==1
  printf &quot;Regression with regime-independent constant\n&quot;
elif opt_const==2
  printf &quot;Regression with regime-dependent constant\n&quot;
elif opt_const==0
  printf &quot;Regression without constant\n&quot;
  printf &quot;\n&quot;
endif
printf &quot;\nSum of Squared Errors: %12.5f\n&quot;, sse
printf &quot;Dependent variable: \t %s \n&quot;, strY
printf &quot;\nCoefficient Estimates\n&quot;
matrix mtmp = beta_lin ~ (beta_lin./sehet_lin) ~ sehomo_lin ~ sehet_lin
colnames(mtmp, &quot;Coeff t-val(het) OLS_SE White_SE&quot;)
if opt_const&gt;0
  string rname = &quot;const @strEXO @strREXO&quot;
else
  string rname = &quot;@strEXO @strREXO&quot;
endif
rownames(mtmp, &quot;@rname&quot;)
printf &quot;%12.4f\n&quot;, mtmp
printf &quot;\n&quot;
flush
printf &quot;*******************************************************************************\n&quot;
</code>
</gretl-function>
<gretl-function name="lrplot" type="void">
 <params count="3">
  <param name="lrstats" type="matrix"/>
  <param name="lrcrit" type="matrix"/>
  <param name="qq" type="matrix"/>
 </params>
<code>loop nplot=1..rows(lrcrit) -q
  matrix mtmp = ones(rows(qq),cols(lrcrit)) .* lrcrit[nplot,]
  matrix mplot = lrstats[,nplot] ~ mtmp ~ qq
  colnames(mplot, &quot;LR-stat. 90pct. 95pct. 99pct. qq&quot;)
  plot mplot
    options with-lines fit=none single-yaxis
    #literal set term png font 'Helvetica,12' lw 2
    literal set title '$nplot Threshold Model'
    literal set xlabel 'Threshold Parameter'
    literal set ylabel 'Likelohood Ratio'
    literal set key top right
  end plot --output=display
endloop
</code>
</gretl-function>
<gretl-function name="TR" type="matrix" private="1">
 <params count="3">
  <param name="y" type="matrix"/>
  <param name="tt" type="scalar"/>
  <param name="n" type="scalar"/>
 </params>
<code># This function generates the mean deviations
# for the FE-estimator
yf = mshape(y,tt,n)'
yfm = yf .- meanr(yf)
yfm = yfm[,1:tt-1]
return (vec(yfm'))
</code>
</gretl-function>
<sample-script>
#*****************************************************************************
# EXAMPLE: Replication of Hansen's results in Journal of Econometrics (1999)
#*****************************************************************************
#clear
#open http://www.wiso.uni-hamburg.de/fileadmin/sozialoekonomie/vwl/fritsche/Tarassow/invest_joe99.gdt
open invest_joe99.gdt --frompkg=Threshold_Panel
include Threshold_Panel.gfn

# LOAD DATASET
list linvest = inva vala cfa debta
matrix invest = { linvest }
matrix i = invest[,1]     # investment/assets                             #
matrix q = invest[,2]     # Tobin's Q                                     #
matrix c = invest[,3]     # cash-flow/assets                              #
matrix d = invest[,4]     # debt/assets                                   #
scalar N = 565
scalar T = 15

# Shrink the orginal dataset for illustrative reasons
# Comment the lines below for replicating the Hansen's results exactly! #
# --- from here -------------------
scalar nsel = 20
matrix i = mshape(i,T,N)
i = vec(i[,1:nsel])
matrix q = mshape(q,T,N)
q = vec(q[,1:nsel])
matrix c = mshape(c,T,N)
c = vec(c[,1:nsel])
matrix d = mshape(d,T,N)
d = vec(d[,1:nsel])
# --- to here ---------------------

# SET UP MODEL PARAMETERS
scalar nthresh = 2				# Max. # of thresholds to test, Hansen (1999) ntresh=3
scalar opt_const = 0			# Hansen (1999) opt_const=0
scalar max_lag = 1
scalar t = 15
scalar nt = rows(i)	#rows(invest)
scalar n = nt/t
scalar qn = 300					# Hansen (1999) qn=400
scalar nrep = 100				# Hansen (1999) nrep=300
scalar trim_1 = 0.01			# Hansen (1999) trim_1=0.01
scalar trim_2 = 0.01			# Hansen (1999) trim_2=0.01
scalar trim_3 = 0.05			# Hansen (1999) trim_3=0.05
scalar conf_lev = 0.95			# Hansen (1999) conf_lev=0.95

# LAGS
matrix y = LAG_V(i,0,t,n,max_lag)
matrix q1 = LAG_V(q,1,t,n,max_lag)
matrix d1 = LAG_V(d,1,t,n,max_lag)
matrix cf = LAG_V(c,1,t,n,max_lag)
matrix THRESH = d1					# set to threshold variable

# SET UP THE MODEL SPECIFICATION
# Further regime-independent regressors following Hansen (1999) eq. (22)
matrix x = q1~(q1.^2)~(q1.^3)~d1~(q1.*d1)

# RUN THE MODEL(S)
set stopwatch
bundle B = THRESH_SETUP(y,x,cf,d1, &quot;i&quot;, &quot;q1 q1_sq q1_tr d1 q1d1&quot;, \
  &quot;cf&quot;, &quot;d&quot;, nthresh, opt_const, max_lag, t, \
  qn, nrep, trim_1, trim_2, trim_3, conf_lev)
printf &quot;\n This took %.2f seconds\n&quot;, $stopwatch

# Plot the Likelihood Ratio test confidence interval
matrix qq = B.qq1
matrix lrstats = B.lrstats
matrix lrcrit = B.lrcrit
lrplot(lrstats, lrcrit, qq)
</sample-script>
</gretl-function-package>
</gretl-functions>
