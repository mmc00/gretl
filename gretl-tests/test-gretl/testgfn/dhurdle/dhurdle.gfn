<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="dhurdle" ID="1431854948" minver="1.10.0" lives-in-subdir="true">
<author email="r.lucchetti@univpm.it">Riccardo &quot;Jack&quot; Lucchetti</author>
<version>1.22</version>
<date>2015-07-13</date>
<description>Double-hurdle model</description>
<label>Double-hurdle</label>
<menu-attachment>MAINWIN/Model/LimdepModels</menu-attachment>
<help>
This package estimates the so-calles &quot;double-hurdle&quot; model, also 
known as two-part, or Cragg's model. It's basically a Tobit model 
with sample selection, that is:

s = Z * gamma + u
ystar = X * beta + e
y = (s&gt;0) &amp;&amp; (ystar&gt;0) ? ystar : 0

and rho is the correlation coefficient between u and e. 

================================================================
main function
================================================================
Syntax: dhurdle(series depvar, list X, list Z, scalar verbose[0], 
		boolean robust[1], scalar grid[0])	 

  depvar: series, dependent variable
       X: list, explanatory variables for main equation
       Z: list, explanatory variables for selection equation
 verbose: (optional) scalar, 0 = silent, 1 = just output, 
          2 = show iterations
  robust: (optional) scalar, 0 = Hessian, 1 = sandwich
    grid: (optional) scalar, default 0.
          if 0 &lt; grid &lt; 1, a preliminary grid search on rho



================================================================
auxiliary function
================================================================
Syntax: dhurdle_bundle_print(bundle *mod)

Prints out a model generated by the dhurdle() function
</help>
<data-files count="1">
tobacco.gdt </data-files>
<gretl-function name="dhurdle" type="bundle">
 <params count="6">
  <param name="depvar" type="series">
<description>Dependent variable</description>
  </param>
  <param name="X" type="list">
<description>Main eq. regressors</description>
  </param>
  <param name="Z" type="list">
<description>Selection eq. regressors</description>
  </param>
  <param name="verbose" type="scalar" min="0" max="2" default="1">
<description>Verbosity</description>
  </param>
  <param name="robust" type="bool" default="1">
<description>Robust</description>
  </param>
  <param name="grid" type="scalar" default="0">
<description>Grid search (0 for none)</description>
  </param>
 </params>
<code>bundle ret
ret[&quot;creator&quot;] = &quot;dhurdle&quot;
list everything = depvar X
list everything = everything || Z
smpl ok(everything) --restrict
ret[&quot;nobs&quot;] = $nobs
ret[&quot;y&quot;]    = depvar
ret[&quot;mX&quot;]   = {X}
ret[&quot;mZ&quot;]   = {Z}
ret[&quot;s_y&quot;]  = argname(depvar)
ret[&quot;s_X&quot;]  = varname(X)
ret[&quot;s_Z&quot;]  = varname(Z)
ret[&quot;robust&quot;] = robust
series ll
matrix score
d = (depvar&gt;0)
ret[&quot;d&quot;]    = d
ret[&quot;cens&quot;] = sum(!d)
HECKIT_INIT = 0
if HECKIT_INIT == 0
  coeff = dhurdle_init(depvar, d, X, Z, verbose)
  coeff = dhurdle_init_dep(coeff, depvar, d, X, Z, grid, verbose)
else
  coeff = dhurdle_heckit_init(depvar, d, X, Z, verbose)
endif
if verbose &lt; 2
  mlestring = &quot;-q&quot;
elif verbose == 2
  mlestring = &quot;-v&quot;
else
  printf &quot;Starting values:\n%12.4f\n&quot;, coeff
  mlestring = &quot;-v&quot;
endif
ret[&quot;inival&quot;] = coeff
set warnings off
mle loglik = err ? NA : ll
  err = dhurdle_ll_score(&amp;depvar, &amp;d, X, Z, &amp;coeff, &amp;ll, &amp;score)
  deriv coeff = score
end mle @mlestring
ret[&quot;coeff&quot;] = coeff
ret[&quot;OPG&quot;]   = score
ret[&quot;llt&quot;]   = ll
ret[&quot;lnl&quot;]   = $lnl
V = dhurdle_vcv(robust+1, &amp;depvar, &amp;d, X, Z, &amp;coeff)
ret[&quot;vcv&quot;] = V
#   ret[&quot;iH&quot;] = dhurdle_nhess(&amp;depvar, &amp;d, X, Z, &amp;coeff)
if verbose &gt; 0
  dh_bundle_print(&amp;ret)
endif
return ret
</code>
</gretl-function>
<gretl-function name="dh_bundle_print" type="void">
 <params count="1">
  <param name="mod" type="bundleref"/>
 </params>
<code>k1 = cols(mod[&quot;mX&quot;])
k2 = cols(mod[&quot;mZ&quot;])
coef = mod[&quot;coeff&quot;]
se   = sqrt(diag(mod[&quot;vcv&quot;]))
sig   = exp(coef[k1+k2+1])
sesig = se[k1+k2+1]*sig
arho = coef[k1+k2+2]
rho = 1 - 2/(exp(2*arho) + 1)
rho = tanh(coef[k1+k2+2])
serho = se[k1+k2+2] * (1-rho^2)
printf &quot;\nDouble hurdle model&quot;
if mod[&quot;robust&quot;]
  printf &quot; (robust standard errors)\n&quot;
else
  printf &quot; (standard errors from Hessian)\n&quot;
endif
printf &quot;\nMain equation\n&quot;
printf &quot;----------------------------------------------------------&quot;
parstr = mod[&quot;s_X&quot;]
cs = coef[1:k1] ~ se[1:k1]
modprint cs parstr
printf &quot;Selection equation\n&quot;
printf &quot;----------------------------------------------------------&quot;
parstr = mod[&quot;s_Z&quot;]
cs = coef[k1+1:k1+k2] ~ se[k1+1:k1+k2]
modprint cs parstr
printf &quot;----------------------------------------------------------&quot;
theta = {sig, sesig ; rho, serho }
parstr = &quot;sigma,rho&quot;
modprint theta parstr
T = mod[&quot;nobs&quot;]
C = mod[&quot;cens&quot;]
printf &quot;    Total observations = %d\n&quot;, T
printf &quot; Censored observations = %d (%.2f%% of total)\n&quot;, C, 100*(C/T)
printf &quot;        log-likelihood = %14.6f\n\n&quot;, mod[&quot;lnl&quot;]
</code>
</gretl-function>
<gretl-function name="GUI_dhurdle" type="bundle">
 <params count="4">
  <param name="y" type="series">
<description>Dependent variable</description>
  </param>
  <param name="X" type="list">
<description>Explanatory variables</description>
  </param>
  <param name="Z" type="list">
<description>Explanatory var. for the selection eq.</description>
  </param>
  <param name="verb" type="scalar" min="0" max="2" default="1">
<description>Verbosity</description>
  </param>
 </params>
<code>bundle ret = dhurdle(y, X, Z, verb)
return ret
</code>
</gretl-function>
<gretl-function name="dhurdle_loglik" type="series" private="1">
 <params count="5">
  <param name="depvar" type="seriesref"/>
  <param name="d" type="seriesref"/>
  <param name="X" type="list" const="true"/>
  <param name="Z" type="list" const="true"/>
  <param name="coef" type="matrixref"/>
 </params>
<code>k1 = nelem(X)
k2 = nelem(Z)
matrix selbeta = seq(1,k1)
matrix selgamma = k1 + seq(1,k2)
scalar sellsig = k1 + k2 + 1
scalar sela = k1 + k2 + 2
bet  = coef[selbeta]
gam  = coef[selgamma]
lsig = coef[sellsig]
sig  = exp(lsig)
series ndx_a = lincomb(Z, gam)
series ndx_b = lincomb(X, bet/sig)
series e = depvar/sig - ndx_b
# log of normal density
lng = -.91893853320467274177 - lsig - 0.5*(e*e)
ca = cosh(coef[sela])
sa = sinh(coef[sela])
rho = sa/ca
F = cnorm(ca * ndx_a + sa * e)
G = cdf(D, rho, ndx_a, ndx_b)
series ret = d ? ln(F) + lng : ln(1-G)
return ret
</code>
</gretl-function>
<gretl-function name="ddh_score0" type="matrix" private="1">
 <params count="8">
  <param name="G" type="seriesref"/>
  <param name="a" type="seriesref"/>
  <param name="b" type="seriesref"/>
  <param name="X" type="list"/>
  <param name="Z" type="list"/>
  <param name="ca" type="scalar"/>
  <param name="sa" type="scalar"/>
  <param name="sig" type="scalar"/>
 </params>
<code>matrix tmp = ca*a - sa*b
matrix dnb = dnorm(b)
matrix tmp1 = dnb .* cnorm(tmp)
matrix tmp2 = dnorm(a) * cnorm(ca*b - sa*a)
matrix ret = (1/sig) * tmp1 .* { X }
matrix ret ~= tmp2 .* { Z }
matrix ret ~= -tmp1 .* b
matrix ret ~= ((1/ca) * dnb) .* dnorm(tmp)
return ret ./ (G-1)
</code>
</gretl-function>
<gretl-function name="ddh_score1a" type="matrix" private="1">
 <params count="7">
  <param name="a" type="seriesref"/>
  <param name="e" type="seriesref"/>
  <param name="X" type="list"/>
  <param name="Z" type="list"/>
  <param name="ca" type="scalar"/>
  <param name="sa" type="scalar"/>
  <param name="sig" type="scalar"/>
 </params>
<code>series tmp = ca*a + sa*e
matrix ret = -(sa/sig) .* { X }
matrix ret ~= ca .* { Z }
matrix ret ~= -sa*e
matrix ret ~= (sa*a + ca*e)
return ret .* invmills(-tmp)
</code>
</gretl-function>
<gretl-function name="ddh_score1b" type="matrix" private="1">
 <params count="4">
  <param name="e" type="seriesref"/>
  <param name="X" type="list"/>
  <param name="k2" type="scalar"/>
  <param name="sig" type="scalar"/>
 </params>
<code>matrix ret = (e/sig) .* { X }
matrix adj = zeros(rows(ret), k2 + 2)
matrix adj[,k2+1] = e*e - 1
return ret ~ adj
</code>
</gretl-function>
<gretl-function name="dhurdle_score" type="matrix" private="1">
 <params count="5">
  <param name="depvar" type="seriesref"/>
  <param name="d" type="seriesref"/>
  <param name="X" type="list" const="true"/>
  <param name="Z" type="list" const="true"/>
  <param name="coef" type="matrixref"/>
 </params>
<code>k1 = nelem(X)
k2 = nelem(Z)
matrix selbeta  = seq(1,k1)
matrix selgamma = k1 + seq(1,k2)
scalar sellsig  = k1 + k2 + 1
scalar sela     = sellsig + 1
matrix bet = coef[selbeta]
matrix gam = coef[selgamma]
sig = exp(coef[sellsig])
ndx_a = lincomb(Z, gam)
ndx_b = lincomb(X, bet/sig)
series e = depvar/sig - ndx_b
ca = cosh(coef[sela])
sa = sinh(coef[sela])
G = cdf(D, sa/ca, ndx_a, ndx_b)
matrix S0 = ddh_score0(&amp;G, &amp;ndx_a, &amp;ndx_b, X, Z, ca, sa, sig)
matrix S1a = ddh_score1a(&amp;ndx_a, &amp;e, X, Z, ca, sa, sig)
matrix S1b = ddh_score1b(&amp;e, X, k2, sig)
matrix D = { d }
matrix ret = D .* (S1a + S1b) + (1-D) .* S0
return ret
</code>
</gretl-function>
<gretl-function name="dhurdle_ll_score" type="scalar" private="1">
 <params count="7">
  <param name="depvar" type="seriesref"/>
  <param name="d" type="seriesref"/>
  <param name="X" type="list" const="true"/>
  <param name="Z" type="list" const="true"/>
  <param name="coef" type="matrixref"/>
  <param name="ll" type="seriesref"/>
  <param name="score" type="matrixref"/>
 </params>
<code>scalar k1 = nelem(X)
scalar k2 = nelem(Z)
matrix selbeta  = seq(1,k1)
matrix selgamma = k1 + seq(1,k2)
scalar sellsig  = k1 + k2 + 1
scalar sela     = sellsig + 1
matrix bet = coef[selbeta]
matrix gam = coef[selgamma]
scalar lsig = coef[sellsig]
scalar sig = exp(lsig)
series ndx_a = lincomb(Z, gam)
series ndx_b = lincomb(X, bet/sig)
series e = depvar/sig - ndx_b
# log of normal density
series lng = -.91893853320467274177 - lsig - 0.5*(e*e)
scalar out_of_range = 0
if max(ndx_a) &gt; 30 # Mills ratio goes to 0
  out_of_range = 1
else
  scalar ca = cosh(coef[sela])
  scalar sa = sinh(coef[sela])
  scalar rho = sa/ca
  series F = cnorm(ca * ndx_a + sa * e)
  series G = cdf(D, rho, ndx_a, ndx_b)
  matrix S0  = ddh_score0(&amp;G, &amp;ndx_a, &amp;ndx_b, X, Z, ca, sa, sig)
  matrix S1a = ddh_score1a(&amp;ndx_a, &amp;e, X, Z, ca, sa, sig)
  matrix S1b = ddh_score1b(&amp;e, X, k2, sig)
endif
if out_of_range==1
  series ll = NA
  matrix score = {}
  scalar err = 1
else
  series ll = d ? ln(F) + lng : ln(1-G)
  matrix D = { d }
  matrix score = D .* (S1a + S1b) + (1-D) .* S0
  scalar err = 0
endif
flush
return err
</code>
</gretl-function>
<gretl-function name="dhurdle_sscore" type="matrix" private="1">
 <params count="5">
  <param name="depvar" type="seriesref"/>
  <param name="d" type="seriesref"/>
  <param name="X" type="list" const="true"/>
  <param name="Z" type="list" const="true"/>
  <param name="coef" type="matrixref"/>
 </params>
<code>matrix ret = dhurdle_score(&amp;depvar, &amp;d, X, Z, &amp;coef)
return sumc(ret)'
</code>
</gretl-function>
<gretl-function name="dhurdle_nhess" type="matrix" private="1">
 <params count="5">
  <param name="depvar" type="seriesref"/>
  <param name="d" type="seriesref"/>
  <param name="X" type="list" const="true"/>
  <param name="Z" type="list" const="true"/>
  <param name="coef" type="matrixref"/>
 </params>
<code>lc = coef
matrix H = fdjac(lc, dhurdle_sscore(&amp;depvar, &amp;d, X, Z, &amp;lc))
H = -0.5*(H+H')
#    printf &quot;Inverting Hessian...\n&quot;
H = invpd(H)
return H
</code>
</gretl-function>
<gretl-function name="dhurdle_loglik_given_rho" type="series" private="1">
 <params count="6">
  <param name="depvar" type="seriesref"/>
  <param name="d" type="seriesref"/>
  <param name="X" type="list" const="true"/>
  <param name="Z" type="list" const="true"/>
  <param name="rho" type="scalar"/>
  <param name="coef" type="matrixref"/>
 </params>
<code>k1 = nelem(X)
bet = coef[1:k1]
k2 = nelem(Z)
gam = coef[k1+1:k1+k2]
lsig = coef[k1+k2+1]
sig = exp(lsig)
ndx_a = lincomb(Z, gam)
ndx_b = lincomb(X, bet/sig)
e = depvar/sig - ndx_b
# log of normal density
lng = -.91893853320467274177 - lsig - 0.5*(e*e)
F = cnorm((ndx_a + rho*e)/sqrt(1-rho^2))
G = cdf(D, rho, ndx_a, ndx_b)
series ret = d ? ln(F) + lng : ln(1-G)
return ret
</code>
</gretl-function>
<gretl-function name="dhurdle_profile" type="matrix" private="1">
 <params count="5">
  <param name="depvar" type="series"/>
  <param name="X" type="list"/>
  <param name="Z" type="list"/>
  <param name="start" type="matrix"/>
  <param name="step" type="scalar" default="0.1"/>
 </params>
<code>list everything = depvar X Z
list everything = everything || Z
smpl ok(everything) --restrict
d = (depvar&gt;0)
mlestring = &quot;-q&quot;
/*
if verbose==0
  mlestring = &quot;-q&quot;
elif verbose==1
  mlestring = &quot;&quot;
elif verbose==2
  mlestring = &quot;-v&quot;
else
  printf &quot;Starting values:\n%12.4f\n&quot;, coeff
  mlestring = &quot;-rv&quot;
endif
*/
set warnings off
matrix results = {}
maxcoef = {}
maxll = -$huge
npar = nelem(X) + nelem(Z) + 1
series ll
matrix score
coeff = start[1:npar]
set bfgs_toler 1.0e-5
mle loglik = err ? NA : ll
  coef2 = coeff | 0
  err = dhurdle_ll_score(&amp;depvar, &amp;d, X, Z, &amp;coef2, &amp;ll, &amp;score)
  deriv coeff = score[, 1:npar]
end mle -q # @mlestring
llmax = sum(ll)
if (llmax&gt;maxll)
  maxll = llmax
  maxcoeff = coef2
endif
results |= {0 , llmax}
coeff = coef2[1:npar]
rho = step
loop while rho&lt;0.99 --quiet
  arho = atanh(rho)
  mle loglik = err ? NA : ll
    coef2 = coeff | arho
    err = dhurdle_ll_score(&amp;depvar, &amp;d, X, Z, &amp;coef2, &amp;ll, &amp;score)
    deriv coeff = score[, 1:npar]
  end mle -q # @mlestring
  llmax = sum(ll)
  if (llmax&gt;maxll)
    maxll = llmax
    maxcoeff = coef2
  endif
  #	printf &quot;rho = %6.3f, loglikelihood = %16.10f\n&quot;, rho, llmax
  results |= {rho , llmax}
  rho += step
endloop
coeff = start[1:npar]
rho = -step
loop while rho&gt;-0.99 --quiet
  arho = atanh(rho)
  mle loglik = err ? NA : ll
    coef2 = coeff | { arho }
    err = dhurdle_ll_score(&amp;depvar, &amp;d, X, Z, &amp;coef2, &amp;ll, &amp;score)
    deriv coeff = score[, 1:npar]
  end mle -q # @mlestring
  llmax = sum(ll)
  if (llmax&gt;maxll)
    maxll = llmax
    maxcoeff = coef2
  endif
  #	printf &quot;rho = %6.3f, loglikelihood = %16.10f\n&quot;, rho, llmax
  results |= {rho , llmax}
  rho -= step
endloop
set bfgs_toler default
results = msortby(results, 1)
#    results = results'
printf &quot;%12.4f&quot;, results
return maxcoeff
</code>
</gretl-function>
<gretl-function name="dhurdle_init" type="matrix" private="1">
 <params count="5">
  <param name="depvar" type="series"/>
  <param name="d" type="series"/>
  <param name="X" type="list"/>
  <param name="Z" type="list"/>
  <param name="verbose" type="scalar" default="0"/>
 </params>
<code>k1 = nelem(X)
k2 = nelem(Z)
if verbose &lt; 3
  init_verb = &quot;--quiet&quot;
else
  init_verb = &quot;&quot;
endif
probit d Z @init_verb
matrix gam = $coeff
u = $uhat
series tmpy = d ? depvar : NA
ols tmpy X u @init_verb
matrix bet = $coeff[1:k1]
scalar s = ln($sigma)
matrix coeff = bet | gam | s
if verbose&gt;2
  printf &quot;Initial values: \n%g&quot;, coeff'
endif
return coeff
</code>
</gretl-function>
<gretl-function name="dhurdle_heckit_init" type="matrix" private="1">
 <params count="5">
  <param name="depvar" type="series"/>
  <param name="d" type="series"/>
  <param name="X" type="list"/>
  <param name="Z" type="list"/>
  <param name="verbose" type="scalar" default="0"/>
 </params>
<code>/*
This applies to the dependent model only
*/
k1 = nelem(X)
k2 = nelem(Z)
heckit depvar X ; d Z --quiet
#    printf &quot;Heckit init: err = %d\n&quot;, $error
matrix bet = $coeff[1:k1]
matrix gam = $coeff[k1+2:k1+k2+1]
scalar s = ln($sigma)
scalar arho = atanh($rho)
matrix coeff = bet | gam | s | arho
if verbose&gt;2
  printf &quot;Initial values: \n%g&quot;, coeff'
endif
return coeff
</code>
</gretl-function>
<gretl-function name="dhurdle_init_dep" type="matrix" private="1">
 <params count="7">
  <param name="coeff0" type="matrix"/>
  <param name="depvar" type="series"/>
  <param name="d" type="series"/>
  <param name="X" type="list"/>
  <param name="Z" type="list"/>
  <param name="grid" type="scalar" default="0"/>
  <param name="verbose" type="scalar" default="0"/>
 </params>
<code>/*
It's assumed we have an initial guess for everything but rho, typically, this comes from the independent model, but not necessarily.
Then, if grid&gt;0 we do the grid search, else we do one by-hand BHHH
iteration to find an initial guess
*/
theta_z = coeff0 | {0}
if grid == 0
  # 	we do a bit of cheating here: given the estimates under
  # 	independence (easier to do), we compute an initial guess of
  # 	atrho by the score. The reason why we don't let BFGS do this
  # 	automatically is that we're being more conservative here than
  # 	BFGS, which spares us a few nasty numerical issues
  score = dhurdle_score(&amp;depvar, &amp;d, X, Z, &amp;theta_z)
  # debug
  #GG = score'score
  # print GG
  #mwrite(GG, &quot;foo.mat&quot;)
  #mwrite(score, &quot;bar.mat&quot;)
  # end debug
  ds = mols(ones(rows(score), 1), score) # fixme: be smarter here
  coeff = theta_z + 0.25*ds
else
  coeff = theta_z
  printf &quot;-------------------- GRID SEARCH --------------------\n&quot;
  coeff = dhurdle_profile(depvar, X, Z, coeff, grid)
  printf &quot;-----------------------------------------------------\n&quot;
endif
return coeff
</code>
</gretl-function>
<gretl-function name="dhurdle_vcv" type="matrix" private="1">
 <params count="6">
  <param name="type" type="scalar"/>
  <param name="depvar" type="seriesref"/>
  <param name="d" type="seriesref"/>
  <param name="X" type="list" const="true"/>
  <param name="Z" type="list" const="true"/>
  <param name="coeff" type="matrixref"/>
 </params>
<code>/*
type: 0 -&gt; OPG
1 -&gt; iHess
2 -&gt; sandwich
*/
if (type==0) || (type==2)
  matrix score = dhurdle_score(&amp;depvar, &amp;d, X, Z, &amp;coeff)
  V = score'score
endif
if (type==1) || (type==2)
  matrix iH = dhurdle_nhess(&amp;depvar, &amp;d, X, Z, &amp;coeff)
endif
if type == 0
  #        printf &quot;Inverting OPG matrix...\n&quot;
  V = invpd(V)
elif type == 1
  V = iH
elif type == 2
  V = qform(iH, V)
endif
return V
</code>
</gretl-function>
<sample-script>
# sample function call
# From the examples datasets supplied with
# M. Verbeek, &quot;A Guide to Modern Econometrics&quot;

open tobacco.gdt --quiet --frompkg=dhurdle
include dhurdle.gfn

# dependent variable: tobacco expenditure share
series tobacco_share = misszero(w2) 

# main equation: explanatory variables
series l_nad = ln(nadults)
series ladlx = l_nad * lnx
list X = const bluecol whitecol flanders walloon l_nad lnx ladlx

# selection equation: extra variables
list Z = nkids nkids2 age age2

# estimate and print
dhmod = dhurdle(tobacco_share, X, X || Z, 0)
dh_bundle_print(&amp;dhmod)

# or simply:
# dhmod = dhurdle(tobacco_share, X, X || Z, 1)
</sample-script>
</gretl-function-package>
</gretl-functions>
