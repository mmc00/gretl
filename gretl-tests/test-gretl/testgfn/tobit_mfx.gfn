<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="tobit_mfx" ID="1437918632" minver="1.9.12">
<author email="oleg_komashko@ukr.net">Oleh Komashko</author>
<version>0.2</version>
<date>2015-07-26</date>
<description>marginal effects after tobit and censored regression</description>
<label>marginal effects</label>
<menu-attachment>MODELWIN/Analysis</menu-attachment>
<help>
Marginal effects after the tobit and censored regression

This package serves to calculate marginal effects and associated
statistics (standard errors, z-values and p-values) for censored
regression models (including simple Tobit).
Currently the package calculates only one type of effects:
∂E[y_i|x_i]/∂x_i, where y is the observed variable
(see Greene(2003), subs. 22.3.2).

The package offers a graphical interface which is designed to appear 
under the Analysis menu in gretl's model window; this is hard-wired
to produce marginal effects at the sample means of all the regressors.

The package interface is intended to be maximally similar
to that of lp-mfx package by Allin Cottrell.

Two public functions are available.

1) tobit_mfx calculates marginal effects for each possible outcome at 
the sample means, along with standard errors via the delta method, 
and they return a bundle containing all the results.

function bundle tobit_mfx (series y &quot;dependent variable&quot;,
                           list XL &quot;list of regressors&quot;,
                           scalar lo[0] &quot;left limit&quot;,
                           scalar hi[NA] &quot;rigt limit&quot;)

See the sample script for the use of default values of the cencoring
points.

This function is intended to use alongside with tobit_mfx_print (bundle *b)
function for nice printing of the results (see the sample script).
Note that the output bundle contains the covariance
matrix of the marginal effects. Hence, an user could easy calculate
marginal effects of functions of the regressors.

2) tobit_dp_dx function accept a k-vector, x, containing the values of the regressors 
at which the marginal effects should be found, and they return the k-vector of 
effects pertaining to a specific selected outcome.

function matrix tobit_dp_dx (matrix b &quot;parameter estimates&quot;,
                             list XL &quot;list of regressors&quot;,
                             matrix x &quot;vector of x-values&quot;,
                             scalar s &quot;sigma parameter of the tobit model&quot;,
                             scalar lo[0] &quot;left limit&quot;,
                             scalar hi[NA] &quot;right limit&quot;)




Dummy variables (0/1) are detected and the marginal effect is
calculated as the effect of a discrete change from 0 to 1.

Notes:
tobit_mfx estimates the cencored regression model independently.
Currently, mle block with numerical derivatives is used.

tobit_dp_dx relies upon the native tobit command.

Refefences

Gretl User's Guide
Gretl lp-mfx package

Greene William H. (2003). Econometric Analysis, Upper Saddle River, NJ: Prentice-Hall, 	    fifth edn.

Maddala, G. (1983). Limited Dependent and Qualitative Variables in Econometrics. New 	  York: Cambridge University Press.

Appendix
Stata (TM) commands to compare the results of the sample scripts

# load the data
use &quot;http://www.dartmouth.edu/~econ20pa/affairs.dta&quot;

# tobit_mfx_print(&amp;b1)
. tobit naffairs male age yrsmarr relig occup ratemarr, ll(0)
. mfx compute, predict(ystar(0,.))

# tobit_mfx_print(&amp;b2)
. tobit naffairs male age yrsmarr relig occup ratemarr, ll(1)
. mfx compute, predict(ystar(1,.))

# tobit_mfx_print(&amp;b3)

. tobit naffairs male age yrsmarr relig occup ratemarr, ul(4)
. mfx compute, predict(ystar(.,4))

# tobit_mfx_print(&amp;b4)

. tobit naffairs male age yrsmarr relig occup ratemarr, ll(0) ul(4)
. mfx compute, predict(ystar(0,4))
</help>
<gretl-function name="GUI_tobit_mfx" type="bundle" no-print="1" menu-only="1" pkg-role="gui-main">
<code>## no-print ##
list Y = $ylist
string yname = $depvar
loop foreach i Y
  series @yname = Y.$i
endloop
bundle b
catch scalar ll = $[&quot;llimit&quot;]
err1 = $error
print err1
#     if (err)
#         ll = -$huge
#     endif
#     print ll
catch scalar rl = $[&quot;rlimit&quot;]
err2 = $error
print err2
if (err2)
  rl = $huge
endif
print rl
if (err1)
  if (err2)
    ll = 0
  else
    ll = -$huge
  endif
endif
print ll
#     catch scalar mn = $[&quot;multinom&quot;]
#     scalar err = $error
#     if !err
#         b = mlogit_mfx(@yname, $xlist, $coeff, $vcv, $sample)
#     else
#         string cmd = $command
#         scalar dist = (cmd == &quot;logit&quot;)? 1 : 2
#         catch scalar mn = $[&quot;ordered&quot;]
#         scalar err = $error
#         if !err
#             b = ordered_mfx(@yname, $xlist, $coeff, $vcv, $sample, dist)
#         else
#             b = binary_mfx(@yname, $xlist, $coeff, $vcv, $sample, dist)
#         endif
#     endif
#z = $xlist
b = tobit_mfxguj(@yname , $xlist,ll,rl)
return b
</code>
</gretl-function>
<gretl-function name="tobit_mfx" type="bundle">
 <params count="4">
  <param name="y" type="series">
<description>dependent variable</description>
  </param>
  <param name="XL" type="list">
<description>list of regressors</description>
  </param>
  <param name="lo" type="scalar" default="0">
<description>left limit</description>
  </param>
  <param name="hi" type="scalar" default="NA">
<description>rigt limit</description>
  </param>
 </params>
<code>#     if missing(hi)
#         hi = $huge
#     endif
bundle ret
string yname = argname(y)
ret[&quot;model&quot;] = &quot;Censored regression&quot;
ret[&quot;yname&quot;] = yname
matrix x = ones(1, nelem(XL))
list D = null
loop foreach i XL -q
  if varnum(XL.$i) &gt; 0
    x[i] = mean(XL.$i)
    if isdummy(XL.$i)
      D += XL.$i
    endif
  endif
endloop
if nelem(D) &gt; 0
  ret[&quot;Dnames&quot;] = varname(D)
endif
bigmatr = tobit_estimate3all(y,XL,lo,hi)
rbm = rows(bigmatr)
Vbig = bigmatr[,2:]
alltheta = bigmatr[,1]
theta = alltheta[1:(rbm-1)]
s = alltheta[rbm]
scalar meanprob = tobit_exp (theta,x,s,lo,hi)
ret[&quot;mean_depvar&quot;] = meanprob
matrix xbar = inlist(XL, 0) ? (x[2:]') : x'
matrix dp = tobit_dp_dx(theta, XL, x, s,lo,hi)'
#set fdjac_quality 1
matrix J = fdjac(alltheta, tobit_dp_dx2(alltheta, XL, x,lo,hi))
#set fdjac_quality 0
matrix Vdp = qform(J, Vbig)
matrix se = sqrt(diag(Vdp))
matrix zval = dp ./ se
matrix pval = 2 * pvalue(z, abs(zval))
matrix res = dp ~ se ~ zval ~ pval ~ xbar
colnames(res, &quot;dp/dx s.e. z pval xbar&quot;)
rownames(res, XL - 0)
ret[&quot;mfx&quot;] = res
ret[&quot;vcv&quot;] = Vdp
if missing(lo)
  lo = -$huge
endif
if missing(hi)
  hi = $huge
endif
ret[&quot;left&quot;] = lo
ret[&quot;right&quot;] = hi
return ret
</code>
</gretl-function>
<gretl-function name="tobit_mfx_print" type="void" pkg-role="bundle-print">
 <params count="1">
  <param name="b" type="bundleref"/>
 </params>
<code>string model = b[&quot;model&quot;]
matrix mp = b[&quot;mean_depvar&quot;]
string yname = b[&quot;yname&quot;]
catch string Dnames = b[&quot;Dnames&quot;]
printf &quot;\n%s marginal effects\n&quot;, model
printf &quot;(evaluated at means of regressors)\n&quot;
if !isnull(Dnames)
  printf &quot;\nnote: dp/dx based on discrete change for %s\n&quot;, Dnames
endif
printf &quot;\n&quot;
matrix res = b[&quot;mfx&quot;]
scalar lo =  b[&quot;left&quot;]
scalar hi = b[&quot;right&quot;]
if (lo == -$huge)
  printf &quot;E(%s*|%s &lt; %.1f) = %.4f\n\n%#12.5g\n&quot;, yname, yname,hi, mp, res
elif (hi == $huge)
  printf &quot;E(%s*|%s &gt; %.1f) = %.4f\n\n%#12.5g\n&quot;, yname, yname,lo, mp, res
else
  printf &quot;E(%s*|%.1f &lt; %s &lt; %.1f) = %.4f\n\n%#12.5g\n&quot;, yname, lo, yname, hi, mp, res
endif
</code>
</gretl-function>
<gretl-function name="tobit_dp_dx" type="matrix">
 <params count="6">
  <param name="b" type="matrix">
<description>parameter estimates</description>
  </param>
  <param name="XL" type="list">
<description>list of regressors</description>
  </param>
  <param name="x" type="matrix">
<description>vector of x-values</description>
  </param>
  <param name="s" type="scalar">
<description>sigma parameter of the tobit model</description>
  </param>
  <param name="lo" type="scalar" default="0">
<description>left limit</description>
  </param>
  <param name="hi" type="scalar" default="NA">
<description>right limit</description>
  </param>
 </params>
<code># Computes the &quot;slope&quot; of the probability that y = 1
# with respect to each regressor
#
# Returns a (row) k-vector, where k is the number of
# regressors (omitting the constant, if present)
scalar ifc = inlist(XL, 0)
nc = cols(b)
nr = rows(b)
if (nc&gt;nr)
  b = b'
endif
nc = cols(x)
nr = rows(x)
if (nc&lt;nr)
  x = x'
endif
scalar xb = x*b
if missing(hi)
  hi = $huge
endif
if missing(lo)
  lo = -$huge
endif
scalar fxb = cnorm((hi-xb)/s)-cnorm((lo-xb)/s)
scalar nx = nelem(XL) - ifc
matrix d = zeros(1, nx)
#print xb
loop foreach i XL -q
  if varnum(XL.$i) &gt; 0 &amp;&amp; isdummy(XL.$i)
    x[i] = 0
    scalar p0 = tobit_exp(b,x,s,lo,hi)
    x[i] = 1
    scalar p1 = tobit_exp(b,x,s,lo,hi)
    d[i-ifc] = p1 - p0
  elif varnum(XL.$i) &gt; 0
    d[i-ifc] = b[i] * fxb
  endif
endloop
return d
</code>
</gretl-function>
<gretl-function name="tobit_exp" type="scalar" private="1">
 <params count="5">
  <param name="b" type="matrix"/>
  <param name="x" type="matrix"/>
  <param name="s" type="scalar"/>
  <param name="lo" type="scalar" default="0"/>
  <param name="hi" type="scalar" default="NA"/>
 </params>
<code>nc = cols(b)
nr = rows(b)
if (nc&gt;nr)
  b = b'
endif
nc = cols(x)
nr = rows(x)
if (nc&lt;nr)
  x = x'
endif
scalar xb = x*b
if missing(hi)
  hi = $huge
endif
if missing(lo)
  lo = -$huge
endif
cey = xb + s*(dnorm((lo-xb)/s)-dnorm((hi-xb)/s))/ (cnorm((hi-xb)/s)-cnorm((lo-xb)/s))
ey = lo*cnorm((lo-xb)/s)+hi*cnorm(-(hi-xb)/s)+(cnorm((hi-xb)/s)-cnorm((lo-xb)/s))*cey
return ey
</code>
</gretl-function>
<gretl-function name="tobit_dp_dx2" type="matrix" private="1">
 <params count="5">
  <param name="allb" type="matrix">
<description>parameter estimates</description>
  </param>
  <param name="XL" type="list">
<description>list of regressors</description>
  </param>
  <param name="x" type="matrix">
<description>vector of x-values</description>
  </param>
  <param name="lo" type="scalar" default="0"/>
  <param name="hi" type="scalar" default="NA"/>
 </params>
<code>n = rows(allb)
b = allb[1:(n-1)]
s = allb[n]
return tobit_dp_dx (b,XL,x,s,lo,hi)
</code>
</gretl-function>
<gretl-function name="ln_tob_prob2" type="series" private="1">
 <params count="4">
  <param name="y" type="series"/>
  <param name="X" type="list"/>
  <param name="gamma" type="matrix"/>
  <param name="theta" type="scalar"/>
 </params>
<code>series z = y &gt; 0
series xb = lincomb(X, gamma)
series P = cnorm(xb)
series Q = (y*theta-xb)^2
return -1/2*z*(-2*ln(theta)+Q) + (1-z)*ln(1-P)
</code>
</gretl-function>
<gretl-function name="tobit_mfx_precheck" type="scalar" private="1" pkg-role="gui-precheck">
<code>scalar err = 0
string cmd = $command
if cmd != &quot;tobit&quot;
  print &quot;tobit_mfx: not a tobit or censored regression model&quot;
  err = 1
endif
return err
</code>
</gretl-function>
<gretl-function name="ln_tob_prob2both" type="series" private="1">
 <params count="6">
  <param name="y" type="series"/>
  <param name="X" type="list"/>
  <param name="gamma" type="matrix"/>
  <param name="theta" type="scalar"/>
  <param name="ll" type="scalar"/>
  <param name="ul" type="scalar"/>
 </params>
<code>series zl = y &gt; ll
series zu = y &lt; ul
series xb = lincomb(X, gamma)
series Pl = cnorm(ll*theta - xb)
series Pu = cnorm(ul*theta - xb)
series Q = (y*theta-xb)^2
return (1-zl)*ln(Pl) -1/2*zl*zu*(-2*ln(theta)+Q) + (1-zu)*ln(1-Pu)
</code>
</gretl-function>
<gretl-function name="ln_tob_prob2left" type="series" private="1">
 <params count="5">
  <param name="y" type="series"/>
  <param name="X" type="list"/>
  <param name="gamma" type="matrix"/>
  <param name="theta" type="scalar"/>
  <param name="ll" type="scalar"/>
 </params>
<code>series zl = y &gt; ll
#series zu = y &lt; ul
series xb = lincomb(X, gamma)
series Pl = cnorm(ll*theta - xb)
#series Pu = cnorm(ul*theta - xb)
series Q = (y*theta-xb)^2
return (1-zl)*ln(Pl) -1/2*zl*(-2*ln(theta)+Q)
</code>
</gretl-function>
<gretl-function name="ln_tob_prob2right" type="series" private="1">
 <params count="5">
  <param name="y" type="series"/>
  <param name="X" type="list"/>
  <param name="gamma" type="matrix"/>
  <param name="theta" type="scalar"/>
  <param name="ul" type="scalar"/>
 </params>
<code>#series zl = y &gt; ll
series zu = y &lt; ul
series xb = lincomb(X, gamma)
#series Pl = cnorm(ll*theta - xb)
series Pu = cnorm(ul*theta - xb)
series Q = (y*theta-xb)^2
return -1/2*zu*(-2*ln(theta)+Q) + (1-zu)*ln(1-Pu)
</code>
</gretl-function>
<gretl-function name="tobit_estimate3all" type="matrix" private="1">
 <params count="4">
  <param name="y" type="series"/>
  <param name="X" type="list"/>
  <param name="ll" type="scalar" default="0"/>
  <param name="ul" type="scalar" default="NA"/>
 </params>
<code>#print ll
n = nelem(X)
matrix coef = zeros(n, 1)
scalar tt = 1
set bfgs_richardson on
if missing(ul)
  mle lll = ln_tob_prob2left(y, X, coef,tt,ll)
    params coef tt
  end mle --hessian --quiet
elif missing(ll)
  mle lll = ln_tob_prob2right(y, X, coef,tt,ul)
    params coef tt
  end mle --hessian --quiet
else
  mle lll = ln_tob_prob2both(y, X, coef,tt,ll,ul)
    params coef tt
  end mle --hessian --quiet
endif
set bfgs_richardson off
#vcov = dddd.$vcv
scalar s = 1/tt
Jmatr = (s*I(n)~((-s^2).*coef))|(zeros(1,n)~(-s^2))
Jmatr = Jmatr*($vcv)*transp(Jmatr)
beta = (coef|1)/tt
return beta~Jmatr
</code>
</gretl-function>
<gretl-function name="tobit_estimate3guj" type="matrix" private="1">
 <params count="4">
  <param name="y" type="series"/>
  <param name="X" type="list"/>
  <param name="ll" type="scalar" default="0"/>
  <param name="ul" type="scalar" default="NA"/>
 </params>
<code>#print ll
n = nelem(X)
matrix coef = zeros(n, 1)
scalar tt = 1
set bfgs_richardson on
if missing(ul)||ul == $huge
  dddd &lt;- mle lll = ln_tob_prob2left(y, X, coef,tt,ll)
  params coef tt
end mle --hessian --quiet
elif missing(ll)||ll == -$huge
dddd &lt;- mle lll = ln_tob_prob2right(y, X, coef,tt,ul)
params coef tt
end mle --hessian --quiet
else
dddd &lt;- mle lll = ln_tob_prob2both(y, X, coef,tt,ll,ul)
params coef tt
end mle --hessian --quiet
endif
set bfgs_richardson off
vcov = dddd.$vcv
scalar s = 1/tt
Jmatr = (s*I(n)~((-s^2).*coef))|(zeros(1,n)~(-s^2))
Jmatr = Jmatr*vcov*transp(Jmatr)
beta = (coef|1)/tt
return beta~Jmatr
</code>
</gretl-function>
<gretl-function name="tobit_mfxguj" type="bundle" private="1">
 <params count="4">
  <param name="y" type="series">
<description>dependent variable</description>
  </param>
  <param name="XL" type="list">
<description>list of regressors</description>
  </param>
  <param name="lo" type="scalar" default="0"/>
  <param name="hi" type="scalar" default="NA"/>
 </params>
<code>#     if missing(hi)
#         hi = $huge
#     endif
bundle ret
string yname = argname(y)
ret[&quot;model&quot;] = &quot;Censored regression&quot;
ret[&quot;yname&quot;] = yname
matrix x = ones(1, nelem(XL))
list D = null
loop foreach i XL -q
  if varnum(XL.$i) &gt; 0
    x[i] = mean(XL.$i)
    if isdummy(XL.$i)
      D += XL.$i
    endif
  endif
endloop
if nelem(D) &gt; 0
  ret[&quot;Dnames&quot;] = varname(D)
endif
bigmatr = tobit_estimate3guj(y,XL,lo,hi)
rbm = rows(bigmatr)
Vbig = bigmatr[,2:]
alltheta = bigmatr[,1]
theta = alltheta[1:(rbm-1)]
s = alltheta[rbm]
scalar meanprob = tobit_exp (theta,x,s,lo,hi)
ret[&quot;mean_depvar&quot;] = meanprob
matrix xbar = inlist(XL, 0) ? (x[2:]') : x'
matrix dp = tobit_dp_dx(theta, XL, x, s,lo,hi)'
matrix J = fdjac(alltheta, tobit_dp_dx2(alltheta, XL, x,lo,hi))
matrix Vdp = qform(J, Vbig)
matrix se = sqrt(diag(Vdp))
matrix zval = dp ./ se
matrix pval = 2 * pvalue(z, abs(zval))
matrix res = dp ~ se ~ zval ~ pval ~ xbar
colnames(res, &quot;dp/dx s.e. z pval xbar&quot;)
rownames(res, XL - 0)
ret[&quot;mfx&quot;] = res
ret[&quot;vcv&quot;] = Vdp
if missing(lo)
  lo = -$huge
endif
if missing(hi)
  hi = $huge
endif
ret[&quot;left&quot;] = lo
ret[&quot;right&quot;] = hi
return ret
</code>
</gretl-function>
<sample-script>
# for script to run
# an user should install sample
# data for  Introductory Econometrics by J. M. Wooldridge
open wooldridge/affairs.gdt -q
include tobit_mfx.gfn
list X = const male age yrsmarr relig occup ratemarr

## Marginal effects at means of the dasta
# for Tobit I
bundle b1 = tobit_mfx(naffairs,X)
tobit_mfx_print(&amp;b1)

# for orbitrary left censoring
bundle b2 = tobit_mfx(naffairs,X,1)
tobit_mfx_print(&amp;b2)

# for arbitrary right censoring
bundle b3 = tobit_mfx(naffairs,X,NA,4)
tobit_mfx_print(&amp;b3)


# for double censoring
bundle b4= tobit_mfx(naffairs,X,0,4)
tobit_mfx_print(&amp;b4)


# tobit_dp_dx gives me at arbitrary point
tobit naffairs X
matrix Xm = {X}
# means of the data, but age is set to 30
means = meanc(Xm)
means[3] = 30

eval tobit_dp_dx($coeff,X,means,$sigma)
</sample-script>
</gretl-function-package>
</gretl-functions>

