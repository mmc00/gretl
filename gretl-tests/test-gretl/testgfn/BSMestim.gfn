<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="BSMestim" ID="1209724281" minver="1.8.4">
<author>Ignacio Diaz-Emparanza</author>
<version>1.1</version>
<date>2009-08-22</date>
<description>Basic Structural Model</description>
<gretl-function name="BSMestim" type="list" private="0">
<help>This package estimates a Basic Structural Model as defined in Harvey(1991) &quot;Time Series Models&quot;.

The model is writen in state-space form, and the program uses the prediction error decomposition form of the likelihood, and evaluates the likelihood function using the Kalman Filter. The gretl function &quot;BFGSmax&quot; is used to obtain the parameters that maximize the likelihood function.

Basic Structural Model
----------------------

 The model:

 y(t) = mu(t) + gamma(t) + e(t)
 mu(t) = mu(t-1)+beta(t-1)+eta(t)
 beta(t) = beta(t-1)+xi(t)
 gamma(t) = -SUM_j=1^s-1 gamma(t-j) + omega(t)

 in state-space form: 

    y(t) = Z(t)*alpha(t) + e(t)
alpha(t) = bT*alpha(t-1) + w(t)

where

 alpha(t) = [mu(t), beta(t), gamma(t), ..., gamma(t-(s-2))]'

 bT = ( 1, 1, 0, ...     , 0
        0, 1, 0, ...     , 0
        0, 0, -1, -1, .., -1 
        0, 0,  1,  0, ..., 0
               .............
        0, 0,  0,  0,.. 1, 0)

 Z(t) = (1, 0, 1, 0, ... ,0) for all t

 w(t) = [eta(t), xi(t), omega(t), 0, ..., 0]' 

    Sigma_w = sigma^2_e (q1, 0, .. 0
                          0, q2, ..0
                          0, 0, q3, .. 0
                          0, 0, 0, ... 0
                          .............
                          0, 0, 0, ... 0 )
 
--------------------------------------------------

The BSMestim command has the following parameters and options:

series y: 		is the univariate series whose BSM is to be estimated, 
series *BSMtrend: 	a series name which will save the trend,
series *BSMslope: 	a series name which will save the slope,
series *BSMseas: 	a series name which will save the seasonal component 
bool restrict_irreg: 	a boolean 0/1 [default=0], a 1 determines that the irregular variance must be restricted to zero
bool restrict_level:	a boolean 0/1 [default=0], a 1 will restrict the level variance to zero.
bool restrict_slope:	a boolean 0/1 [default=0], a 1 will restrict the slope variance to zero.
bool restrict_seas: 	a boolean 0/1, [default=0], a 1 will restrict the seasonal variance to zero.
scalar sigmatol: 	an scalar [default=1.E-4] that determines a lower bound to restrict the variances to zero. If 				the estimation of any variance goes below this limit, the program will restrict it to zero.

The algorithm starts concentrating the likelihood on sigma^2_e, and runs a short number of iterations (with a low tolerance) to detect the maximum variance of the model. In a second step this maximum variance is used to concentrate the likelihood (using now de default tolerance of gretl).

You can restrict any of the variances of the model to zero by selecting the corresponding tickmarks in the dialog box.

The q matrix, containing q1, q2 and q3, may be saved assigning a name in the dialog box. 

WARNING: depending on the variance used for concentrating the likelihood, q1, q2 and q3 may represent different ratios. For example if the model likelihood is concentrating with respect to sigma^2_xi:

    q1 = sigma^2_e/sigma^2_xi, 
    q2 = sigma^2_eta/sigma^2_xi and 
    q3 = sigma^2_omega/sigma^2_xi</help>
 <params count="7">
  <param name="y" type="series"/>
  <param name="q" type="matrixref" optional="true"/>
  <param name="irreg" type="bool" default="1"/>
  <param name="level" type="bool" default="1"/>
  <param name="slope" type="bool" default="1"/>
  <param name="seas" type="bool" default="1"/>
  <param name="sigmatol" type="scalar" default="0.0001"/>
 </params>
<code>set messages off
set echo off
if (irreg!=1&amp;&amp;irreg!=0) || (level!=1&amp;&amp;level!=0) || (slope!=1&amp;&amp;slope!=0) || (seas!=1&amp;&amp;seas!=0)
  funcerr &quot;irreg, level, slope and seas must be 0 or 1&quot;
endif
if $pd&lt;2
  funcerr &quot;BSMestim error: your data are not seasonal, you should use the LLTestim function&quot;
endif
matrix fijos = { irreg, level, slope, seas }
matrix theta = { -0.5, -1.5, -2 }
matrix at = { null }
series V = 0
series F = 0
scalar logLc=0
matrix pstar = { null }
matrix bT = { null }
set bfgs_toler 1.E-02
M = BFGSmax(theta, &quot;BSM(&amp;theta, y, &amp;bT, &amp;at, &amp;pstar, &amp;V, &amp;F, &amp;logLc, sigmatol, 1, fijos)&quot;)
scalar sstart = int(min(t))
scalar send = int(max(t))
scalar T=send-sstart+1
scalar sstar = (1/T)*(sum((V^2)/F))
scalar q1=exp(2*theta[1])*sstar
scalar q2=exp(2*theta[2])*sstar
scalar q3=exp(2*theta[3])*sstar
matrix qp = { sstar,q1, q2 , q3 }
matrix conc=imaxr(qp)
scalar concent = conc[1]
set bfgs_toler default
matrix theta = { -0.5, -1.5, -2 }
M = BFGSmax(theta, &quot;BSM(&amp;theta, y, &amp;bT, &amp;at, &amp;pstar, &amp;V, &amp;F, &amp;logLc, sigmatol, concent, fijos)&quot;)
scalar sstar = (1/T)*(sum((V^2)/F))
scalar q1=exp(2*theta[1])
scalar q2=exp(2*theta[2])
scalar q3=exp(2*theta[3])
string vn=argname(y)
series @vn = y
series @vn_trend = kf_smooth(pstar, &amp;at, bT)
series @vn_slope = at[2,]
series @vn_seas = at[3,]
series @vn_irr = @vn - @vn_trend - @vn_seas
list compo = @vn_trend @vn_slope @vn_seas @vn_irr
printf &quot;\nBasic Structural Model estimation:\n&quot;
printf &quot;-----------------------------------------\n&quot;
if concent=1
  printf &quot;    sigma*=\t\t Var(eps)=%8.6E\n&quot;, sstar
  printf &quot;    q1=%8.5f,\t Var(eta)=%8.6E\n&quot;, q1, q1*sstar
  printf &quot;    q2=%8.5f,\t Var(xi)=%8.6E\n&quot;, q2, q2*sstar
  printf &quot;    q3=%8.5f,\t Var(omega)=%8.6E\n&quot;, q3, q3*sstar
  matrix q = {1, q1, q2, q3}'
elif concent=2
  printf &quot;    q1=%8.5f,\t Var(eps)=%8.6E\n&quot;, q1, q1*sstar
  printf &quot;    sigma*=\t\t Var(eta)=%8.6E\n&quot;, sstar
  printf &quot;    q2=%8.5f,\t Var(xi)=%8.6E\n&quot;, q2, q2*sstar
  printf &quot;    q3=%8.5f,\t Var(omega)=%8.6E\n&quot;, q3, q3*sstar
  matrix q = {q1, 1, q2, q3}'
elif concent=3
  printf &quot;q1=%8.5f,\t Var(eps)=%8.6E\n&quot;, q1, q1*sstar
  printf &quot;q2=%8.5f,\t Var(eta)=%8.6E\n&quot;, q2, q2*sstar
  printf &quot;sigma*=\t\t Var(xi)=%8.6E\n&quot;, sstar
  printf &quot;q3=%8.5f,\t Var(omega)=%8.6E\n&quot;, q3, q3*sstar
  matrix q = {q1, q2, 1, q3}'
else
  printf &quot;q1=%8.5f,\t Var(eps)=%8.6E\n&quot;, q1, q1*sstar
  printf &quot;q2=%8.5f,\t Var(eta)=%8.6E\n&quot;, q2, q2*sstar
  printf &quot;q3=%8.5f,\t Var(xi)=%8.6E\n&quot;, q3, q3*sstar
  printf &quot;sigma*=\t\t Var(omega)=%8.6E\n&quot;, sstar
  matrix q = {q1, q2, q3, 1}'
endif
printf &quot;------------------------------------------\n \n&quot;
return compo
</code>
</gretl-function>
<gretl-function name="kf_filt" type="series" private="1">
 <params count="12">
  <param name="y" type="series"/>
  <param name="a0" type="matrix"/>
  <param name="p0" type="matrix"/>
  <param name="bT" type="matrix"/>
  <param name="Z" type="matrix"/>
  <param name="Sigma_w" type="matrix"/>
  <param name="sigma_e" type="scalar"/>
  <param name="at" type="matrixref"/>
  <param name="pstar" type="matrixref"/>
  <param name="V" type="seriesref"/>
  <param name="F" type="seriesref"/>
  <param name="logLc" type="scalarref"/>
 </params>
<code>/*
Measurement equation:
y(t) = Z[t,]*alpha(t)+e(t)	(1.1a)
State transition:
alpha(t)=bT*alpha(t-1)+w(t);  (1.2a)
bT is for &quot;bold T&quot; and w(t)=R(t)*eta(t) in Harvey 1990
a(t) is the estimator of alpha(t)
Parameters:
y       = observable series
a0      = m x 1 vector, prior a(0)
p0      = m x m matrix, prior p(0)=var(a(0))
bT      = m x m matrix (transition matrix)
Z       = T x m matrix
Sigma_w = m x m symmetric matrix of variance of w(t), fixed for all t
sigma_e = scalar variance of e(t), fixed for all t
at      = m x T  matrix (output) with the estimated states
pstar   = m^2 x T matrix (output)
*/
#
# Forward solution
#
scalar T = rows(Z)
scalar m = rows(a0)
matrix at_t = a0
matrix pt_t = p0
matrix at = zeros(m,T)
# printf &quot;\n...Filtering...\n&quot;
loop for i=1..T --quiet
  # Prediction equations
  # eq. (2.2a)
  matrix at_t = bT*at_t
  # eq. (2.2b)
  matrix pt_t1 = qform(bT,pt_t)+Sigma_w
  # eq. (2.3c)
  matrix zt = Z[$i,]
  matrix H = pt_t1*zt'
  matrix f = zt*H + sigma_e
  if i&gt;1
    matrix pstar_t = (bT*pt_t)' inv(pt_t1)
  endif
  #Updating equations
  # eq. (2.4a)
  genr V[$i] = y[$i] - zt*at_t
  matrix at_t = at_t + H*(V[$i]/f)
  genr F[$i] = f
  # eq (2.4b)
  matrix pt_t = pt_t1 - H*H' * (1/f)
  matrix at[,$i]=at_t
  if i&gt;1
    if i=2
      matrix pstar=vec(pstar_t)
    else
      matrix pstar=pstar~vec(pstar_t)
    endif
  endif
endloop
#Concentrated Log-likelihood fuction
scalar logLc = -(T/2)*(log(2*pi)+1)-(1/2)*sum(log(F))-(T/2)*log((1/T)*sum((V^2)/F))
series filtered = at[1,]
#  printf &quot;\nFilter done\n&quot;
  return filtered
</code>
</gretl-function>
<gretl-function name="kf_smooth" type="series" private="1">
 <params count="3">
  <param name="pstar" type="matrix"/>
  <param name="at" type="matrixref"/>
  <param name="bT" type="matrix"/>
 </params>
<code>/*
Fixed-interval smoothing
The matrix pt is not used here, but could be used if
one wants to calculate confidence intervals for the
at estimators.
*/
scalar m = rows(at)
scalar T = cols(at)
#printf &quot;\n...Smoothing...\n&quot;
scalar T1=T-1
loop for i=1..T1 --quiet
  scalar j=T-i
  matrix pstar_t = mshape(pstar[,j],m,m)
  # eq. (2.9a)
  matrix at[,j] += pstar_t*(at[,(j+1)]-bT*at[,j])
endloop
series ret = at[1,]
#printf &quot;\nSmoothing done\n&quot;
  return ret
</code>
</gretl-function>
<gretl-function name="BSM" type="scalar" private="1">
 <params count="11">
  <param name="param" type="matrixref"/>
  <param name="y" type="series"/>
  <param name="bT" type="matrixref"/>
  <param name="at" type="matrixref"/>
  <param name="pstar" type="matrixref"/>
  <param name="V" type="seriesref"/>
  <param name="F" type="seriesref"/>
  <param name="logLc" type="scalarref"/>
  <param name="sigmatol" type="scalar" default="0.0001"/>
  <param name="concent" type="scalar" default="1"/>
  <param name="fixed" type="matrix"/>
 </params>
<code>set echo off
set messages off
if concent&gt;4
  funcerr &quot;concent must be 1, 2, 3, or 4&quot;
endif
genr time
scalar s = $pd
scalar sstart = int(min(time))
scalar send = int(max(time))
scalar T=send-sstart+1
matrix b1 = { 1, 1; 0, 1 }
matrix b2 = zeros(2, s-1)
matrix b3 = -ones(1, s-1) | (I(s-2) ~ zeros(s-2, 1))
matrix bT = (b1 ~ b2) | (b2' ~ b3)
scalar m = cols(bT)
matrix Z = ones(T,1) ~ zeros(T,1) ~ ones(T,1) ~ zeros(T, s-2)
matrix a0 = y[1] * ones(m,1)
matrix p0 = 400000*I(m)
#
matrix Sigma_w = zeros(s+1,s+1)
if concent=1
  scalar sigma_e=1
  scalar tmp = exp(2*param[1])*fixed[2]
  Sigma_w[1,1] = (tmp&gt;sigmatol) ? tmp : 0
  matrix param[1] = (tmp&gt;sigmatol) ? param[1] : -500
  scalar tmp = exp(2*param[2])*fixed[3]
  Sigma_w[2,2] = (tmp&gt;sigmatol) ? tmp : 0
  matrix param[2] = (tmp&gt;sigmatol) ? param[2] : -500
  scalar tmp = exp(2*param[3])*fixed[4]
  Sigma_w[3,3] = (tmp&gt;sigmatol) ? tmp : 0
  matrix param[3] = (tmp&gt;sigmatol) ? param[3] : -500
else
  if concent=2
    scalar tmp = exp(2*param[1])*fixed[1]
    scalar sigma_e=(tmp&gt;sigmatol) ? tmp : 0
    matrix param[1] = (tmp&gt;sigmatol) ? param[1] : -500
    Sigma_w[1,1] = 1
    scalar tmp = exp(2*param[2])*fixed[3]
    Sigma_w[2,2] = (tmp&gt;sigmatol) ? tmp : 0
    matrix param[2] = (tmp&gt;sigmatol) ? param[2] : -500
    scalar tmp = exp(2*param[3])*fixed[4]
    Sigma_w[3,3] = (tmp&gt;sigmatol) ? tmp : 0
    matrix param[3] = (tmp&gt;sigmatol) ? param[3] : -500
  else
    if concent=3
      scalar tmp = exp(2*param[1])*fixed[1]
      scalar sigma_e=(tmp&gt;sigmatol) ? tmp : 0
      matrix param[1] = (tmp&gt;sigmatol) ? param[1] : -500
      Sigma_w[2,2] = 1
      scalar tmp = exp(2*param[2])*fixed[2]
      Sigma_w[1,1] = (tmp&gt;sigmatol) ? tmp : 0
      matrix param[2] = (tmp&gt;sigmatol) ? param[2] : -500
      scalar tmp = exp(2*param[3])*fixed[4]
      Sigma_w[3,3] = (tmp&gt;sigmatol) ? tmp : 0
      matrix param[3] = (tmp&gt;sigmatol) ? param[3] : -500
    else
      if concent=4
        scalar tmp = exp(2*param[1])*fixed[1]
        scalar sigma_e=(tmp&gt;sigmatol) ? tmp : 0
        matrix param[1] = (tmp&gt;sigmatol) ? param[1] : -500
        Sigma_w[3,3] = 1
        scalar tmp = exp(2*param[2])*fixed[2]
        Sigma_w[1,1] = (tmp&gt;sigmatol) ? tmp : 0
        matrix param[2] = (tmp&gt;sigmatol) ? param[2] : -500
        scalar tmp = exp(2*param[3])*fixed[3]
        Sigma_w[2,2] = (tmp&gt;sigmatol) ? tmp : 0
        matrix param[3] = (tmp&gt;sigmatol) ? param[3] : -500
      endif
    endif
  endif
endif
series filtered = kf_filt(y, a0, p0, bT, Z, Sigma_w, sigma_e, &amp;at, &amp;pstar, &amp;V, &amp;F, &amp;logLc)
  return logLc
</code>
</gretl-function>
<sample-script>
include BSMestim.gfn
open data9-3.gdt
list listavar = BSMestim(reskwh)
print reskwh listavar -o
</sample-script>
</gretl-function-package>
</gretl-functions>
