<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="BreitungCandelonTest" ID="1404122069" needs-time-series-data="true" minver="1.9.0">
<author email="svetosch at gmx dot net">Sven Schreiber</author>
<version>1.5.1</version>
<date>2015-07-01</date>
<description>Breitung-Candelon test of frequency-wise Granger (non-) causality</description>
<help>
Performs a frequency-wise Granger (non-) causality test as described in Breitung and Candelon (2006): &quot;Testing for short- and long-run causality: A frequency-domain approach&quot;, Journal of Econometrics, 132, pp. 363â€“378.

The code is adapted from the original code by Joerg Breitung written in Gauss (with permission). The license is the same as the one of gretl itself (GPL).

Parameters:
* &quot;target&quot;: series that is (potentially) caused by &quot;cause&quot;.
* &quot;cause&quot;: series that is (potentially) causal; of course, under the null hypothesis it is non-causal.
* &quot;conditioning&quot;: list of other relevant variables.  (As in the original Gauss code, Geweke's approach of conditioning is used; see the JoE article for details.)
* &quot;lagorder&quot;: number of lags of all variables in the underlying VAR (refers to levels)
* &quot;freqpoints&quot;: number of frequencies (in the interval [0.01;3.14]) to test. The points will be more or less evenly spaced. 
* &quot;siglevel&quot;: significance level of the test; this just determines the critical value that is returned as part of the results for convenience.

Output: 
* a matrix with three columns: first column holds the tested frequencies, second column the corresponding test statistics, third column the constant critical value.
* A graph of the result matrix will be produced with gnuplot (GUI only).

Note that the test results have the nominal significance level only for a fixed frequency point, not for a frequency band or for an endogenously chosen frequency.  

Please report problems on the gretl mailing list.

thanks and enjoy,
Sven Schreiber

--------------
recent version history:
1.5, June 2015: replace textplot with nicer gnuplot graphs (and 1.5.1: enforce common axis)
1.4, June 2014: update to 'textplot' (and therefore require gretl 1.9.0), handle missing values, print warnings
1.3, 23 Nov 2012: fix argument type bug and loop syntax 
--------------
</help>
<gretl-function name="BreitungCandelonTest" type="matrix">
 <params count="6">
  <param name="target" type="series" const="true"/>
  <param name="cause" type="series" const="true"/>
  <param name="condvars" type="list" optional="true" const="true">
<description>conditioning variables (optional)</description>
  </param>
  <param name="lagorder" type="int" min="2" max="100" default="3">
<description>lag length (levels)</description>
  </param>
  <param name="freqpoints" type="int" min="0" max="500" default="100">
<description>number of frequencies</description>
  </param>
  <param name="siglevel" type="scalar" default="0.05">
<description>significance level</description>
  </param>
 </params>
<code># This is the top-level user-interface function.
# It calls BCtest_fromto()
#   which in turn calls caus_freq() to calculate the actual test for a given freq,
#   and then puts all test results in a matrix.
# At the end this function graphs the results.
# some checks:
if sum(missing(target)) &gt; 0
  print &quot;Warning: missing values found in target, will try to remove obs.&quot;
  smpl target --no-missing
endif
if sum(missing(cause)) &gt; 0
  print &quot;Warning: missing values found in cause, will try to remove obs.&quot;
  smpl cause --no-missing
endif
if nelem(condvars) &gt; 0
  if sum(ok(condvars)-1) &lt; 0
    # missing() doesn't work for lists; the -1 seems to broadcast fine
    # the lower-than-term is correct because everything is inverted here
    print &quot;Warning: missing values found in conditioning, will try to remove obs.&quot;
    smpl condvars --no-missing
  endif
endif
printf &quot;Chosen lag order: %d\n&quot;, lagorder
if lagorder = 2
  print &quot;Warning: The test with only 2 lags is not suitable for I(1) variables.&quot;
endif
printf &quot;Sample size (including lags, T+p): %d; from obs %s to obs %s.\n&quot;, $nobs, obslabel($t1), obslabel($t2)
# construct the matrix input
matrix mY = {target,cause,condvars}
T = rows(mY)
numofvars = cols(mY)
# further checks
if rank(mY) &lt; numofvars
  funcerr &quot;Exact linear dependence found in input (duplicated vars?).&quot;
endif
if lagorder &gt;= T
  funcerr &quot;Can't have more lags than observations&quot;
endif
if (lagorder*numofvars) &gt;= T
  funcerr &quot;No degrees of freedom left (too many lags, too many variables)&quot;
endif
# if freqpoints &gt;= $nobs
#   printf &quot;Warning: too many tested frequencies for graphing in current workfile.&quot;
# Because only series can be graphed, and longer series exceed workfile sample.
#   printf &quot; (But test results will still be stored in return matrix.)\n&quot;
#   do_graph = 0
#else
do_graph = 1	# redundant after the June 2015 change?
# endif
# now do the actual test
matrix BCtestoutput = BCtest_fromto(mY,lagorder,0.01,3.14,freqpoints) # to be returned
# add the critical value as constant series for convenience
numoffreqs = rows(BCtestoutput)
matrix BCtestoutput = BCtestoutput ~ (critical(X,2,siglevel)*ones(numoffreqs,1))
# graph the results
if do_graph = 1
  #startobs = $t1
  # debug: print startobs
  #endobs = startobs + numoffreqs - 1
  #smpl startobs endobs	# hope it isn't necessary to undo this later,
  # because it only affects the inner scope?
  #series BCfreqs = BCtestoutput[,1]
  #series BCstats = BCtestoutput[,2]
  #series BCcvals = BCtestoutput[,3]
  #textplot BCcvals BCstats BCfreqs --tall
  colnames(BCtestoutput, &quot;frequency teststat crit.val.&quot;)
  gnuplot 2 3 1 --matrix=BCtestoutput --suppress-fitted --single-yaxis
endif
printf &quot;The columns in the return matrix (if any) hold\n&quot;
printf &quot;(1) frequencies, (2) test statistics,\n&quot;
printf &quot;(3) critical value (repeated) at %4.3f level.\n&quot;, siglevel
return BCtestoutput
</code>
</gretl-function>
<gretl-function name="caus_freq" type="scalar" private="1">
 <params count="3">
  <param name="mY" type="matrix"/>
  <param name="lagorder" type="int"/>
  <param name="freqpoint" type="scalar"/>
 </params>
<code># this function calculates the actual test statistic
# mY: first col target, second col cause, further cols conditioning vars
T = rows(mY)
K = cols(mY)
matrix mXstar = mY[3:T,2] - 2*cos(freqpoint)*mY[2:T-1,2] + mY[1:T-2,2]
# (the Gegenbauer polynomial for non-causality at frequency freqpoint)
matrix mX = mY[lagorder:T-1,] ~ mY[lagorder-1:T-2,]	# two lags
# (at least lagorder 2 is required because otherwise no cyclical behavior)
matrix mind = {2, K+2} # index vector refers to first and second lag of causal var
upto = lagorder-2
loop i=1..upto --quiet	# add more lags
  matrix mtemp = mY[lagorder-1-i:T-2-i,]   # next lag of all variables
  matrix mX = (K&gt;2) ? (mX ~ mtemp[,1] ~ mtemp[,3:K]) :  (mX ~ mtemp[,1])
  # (remove causing var, handled below; K&gt;2 means we have conditioning vars)
  matrix mX = mX ~ mXstar[lagorder-1-i:T-2-i]
  # (these Gegenbauer lags of the causal variable are non-causal by construction)
  # (it seems un-important that the Xstarlags come last, so they don't, here)
endloop
matrix mX = mX ~ ones(T-lagorder,1)
matrix mDepvar = mY[lagorder+1:T,1]
# here the original Gauss code was b=depvar/x
# AFAIK this means regress depvar on x and get the estimates
matrix mU = {}	# to hold the residuals
matrix mb = mols(mDepvar,mX,&amp;mU)
scalar sig2 = mU'mU
scalar sig2 = sig2 / (T-lagorder-cols(mX))
matrix mVarb = sig2 * invpd(mX'mX)
# now the vector (2;k+2) was used for indexing, I hope this is what was meant
scalar wald = qform(transp(mb[mind]), invpd(mVarb[mind,mind]))
return wald
</code>
</gretl-function>
<gretl-function name="BCtest_fromto" type="matrix" private="1">
 <params count="5">
  <param name="mY" type="matrix" const="true"/>
  <param name="lagorder" type="int"/>
  <param name="fromfreq" type="scalar"/>
  <param name="tofreq" type="scalar"/>
  <param name="numoffreqs" type="int"/>
 </params>
<code># We expect the return matrix to have numoffreqs rows, but could be slightly different
#  so one shouldn't rely on that.
# The idea of having fromfreq and tofreq is that in a batch processing context
#  we can save computing time by looking only at the freqs we want.
# For a general graph instead we would look at the entire frequency band.
matrix mcontainer = zeros(0,2)	# new w/o the critical value; 1st col freqs, 2nd col stats
T = rows(mY)
step = (tofreq-fromfreq)/(numoffreqs-1)
loop for (f=fromfreq; f&lt;=tofreq; f+=step)  --quiet
  teststat = caus_freq(mY,lagorder,f)
  matrix mcontainer = mcontainer | {f, teststat}
endloop
return mcontainer
</code>
</gretl-function>
<sample-script>
include BreitungCandelonTest.gfn
# test case:
open denmark
smpl 1975:1 1987:3
list conditioning = IBO
#list conditioning = null
lagorder = 4
points = 50
siglevel = 0.05
matrix BC1 = BreitungCandelonTest(LRM,LRY,conditioning,lagorder,points,siglevel)
</sample-script>
</gretl-function-package>
</gretl-functions>

