<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="poisson_mfx" ID="1438379031" minver="1.9.12">
<author email="oleg_komashko@ukr.net">Oleg Komashko</author>
<version>0.1</version>
<date>2015-08-01</date>
<description>marginale effects for poisson and negbin regression</description>
<label>marginal effects</label>
<menu-attachment>MODELWIN/Analysis</menu-attachment>
<help>
Marginal effects after poisson and negbin regression

This package serves to calculate marginal effects and
associated statistics (standard errors, z-values and p-values)
for poisson and negbin regression.

The package offers a graphical interface which is designed to appear 
under the Analysis menu in gretl's model window; this is hard-wired
to produce marginal effects at the sample means of all the regressors.

Two public functions are available.

1) poisson_mfx calculates marginal effects  at 
the sample means, along with standard errors via the delta method, 
and they return a bundle containing all the results.

function bundle poisson_mfx (series y &quot;dependent variable&quot;,
                             list XL &quot;list of regressors&quot;,
                             matrix theta &quot;parameter estimates&quot;,
                             matrix V &quot;estimated variance matrix&quot;,
                             bool poiss[1])

This function is intended to use alongside with poisson_mfx_print
(bundle *b) function for nice printing of the results 
(see the sample script).
Note that the output bundle contains the covariance
matrix of the marginal effects. Hence, an user could easy calculate
marginal effects of functions of the regressors.

2) poisson_dp_dx function accept a k-vector, x, containing the 
values of the regressors at which the marginal effects should be
found, and they return the k-vector of effects pertaining to a
specific selected outcome.

function matrix poisson_dp_dx (matrix b &quot;parameter estimates&quot;,
                               list XL &quot;list of regressors&quot;,
                               matrix x &quot;vector of x-values&quot;)

Dummy variables (0/1) are detected and the marginal effect is
calculated as the effect of a discrete change from 0 to 1.

Refefences

Gretl User's Guide
Gretl lp-mfx package

Greene William H. (2003). Econometric Analysis, Upper Saddle
River, NJ: Prentice-Hall, fifth edn.

Maddala, G. (1983). Limited Dependent and Qualitative Variables
in Econometrics. New York: Cambridge University Press.
</help>
<gretl-function name="GUI_poisson_mfx" type="bundle" no-print="1" menu-only="1" pkg-role="gui-main">
<code>## no-print ##
string cmd = $command
if cmd == &quot;negbin&quot;
  poiss = 0
else
  poiss = 1
endif
list Y = $ylist
string yname = $depvar
loop foreach i Y
  series @yname = Y.$i
endloop
bundle b
b = poisson_mfx(@yname , $xlist,$coeff,$vcv,poiss)
return b
</code>
</gretl-function>
<gretl-function name="poisson_mfx" type="bundle">
 <params count="5">
  <param name="y" type="series">
<description>dependent variable</description>
  </param>
  <param name="XL" type="list">
<description>list of regressors</description>
  </param>
  <param name="theta" type="matrix">
<description>parameter estimates</description>
  </param>
  <param name="V" type="matrix">
<description>estimated variance matrix</description>
  </param>
  <param name="poiss" type="bool" default="1"/>
 </params>
<code>nV = rows(V)
if !poiss
  V = V[1:(nV-1),1:(nV-1)]
  theta = theta[1:nV-1]
endif
bundle ret
if nelem(XL) != rows(V)
  funcerr &quot;Length of X list does not match dimension of V&quot;
endif
# ensure we're using the model's estimation sample
# smpl sample --dummy
nc = cols(theta)
nr = rows(theta)
if (nc&gt;nr)
  b = b'
endif
string yname = argname(y)
ret[&quot;model&quot;] = &quot;Poisson/Negbin&quot;
#ret[&quot;dist&quot;] = dist
ret[&quot;yname&quot;] = yname
# compute mean X and assemble list of dummies
matrix x = ones(1, nelem(XL))
list D = null
loop foreach i XL -q
  if varnum(XL.$i) &gt; 0
    x[i] = mean(XL.$i)
    if isdummy(XL.$i)
      D += XL.$i
    endif
  endif
endloop
if nelem(D) &gt; 0
  ret[&quot;Dnames&quot;] = varname(D)
endif
scalar meanprob = exp(x*theta)
ret[&quot;mean_depvar&quot;] = meanprob
matrix xbar = inlist(XL, 0) ? (x[2:]') : x'
# now compute marginal effects
matrix dp = poisson_dp_dx(theta, XL, x)'
matrix J = fdjac(theta, poisson_dp_dx(theta, XL, x))
matrix Vdp = qform(J, V)
matrix se = sqrt(diag(Vdp))
matrix zval = dp ./ se
matrix pval = 2 * pvalue(z, abs(zval))
matrix res = dp ~ se ~ zval ~ pval ~ xbar
colnames(res, &quot;dp/dx s.e. z pval xbar&quot;)
rownames(res, XL - 0)
ret[&quot;mfx&quot;] = res
ret[&quot;vcv&quot;] = Vdp
return ret
</code>
</gretl-function>
<gretl-function name="poisson_dp_dx" type="matrix">
 <params count="3">
  <param name="b" type="matrix">
<description>parameter estimates</description>
  </param>
  <param name="XL" type="list">
<description>list of regressors</description>
  </param>
  <param name="x" type="matrix">
<description>vector of x-values</description>
  </param>
 </params>
<code># Computes the &quot;slope&quot; of the probability that y = 1
# with respect to each regressor
#
# Returns a (row) k-vector, where k is the number of
# regressors (omitting the constant, if present)
nc = cols(b)
nr = rows(b)
if (nc&gt;nr)
  b = b'
endif
nc = cols(x)
nr = rows(x)
if (nc&lt;nr)
  x = x'
endif
scalar ifc = inlist(XL, 0)
scalar xb = x*b
scalar fxb = exp(xb)
scalar nx = nelem(XL) - ifc
matrix d = zeros(1, nx)
loop foreach i XL -q
  if varnum(XL.$i) &gt; 0 &amp;&amp; isdummy(XL.$i)
    x[i] = 0
    scalar p0 = exp(x*b)
    x[i] = 1
    scalar p1 = exp(x*b)
    d[i-ifc] = p1 - p0
  elif varnum(XL.$i) &gt; 0
    d[i-ifc] = b[i] * fxb
  endif
endloop
return d
</code>
</gretl-function>
<gretl-function name="poisson_mfx_print" type="void" pkg-role="bundle-print">
 <params count="1">
  <param name="b" type="bundleref"/>
 </params>
<code>string model = b[&quot;model&quot;]
matrix mp = b[&quot;mean_depvar&quot;]
string yname = b[&quot;yname&quot;]
catch string Dnames = b[&quot;Dnames&quot;]
printf &quot;\n%s marginal effects\n&quot;, model
printf &quot;(evaluated at means of regressors)\n&quot;
if !isnull(Dnames)
  printf &quot;\nnote: dp/dx based on discrete change for %s\n&quot;, Dnames
endif
printf &quot;\n&quot;
matrix res = b[&quot;mfx&quot;]
printf &quot;E(%s) = %.4f\n\n%#12.5g\n&quot;, yname, mp, res
</code>
</gretl-function>
<gretl-function name="poisson_mfx_precheck" type="scalar" private="1" pkg-role="gui-precheck">
<code>scalar err = 0
string cmd = $command
if ((cmd != &quot;poisson&quot;)&amp;&amp;(cmd != &quot;negbin&quot;))
  print &quot;poisson_mfx: not a poisson or negbin regression model&quot;
  err = 1
endif
return err
</code>
</gretl-function>
<sample-script>
open affairs.gdt
# stata to compare
# use &quot;http://www.dartmouth.edu/~econ20pa/affairs.dta&quot;
list X = const male age yrsmarr

poisson naffairs X
b1 = poisson_mfx(naffairs,X,$coeff,$vcv)
poisson_mfx_print(&amp;b1)

# stata to compare
# poisson naffairs male age yrsmarr
# mfx compute

eval poisson_dp_dx({1,2,3,4},X,{0.1,0.2,0.3,1})

negbin naffairs X
b2 = poisson_mfx(naffairs,X,$coeff,$vcv,0)
poisson_mfx_print(&amp;b2)

# stata to compare
# nbreg naffairs male age yrsmarr, dispersion(mean)
# mfx compute

negbin naffairs X --model1
b3 = poisson_mfx(naffairs,X,$coeff,$vcv,0)
poisson_mfx_print(&amp;b3)

# stata to compare
# nbreg naffairs male age yrsmarr, dispersion(constant)
# mfx compute
</sample-script>
</gretl-function-package>
</gretl-functions>

