<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="sfa_mod" ID="1217318637" minver="1.8.4">
<author>Gordon Hughes</author>
<version>0.91</version>
<date>2009-08-22</date>
<description>Estimation of stochastic frontier models with no heteroskedasticity</description>
<help>
Function sfa_mod estimates standardard stochastic frontier models for a range of specifications with no heteroscedasticity across observations

Usage: matrix sfa_result = sfa_mod(y, X) [Simple version]
       matrix sfa_result = sfa_mod(y, X, model, type) [More options]
       matrix sfa_result = sfa_mod(y, X, model, type, &amp;start) [Full version]
 
Dependent variable: series y

Variables in cost/production function: list X (including const if required)

Parameter: string model - &quot;E&quot; or &quot;e&quot; = Normal-Exponential (default); 
                          &quot;H&quot; or &quot;h&quot; = Normal-Half Normal; 
                          &quot;T&quot; or &quot;t&quot; = Normal-Truncated Normal.

Parameter: string type - &quot;C&quot; or &quot;c&quot; = Cost function;
                         &quot;P&quot; or &quot;p&quot; = Production function.

Input: matrix start - Starting values for coefficients (default=null)
       This is provided as a pointer to an existing matrix

Null inputs are permitted for model, type and start

Output:  matrix sfa_result

The output matrix has the following columns
    Col  1      - b [i, i=1..nx] (mu) su sv
    Cols 2-nx+1 - variance-covariance matrix
    Col  nx+2   - log-likelihood aic bic hqc
where b is a vector of coefficients for the production/cost function; 
      mu = the mean of truncated normal distribution [only if model = &quot;T&quot;];
      su = sigma_u;
      sv = sigma_v.

The basic model assumes that:

		y = X'b - su + v

where s = 1 for a production function and s = -1 for a cost function,
      u &gt; 0 is a one-sided efficiency error, and 
      v = N[0, sigma_v] is a normally distributed random error with mean = 0 and 
          sd = sigma_v. 

The alternative specifications concern the distribution of the efficiency error:

If type = &quot;E&quot;, u has an exponential distribution with sd = sigma_u.

If type = &quot;H&quot;, u has a half-normal distribution with sd = sigma_u - i.e. values of 
    N[0, sigma_u} &gt;= 0.

If type = &quot;T&quot;, us has a truncated normal distribution with mean = mu, sd = sigma_u 
    - i.e. values of N[mu, sigma_u] &gt;= 0.

For details of the stochastic frontier model see
    S. Kumbhakar &amp; C. Knox Lovell - Stochastic Frontier Analysis
    W. Greene - Econometric Analysis, Chap 9
</help>
<gretl-function name="sfa_mod" type="matrix">
 <params count="5">
  <param name="y" type="series">
<description>Dependent variable</description>
  </param>
  <param name="X" type="list">
<description>List of independent variables</description>
  </param>
  <param name="model" type="string" optional="true">
<description>Error specification E/H/T</description>
  </param>
  <param name="type" type="string" optional="true">
<description>Cost/Production function C/P</description>
  </param>
  <param name="sbeta" type="matrixref" optional="true">
<description>Col vector of initial coefficient values</description>
  </param>
 </params>
<code>#
# Estimate stochastic frontier models
#
# Usage: matrix sfa_result = sfa_mod(y, X, model, type)
#
# Dependent variable: series y
#
# Variables in cost/production function: list X (including const if required)
#
# Parameter: string model - &quot;E&quot; = Normal-Exponential (default)
#                           &quot;H&quot; = Normal-Half Normal
#                           &quot;T&quot; = Normal-Truncated Normal
#
# Parameter: string type - &quot;C&quot; = Cost function (default)
#                          &quot;P&quot; = Production function
#
# Output matrix:
#     Col  1      - b[i, i=1..nx] (mu) su sv
#     Cols 2-nx+1 - variance-covariance matrix
#     Col  nx+2   - log-likelihood aic bic hqc
#
# Test input data
if nelem(X) = 0
  funcerr &quot;The variable list X must not be empty&quot;
endif
if isnull(type)
  string type=&quot;C&quot;
endif
if isnull(model)
  string model=&quot;E&quot;
endif
scalar prod_flag = (type=&quot;P&quot; || type=&quot;p&quot;)
scalar cost_flag = 1-prod_flag
scalar hnorm_flag = (model=&quot;H&quot; || model=&quot;h&quot;)
scalar tnorm_flag = (model=&quot;T&quot; || model=&quot;t&quot;)
scalar expon_flag = 1- hnorm_flag - tnorm_flag
if isnull(sbeta)
  if expon_flag &gt; 0
    printf &quot;\nStochastic Frontier Analysis : Normal-Exponential&quot;
    if cost_flag &gt; 0
      printf &quot;\nCost function specification\n&quot;
    else
      printf &quot;\nProduction function specification\n&quot;
    endif
    matrix result=sfa_est_exp(y, X, cost_flag)
    print &quot;hello for result&quot;
  endif
  if hnorm_flag &gt; 0
    printf &quot;\nStochastic Frontier Analysis : Normal-Half Normal&quot;
    if cost_flag &gt; 0
      printf &quot;\nCost function specification\n&quot;
    else
      printf &quot;\nProduction function specification\n&quot;
    endif
    matrix result=sfa_est_hnorm(y, X, cost_flag)
  endif
  if tnorm_flag &gt; 0
    printf &quot;\nStochastic Frontier Analysis : Normal-Truncated Normal&quot;
    if cost_flag &gt; 0
      printf &quot;\nCost function specification\n&quot;
    else
      printf &quot;\nProduction function specification\n&quot;
    endif
    matrix result=sfa_est_tnorm(y, X, cost_flag)
  endif
else
  scalar nx = nelem(X)
  scalar ns = rows(sbeta)
  if expon_flag &gt; 0
    scalar ncr = nx+2
    if ns = ncr
      printf &quot;\nNo of initial coefficient values = No of values required &quot;
    else
      sprintf s &quot;No of initial coefficient values supplied = &quot;
      printf &quot;\n%44s%3.0f&quot;, s, ns
      sprintf s &quot;No of initial coefficient values required = &quot;
      printf &quot;\n%44s%3.0f&quot;, s, ncr
      printf &quot;\nInitial coefficient values filled from top of column vector provided &quot;
    endif
    printf &quot;\nStochastic Frontier Analysis : Normal-Exponential&quot;
    if cost_flag &gt; 0
      printf &quot;\nCost function specification\n&quot;
    else
      printf &quot;\nProduction function specification\n&quot;
    endif
    matrix result=sfa_est_exp(y, X, cost_flag, &amp;sbeta)
  endif
  if hnorm_flag &gt; 0
    printf &quot;\nStochastic Frontier Analysis : Normal-Half Normal&quot;
    if cost_flag &gt; 0
      printf &quot;\nCost function specification\n&quot;
    else
      printf &quot;\nProduction function specification\n&quot;
    endif
    matrix result=sfa_est_hnorm(y, X, cost_flag, &amp;sbeta)
  endif
  if tnorm_flag &gt; 0
    printf &quot;\nStochastic Frontier Analysis : Normal-Truncated Normal&quot;
    if cost_flag &gt; 0
      printf &quot;\nCost function specification\n&quot;
    else
      printf &quot;\nProduction function specification\n&quot;
    endif
    matrix result=sfa_est_tnorm(y, X, cost_flag, &amp;sbeta)
  endif
endif
matrix coef = result[,1]
scalar vcol = cols(result)-1
scalar lcol = cols(result)
matrix vcv = result[,2:vcol]
scalar loglik = result[1,lcol]
scalar aic = result[2,lcol]
scalar bic = result[3,lcol]
scalar hqc = result[4,lcol]
printf &quot;\n\n                 Variable       Coeff          SE   z-ratio   P-value\n\n&quot;
printf &quot;Coefficients of cost/production function\n&quot;
k = 1
loop foreach i X -q
  s = &quot;$i&quot;
  scalar c = coef[k]
  scalar se = sqrt(vcv[k,k])
  scalar zs = abs(c/se)
  scalar pv = 2*pvalue(n, zs)
  printf &quot;%25s%12.5f%12.5f%10.3f%10.3f\n&quot;, s, c, se, zs, pv
  k++
endloop
printf &quot;\nParameters of the error distributions\n&quot;
if tnorm_flag &gt; 0
  s = &quot;Truncated normal - mu&quot;
  scalar c = coef[k]
  scalar se = sqrt(vcv[k,k])
  scalar zs = abs(c/se)
  scalar pv = 2*pvalue(n, zs)
  printf &quot;%25s%12.5f%12.5f%10.3f%10.3f\n&quot;, s, c, se, zs, pv
  k++
endif
s = &quot;Inefficiency - sigma_u&quot;
scalar c = coef[k]
scalar se = sqrt(vcv[k,k])
scalar zs = abs(c/se)
scalar pv = 2*pvalue(n, zs)
printf &quot;%25s%12.5f%12.5f%10.3f%10.3f\n&quot;, s, c, se, zs, pv
k++
sprintf s &quot;Random error - sigma_v&quot;
scalar c = coef[k]
scalar se = sqrt(vcv[k,k])
scalar zs = abs(c/se)
scalar pv = 2*pvalue(n, zs)
printf &quot;%25s%12.5f%12.5f%10.3f%10.3f\n&quot;, s, c, se, zs, pv
k++
sprintf s &quot;Log-Likelihood = &quot;
printf &quot;\n%20s%10.3f\n&quot;, s, loglik
sprintf s &quot;Akaike Information Criterion (AIC) = &quot;
printf &quot;%40s%10.3f\n&quot;, s, aic
sprintf s &quot;Schwarz's Bayesian Criterion (BIC) = &quot;
printf &quot;%40s%10.3f\n&quot;, s, bic
sprintf s &quot;Hannan-Quinn Criterion (HQC) = &quot;
printf &quot;%40s%10.3f\n&quot;, s, hqc
printf &quot;\n\n&quot;
return result
</code>
</gretl-function>
<gretl-function name="sfa_est_hnorm" type="matrix" private="1">
 <params count="4">
  <param name="y" type="series"/>
  <param name="X" type="list"/>
  <param name="cost" type="bool"/>
  <param name="sbeta" type="matrixref" optional="true"/>
 </params>
<code>#
# MLE for SFA with Normal-Half Normal model with no heteroscedasticity
#
# Inputs:
#     series y - dependent variable
#     list X - independent variables including const if required
#     bool cost - flag &gt; 0 for cost function, otherwise production function
#     matrix sbeta - column vector of initial coefficient values (default is null)
#
# Output
#     matrix ret - contains estimates of coefficients, var-cov matrix &amp; log-likelihood, etc
#
# Parameters
#     b = coefficients of cost/production function
#     su = sigma_u, SD of efficiency error component - u[i,t]
#     sv = sigma_v, SD of random error component - v[i,t]
#
scalar nx = nelem(X)
scalar ncr = nx+2
# Use boolean variable cost to setup sc for cost or production function
if cost
  scalar sc = -1
else
  scalar sc = 1
endif
if isnull(sbeta)
  ols y X --quiet
  matrix b = $coeff
  scalar su = 0.1
  scalar sv = 0.1
else
  matrix start = zeros(ncr,1)
  scalar ns = rows(sbeta)
  scalar ncf = ns
  if ns &gt; ncr
    ncf = ncr
  endif
  start[1:ncf,1] = sbeta[1:ncf,1]
  if start[nx+1,1] &lt;= 0
    start[nx+1,1] = 0.1
  endif
  if start[nx+2,1] &lt;= 0
    start[nx+2,1] = 0.1
  endif
  matrix b = start[1:nx,1]
  scalar su = start[nx+1,1]
  scalar sv = start[nx+2,1]
endif
mle logl=ln(cnorm(zval))-ln(ss)-0.5*((e/ss)^2)+0.5*ln(2/pi)
  scalar ss = sqrt(su^2 + sv^2)
  scalar lambda = su/sv
  series e = y-lincomb(X,b)
  series zval = -(sc*lambda/ss)*e
  series d1 = dnorm(zval)/cnorm(zval)
  series de = d1*(-sc*lambda/ss)-(e/(ss^2))
  matrix Xmat = {X}
  matrix demat = {de}
  matrix d_b = -Xmat.*demat
  series dss = d1*((sc*e*lambda)/(ss^2))-(1/ss)+((e^2)/(ss^3))
  series dlam = d1*(-sc*e/ss)
  series d_su = dss*(su/ss)+dlam*(1/sv)
  series d_sv = dss*(sv/ss)+dlam*(-su/(sv^2))
  deriv b = d_b
  deriv su = d_su
  deriv sv = d_sv
  #   params b su sv
end mle --quiet
matrix ret1=$coeff~$vcv
scalar rr2=rows(ret1)-4
matrix ret2=$lnl|$aic|$bic|$hqc|zeros(rr2,1)
return ret1~ret2
</code>
</gretl-function>
<gretl-function name="sfa_est_exp" type="matrix" private="1">
 <params count="4">
  <param name="y" type="series"/>
  <param name="X" type="list"/>
  <param name="cost" type="bool"/>
  <param name="sbeta" type="matrixref" optional="true"/>
 </params>
<code>#
# MLE for SFA with Normal-Exponential model with no heteroscedasticity
#
# Inputs:
#     series y - dependent variable
#     list X - independent variables including const if required
#     bool cost - flag &gt; 0 for cost function, otherwise production function
#     matrix sbeta - column vector of initial coefficient values (default is null)
#
# Output
#     matrix ret - contains estimates of coefficients, var-cov matrix &amp; log-likelihood, etc
#
# Parameters
#     b = coefficients of cost/production function
#     su = sigma_u, SD of efficiency error component - u[i,t]
#     sv = sigma_v, SD of random error component - v[i,t]
#
scalar nx = nelem(X)
scalar ncr = nx+2
# Use boolean variable cost to setup sc for cost or production function
if cost
  scalar sc = -1
else
  scalar sc = 1
endif
if isnull(sbeta)
  ols y X --quiet
  matrix b = $coeff
  scalar su = 0.1
  scalar sv = 0.1
else
  matrix start = zeros(ncr,1)
  scalar ns = rows(sbeta)
  scalar ncf = ns
  if ns &gt; ncr
    ncf = ncr
  endif
  start[1:ncf,1] = sbeta[1:ncf,1]
  if start[nx+1,1] &lt;= 0
    start[nx+1,1] = 0.1
  endif
  if start[nx+2,1] &lt;= 0
    start[nx+2,1] = 0.1
  endif
  matrix b = start[1:nx,1]
  scalar su = start[nx+1,1]
  scalar sv = start[nx+2,1]
endif
mle logl=ln(cnorm(zval))-ln(su)+(sc*e/su)+0.5*((sv/su)^2)
  series e = y-lincomb(X,b)
  series zval = (-sc*e/sv)-(sv/su)
  series d1 = dnorm(zval)/cnorm(zval)
  series de = (sc/su)-d1*(sc/sv)
  matrix Xmat = {X}
  matrix demat = {de}
  matrix d_b = -Xmat.*demat
  series d_su = (sv/(su^2))*d1-(1/su)-((sc*e)/(su^2))-((sv^2)/(su^3))
  series d_sv = (((sc*e)/(sv^2))-(1/su))*d1+(sv/(su^2))
  deriv b = d_b
  deriv su = d_su
  deriv sv = d_sv
  #   params b su sv
end mle --quiet
matrix ret1=$coeff~$vcv
scalar rr2=rows(ret1)-4
matrix ret2=$lnl|$aic|$bic|$hqc|zeros(rr2,1)
return ret1~ret2
</code>
</gretl-function>
<gretl-function name="sfa_est_tnorm" type="matrix" private="1">
 <params count="4">
  <param name="y" type="series"/>
  <param name="X" type="list"/>
  <param name="cost" type="bool"/>
  <param name="sbeta" type="matrixref" optional="true"/>
 </params>
<code>#
# MLE for SFA with Normal-Truncated Normal model with no heteroscedasticity
#
# Inputs:
#     series y - dependent variable
#     list X - independent variables including const if required
#     bool cost - flag &gt; 0 for cost function, otherwise production function
#     matrix sbeta - column vector of initial coefficient values (default is null)
#
# Output
#     matrix ret - contains estimates of coefficients, var-cov matrix &amp; log-likelihood, etc
#
# Parameters
#     b = coefficients of cost/production function
#     mu = mean of truncated normal distribution for efficiency error component - u[i,t]
#     su = sigma_u, SD of efficiency error component - u[i,t]
#     sv = sigma_v, SD of random error component - v[i,t]
#
scalar nx = nelem(X)
scalar ncr = nx+3
# Use boolean variable cost to setup sc for cost or production function
if cost
  scalar sc = -1
else
  scalar sc = 1
endif
if isnull(sbeta)
  ols y X --quiet
  matrix b = $coeff
  scalar su = 0.1
  scalar sv = 0.1
  scalar mu = 0.01
else
  matrix start = zeros(ncr,1)
  scalar ns = rows(sbeta)
  scalar ncf = ns
  if ns &gt; ncr
    ncf = ncr
  endif
  start[1:ncf,1] = sbeta[1:ncf,1]
  if start[nx+1,1] &lt;= 0
    start[nx+1,1] = 0.1
  endif
  if start[nx+2,1] &lt;= 0
    start[nx+2,1] = 0.1
  endif
  if start[nx+3,1] &lt;= 0
    start[nx+3,1] = 0.01
  endif
  matrix b = start[1:nx,1]
  scalar su = start[nx+1,1]
  scalar sv = start[nx+2,1]
  scalar mu = start[nx+3,1]
endif
mle logl=ln(cnorm(zval))-0.5*ln(2*pi)-ln(ss)-ln(cnorm(mval))-0.5*(((e+sc*mu)/ss)^2)
  series e = y-lincomb(X,b)
  scalar ss = sqrt(su^2+sv^2)
  scalar lambda = su/sv
  scalar gamma = (su/ss)^2
  scalar mval = mu/(ss*sqrt(gamma))
  scalar zdenom = ss*sqrt(gamma*(1-gamma))
  series zval = ((1-gamma)*mu-sc*gamma*e)/zdenom
  series d1 = dnorm(zval)/cnorm(zval)
  series de = d1*((-sc*gamma)/zdenom)-((e+sc*mu)/(ss*ss))
  matrix Xmat = {X}
  matrix demat = {de}
  matrix d_b = -Xmat.*demat
  series d2 = dnorm(mval)/cnorm(mval)
  series d_mu = (-d2/(ss*sqrt(gamma)))+d1*(1-gamma)/(zdenom) -(sc*(e+sc*mu))/(ss*ss)
  series d_ss = (-1/ss)+d2*(mval/ss)-d1*(zval/ss)+((e+sc*mu)^2)/(ss^3)
  series d_gam = 0.5*d2*(mu/(ss*(gamma^1.5)))-d1*((mu+sc*e)/zdenom) -0.5*d1*zval*(1-2*gamma)/(gamma*(1-gamma))
  series dss_su = su/ss
  series dss_sv = sv/ss
  series dgam_su = 2*su/(ss*ss)-((2*su*su)/(ss^3))*dss_su
  series dgam_sv = -((2*su*su)/(ss^3))*dss_sv
  series d_su = d_gam*dgam_su+d_ss*dss_su
  series d_sv = d_gam*dgam_sv+d_ss*dss_sv
  deriv b = d_b
  deriv mu = d_mu
  deriv su = d_su
  deriv sv = d_sv
  #   params b mu su sv
end mle --quiet
matrix ret1=$coeff~$vcv
scalar rr2=rows(ret1)-4
matrix ret2=$lnl|$aic|$bic|$hqc|zeros(rr2,1)
return ret1~ret2
</code>
</gretl-function>
<sample-script>
# Sample script to demonstrate use of function sfa_mod
# Estimation of basic stochastic frontier

include sfa_mod.gfn

# Use Greene dataset 9-1
open greene9_1.gdt
series ln_vadd = ln(valadd)
series ln_cap = ln(capital)
series ln_lab = ln(labor)
list xlist = const ln_cap ln_lab

# Some models have problems with convergence, so adjust tolerance
set bfgs_toler 0.0001

# Estimate Exponential Model
# Ignore warning message - results correspond to Greene's results 
matrix sfa_coeff1 = sfa_mod(ln_vadd, xlist, &quot;E&quot;, &quot;P&quot;)
print sfa_coeff1

# Use coefficients from Exponential Model to estimate Half-Normal Model
matrix start2 = zeros(5,1)
matrix start2[1:5,1] = sfa_coeff1[1:5,1]
matrix sfa_coeff2 = sfa_mod(ln_vadd, xlist, &quot;H&quot;, &quot;P&quot;, &amp;start2)

# Estimate Truncated Normal Model
matrix sfa_coeff3 = sfa_mod(ln_vadd, xlist, &quot;T&quot;, &quot;P&quot;)

print ln_vadd --byobs

# Generate efficiency residuals for Exponential Model
# series upred = sfa_eff(ln_vadd, xlist, sfa_coeff1, &quot;E&quot;, &quot;P&quot;)
# Generate technical efficiencies for Exponential Model
# series tech_eff = sfa_eff(ln_vadd, xlist, sfa_coeff1, &quot;E&quot;, &quot;P&quot;, &quot;T&quot;)

# print ln_vadd upred tech_eff --byobs
</sample-script>
</gretl-function-package>
</gretl-functions>

