<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="BNdecomp" ID="1" needs-time-series-data="true" minver="1.9.92">
<author email="r.lucchetti@univpm.it">Riccardo &quot;Jack&quot; Lucchetti</author>
<version>2.0</version>
<date>2015-03-03</date>
<description>Beveridge-Nelson Decomposition</description>
<label>Beveridge-Nelson decomposition</label>
<menu-attachment>MAINWIN/Variable/Filter</menu-attachment>
<help>
Performs a Beveridge-Nelson decomposition on the series y. It is assumed that y can be represented as an ARIMA process. See Hamilton(1995) &quot;Time Series Analysis&quot;, section 17.5.

If the boolean switch auto is true, then the ARIMA orders will be chosen by minimizing the BIC criterion among all the ARIMA models with maximum orders p and q. Otherwise, an ARIMA(p,1,q) will be used.

If the &quot;verbose&quot; parameter is non-zero, details of the decomposition are shown.

Returns the trend component in a new series.
</help>
<gretl-function name="BNdecomp" type="series">
 <params count="5">
  <param name="y" type="series"/>
  <param name="auto" type="bool"/>
  <param name="p" type="int" min="0" max="4" default="0"/>
  <param name="q" type="int" min="0" max="4" default="0"/>
  <param name="verbose" type="bool" default="1"/>
 </params>
<code>if auto # choose p and q automatically
  scalar minbic = $huge
  scalar maxpq = (p&gt;q) ? p : q
  scalar D1 = 1
  smpl +maxpq ;
  loop i = 0..p --quiet
    loop j = 0..q --quiet
      arima i 1 j ; y --quiet
      # printf &quot;%3d %3d %16.4f\n&quot;, i, j, $bic
      if $bic &lt; minbic
        series m = cum($uhat)
        scalar p_ = i
        scalar q_ = j
        if (i+j) &gt; 0
          D1 = d1($coeff[2:], i, j)
        endif
        minbic = $bic
      endif
    endloop
  endloop
  smpl full
else
  arima p 1 q ; y --quiet
  series m = cum($uhat)
  D1 = d1($coeff[2:], p, q)
endif
if verbose
  printf &quot;Beveridge-Nelson decomposition of %s\n&quot;, argname(y)
  if auto
    printf &quot;using an ARMA(%d, %d) model (auto, BIC = %g)\n&quot;, p_, q_, minbic
  else
    printf &quot;using an ARMA(%d, %d) model (user chosen)\n&quot;, p, q
  endif
endif
series Trend = m*D1
series tmp = y - Trend
ols tmp const time --quiet
return Trend + $yhat
</code>
</gretl-function>
<gretl-function name="d1" type="scalar" private="1">
 <params count="3">
  <param name="coef" type="matrix"/>
  <param name="p" type="scalar"/>
  <param name="q" type="scalar"/>
 </params>
<code>scalar arsum = (p &gt; 0) ? sumc(coef[1:p]) : 0
scalar masum = (q &gt; 0) ? sumc(coef[1+p:p+q]) : 0
return (1+masum)/(1-arsum)
</code>
</gretl-function>
<sample-script>
include BNdecomp.gfn
open data9-7

scalar auto = 1
scalar maxp = 2
scalar maxq = 2
scalar verbose = 1

# choose p and q automatically
series BN_QNC_auto = BNdecomp(QNC, 1, maxp, maxq, verbose)

# choose p and q by hand
series BN_QNC_bh = BNdecomp(QNC, 0, 1, 1, verbose)

gnuplot QNC BN_QNC_auto BN_QNC_bh \
  --with-lines --output=display --time-series
</sample-script>
</gretl-function-package>
</gretl-functions>

