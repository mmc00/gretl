<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="HoltWinters" ID="1266684682" needs-time-series-data="true" minver="1.9.10">
<author email="ignacio.diaz-emparanza@ehu.eus">Ignacio Diaz-Emparanza</author>
<version>1.9</version>
<date>2015-05-26</date>
<description>Time series forecasting using Holt-Winters exponential smoothing</description>
<help>
IMPORTANT: If you want to make some forecasts out of the sample, extend the sample in the number of obs. that you want. For example: &quot;dataset addobs +4&quot; (or in the GUI: /Data/Add obs.)
Alternatively, setting a number different from zero in the field &quot;Number of final intra-sample predictions=n&quot; you may make n forecasts within the sample, and use them to compare with 
the las n observed values by means of ECM and EAM. 

For annual data, the local linear trend model, based on double exponential smoothing by Holt is used to smooth and to obtain forecasts for a univariate series. The model used is:

\hat(Y)_t(l)=S_t+l b_t

being

S_t=delta_1 Y_t + (1-delta_1)(S_{t-1}+b_{t-1})
b_t=delta_2(S_t-S_{t-1})+(1-delta_2) b_{t-1}

0 &lt; delta_1 &lt; 1 and 0 &lt; delta_2 &lt;1

initial values for S_t and b_t are calculated by means of a linear trend estimation along the full sample.

For seasonal data (periodicity, $pd &gt; 1) the seasonal extension by Winters is also computed. The model used here is a mixture additive/multiplicative model:

\hat(Y)_t(l) = (S_t+l b_t) I_{t+l-$pd}

being

S_t=delta_1 (Y_t/I_{t-$pd} + (1-delta_1)(S_{t-1}+b_{t-1})
b_t=delta_2(S_t-S_{t-1})+(1-delta_2) b_{t-1}
I_t=delta_3 (Y_t/S_t) + (1-delta_3) I_{t-$pd}

0 &lt; delta_1 &lt; 1 and 0 &lt; delta_2 &lt;1

Initial values for the seasonal component (I_t) are calculated using the mean of each period in the first 4 years.

Reference: &quot;Econometría. Series temporales y predicción&quot; (1993). Jose M. Otero. Ed: AC. Madrid.
</help>
<gretl-function name="HoltWinters" type="list">
 <params count="6">
  <param name="y" type="series">
<description>Dependent variable</description>
  </param>
  <param name="delta1" type="scalar" min="0" max="1" default="0.3">
<description>Level smoothness parameter</description>
  </param>
  <param name="delta2" type="scalar" min="0" max="1" default="0.1">
<description>Slope smoothness parameter</description>
  </param>
  <param name="delta3" type="scalar" min="0" max="1" default="0.7">
<description>Seasonality smoothness parameter</description>
  </param>
  <param name="pred" type="int" min="0" max="12" default="0">
<description>Number of final intra-sample predictions</description>
  </param>
  <param name="printresults" type="bool" default="0">
<description>Print numerical results</description>
  </param>
 </params>
<code>catch smpl y --contiguous
if $error
  print &quot;There are internal missing values&quot;
endif
if pred&gt;0
  smpl ; -pred
endif
string sy = argname(y)
genr time
#Holt
#Initial values by means of a global linear trend
ols y 0 time --quiet
series yh1= (0.85*y&lt;= $yhat &amp;&amp; $yhat &lt;=1.15*y) ? $yhat : y
series s1 = NA*const
series b1 = NA*const
scalar f=$t1
scalar f2=$t1+1
scalar u1=$t2
genr s1[f]=yh1[f]
genr b1[f]=yh1[f2]-yh1[f]
#scalar lobs=lastobs(y)-firstobs(y)+1 # Current sample size
scalar lobs=$t2-$t1+1 # Current sample size
loop i=f2..lobs --quiet
  genr s1[i] = delta1*y[i] + (1-delta1)*(s1[i-1]+b1[i-1])
  genr b1[i] = delta2*(s1[i]-s1[i-1]) + (1-delta2)*b1[i-1]
endloop
smpl --full
# Number of predictions, equal to the number of missing obs. at the end of the variable
scalar predh = $t2-u1
if predh&gt;0
  loop i=1..predh --quiet
    scalar ji=lobs+i
    genr s1[ji] = s1[ji-1]+b1[ji-1]
    genr b1[ji] = b1[ji-1]
  endloop
endif
if pred&gt;0
  smpl y --contiguous
  matrix my = { y }
  matrix calpred = my[$t2-pred+1:$t2,1]~zeros(pred,1)
  loop i=1..pred --quiet
    scalar ji=lobs+i
    calpred[i,2] = y[ji]-(s1[ji]+b1[ji])
  endloop
  calpred = calpred ~ calpred[,2].*calpred[,2] ~ abs(calpred[,2])
  scalar ECM = sum(calpred[,3])/rows(calpred)
  scalar EAM = sum(calpred[,4])/rows(calpred)
endif
#series @sy_H = s1(-1)+b1(-1)
series @sy_H = s1+b1
setinfo @sy_H -d &quot;Holt's trend prediction component&quot; -n &quot;Holt smoother&quot;
series @sy = y
list salida = @sy @sy_H
#Winters
if $pd&gt;1
  series s1 = y
  series b1 = NA*const
  series I1 = NA*const
  #Computing initial values for the seasonal based on 4 years data
  scalar s=$pd
  scalar s4=firstobs(y)+4*s-1
  series dumvar = (obs&lt;=s4 &amp;&amp; obs&gt;=f)
  if lobs&lt;s4
    print &quot;Insuficient data (4 years needed)&quot;
  endif
  smpl dumvar --dummy
  ols y 0 time --quiet
  series yh=y/$yhat
  scalar b11=0
  scalar denom=0
  scalar fs=firstobs(y)+(s-1)
  loop i=f..fs --quiet
    scalar j1 = i+s
    scalar j2 = i+2*s
    scalar j3 = i+3*s
    genr I1[i]=(yh[i]+yh[j1]+yh[j2]+yh[j3])/4
    scalar b11 = b11 + y[s+i]-y[i]
    scalar denom = denom + I1[i]
  endloop
  #scalar cf=s/(I1[1]+I1[2]+I1[3]+I1[4])
  scalar cf = s/denom
  series I1 = cf*I1
  genr b1[fs]=b11/(s^2)
  genr s1[fs]=y[fs]
  #Evaluating the components for the rest of the sample
  scalar sm1=firstobs(y)+s
  loop i=sm1..lobs --quiet
    genr s1[i] = delta1*(y[i]/I1[i-s]) + (1-delta1)*(s1[i-1]+b1[i-1])
    genr b1[i] = delta2*(s1[i]-s1[i-1]) + (1-delta2)*b1[i-1]
    genr I1[i] = delta3*(y[i]/s1[i])+(1-delta3)*I1[i-s]
  endloop
  smpl --full
  scalar predh = $t2-u1
  if predh&gt;0
    loop i=1..predh --quiet
      scalar ji=lobs+i
      genr s1[ji] = s1[ji-1]+b1[ji-1]
      genr b1[ji] = b1[ji-1]
      genr I1[ji] = I1[ji-s]
    endloop
  endif
  #----
  if pred&gt;0
    smpl y --contiguous
    matrix calpredW = my[$t2-pred+1:$t2]~zeros(pred,1)
    loop i=1..pred --quiet
      scalar ji=lobs+i
      calpredW[i,2] = y[ji]-(s1[ji]+b1[ji])*I1[ji-s]
    endloop
    calpredW = calpredW ~ calpredW[,2].*calpredW[,2] ~ abs(calpredW[,2])
    scalar ECMW = sum(calpredW[,3])/rows(calpredW)
    scalar EAMW = sum(calpredW[,4])/rows(calpredW)
  endif
  smpl --full
  #----
  #        series @sy_W = (s1(-1)+b1(-1))*I1(-s)
  series @sy_W = (s1+b1)*I1
  setinfo @sy_W -d &quot;Winters' trend + seasonal prediction component&quot; -n &quot;Winters smoother&quot;
  list salida += @sy_W
endif
if $pd=1
  printf &quot;\n Annual data. There is no seasonality, so the Winters component is not computed\n&quot;
endif
if printresults=1
  print salida --byobs
endif
if pred&gt;0
  printf &quot;\nStatistics for the quality of predictions:\n\n&quot;
  printf &quot;         MSE\t\tMAE \n&quot;
  printf &quot;         ---\t\t---\n&quot;
  printf &quot;HOLT:    %4.4f \t%4.4f\n&quot;, ECM, EAM
  printf &quot;WINTERS: %4.4f \t%4.4f\n\n&quot;, ECMW, EAMW
  printf &quot;Number of predictions: %.0f (%s-%s) \n\n&quot;, pred, obslabel(u1+1), obslabel(u1+pred)
endif
return salida
</code>
</gretl-function>
<sample-script>
include HoltWinters.gfn 

open data9-3.gdt
# delta1=0.5, delta2=0.1, delta3=0.7, intra-sample predictions=4
list lHW=HoltWinters(reskwh, 0.5, 0.1, 0.7, 4)
print lHW --byobs

#Adding space for post-sample predictions
dataset addobs +4
#
#Running the function with default values:
#delta1=0.3, delta2=0.1, delta3=0.7
list lHW2=HoltWinters(reskwh)
print lHW2 --byobs

#Example with annual data:
#
#open data3-6.gdt
#list comp=HoltWinters(Ct)
</sample-script>
</gretl-function-package>
</gretl-functions>

