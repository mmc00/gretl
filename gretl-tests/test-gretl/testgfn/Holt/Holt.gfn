<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="Holt" ID="1444052201" needs-time-series-data="true" minver="2015a" lives-in-subdir="true">
<author email="ignacio.diaz-emparanza@ehu.eus">Ignacio Diaz-Emparanza</author>
<version>1.0</version>
<date>2015-10-05</date>
<description>Holt's local linear trend</description>
<tags>C22 C53</tags>
<label>Holt's trend</label>
<menu-attachment>MAINWIN/Variable/Filter</menu-attachment>
<help>
pdfdoc:Holt.pdf
</help>
<gretl-function name="Holt" type="bundle" pkg-role="gui-main">
 <params count="5">
  <param name="y" type="series">
<description>Dependent variable</description>
  </param>
  <param name="delta1" type="scalar" min="0" max="1" default="0.3">
<description>Level smoothness parameter</description>
  </param>
  <param name="delta2" type="scalar" min="0" max="1" default="0.1">
<description>Slope smoothness parameter</description>
  </param>
  <param name="init" type="int" min="0" max="2" default="2">
<description>Initial values based on:</description>
<labels count="3">
"the first two observations" "a regression with the whole sample" "a regression with the first half of the sample" </labels>
  </param>
  <param name="pred" type="int" default="0">
<description>Number of final intra-sample predictions</description>
  </param>
 </params>
<code>catch smpl y --contiguous
if $error
  funcerr &quot;There are internal missing values&quot;
endif
if pred&gt;0
  smpl ; -pred
endif
scalar nwhole=$nobs
scalar nhalf=floor($nobs/2)
string sy = argname(y)
genr time
series s1 = NA*const
series b1 = NA*const
scalar f=$t1
if init==0
  #Initial values s1[1]=y[1] and b1[1]=y[2]-y[1]
  genr s1[f]=y[f]
  genr b1[f]=y[f+1]-y[f]
elif init == 1
  #Initial values by means of a global linear trend
  ols y 0 time --quiet
  series yh1 = $yhat
  genr s1[f]=delta1*y[f]+(1-delta1)*($coeff[1]+$coeff[2])
  genr b1[f]=delta2*(s1[f]-$coeff[1])+(1-delta2)*$coeff[2]
else
  #Initial values by means of a linear trend for the first half
  string sfirst = obslabel($t1)
  string slast = obslabel($t2)
  string slast2 = obslabel(nhalf)
  smpl @sfirst @slast2
  ols y 0 time --quiet
  series yh1 = $yhat
  genr s1[f]=delta1*y[f]+(1-delta1)*($coeff[1]+$coeff[2])
  genr b1[f]=delta2*(s1[f]-$coeff[1])+(1-delta2)*$coeff[2]
  smpl @sfirst @slast
endif
scalar f2=$t1+1
scalar u1=$t2
scalar lobs=$t2-$t1+1 # Current sample size
loop i=f2..lobs --quiet
  genr s1[i] = delta1*y[i] + (1-delta1)*(s1[i-1]+b1[i-1])
  genr b1[i] = delta2*(s1[i]-s1[i-1]) + (1-delta2)*b1[i-1]
endloop
smpl --full
# Number of predictions, equal to the number of missing obs. at the end of the variable
scalar predh = $t2-u1
if predh&gt;0
  loop i=1..predh --quiet
    scalar ji=lobs+i
    genr s1[ji] = s1[ji-1]+b1[ji-1]
    genr b1[ji] = b1[ji-1]
  endloop
endif
bundle b
if pred&gt;0
  smpl y --contiguous
  matrix my = { y }
  matrix calpred = my[$t2-pred+1:$t2,1]~zeros(pred,1)
  loop i=1..pred --quiet
    scalar ji=lobs+i
    calpred[i,2] = y[ji]-(s1[ji]+b1[ji])
  endloop
  calpred = calpred ~ calpred[,2].*calpred[,2] ~ abs(calpred[,2])
  scalar MSE = sum(calpred[,3])/rows(calpred)
  scalar MAE = sum(calpred[,4])/rows(calpred)
  b[&quot;MSE&quot;] = MSE
  b[&quot;MAE&quot;] = MAE
endif
series @sy_H = (obs==f) ? s1[f] : s1(-1)+b1(-1)
setinfo @sy_H -d &quot;Holt's trend prediction component&quot; -n &quot;Holt smoother&quot;
series @sy = y
b[&quot;yname&quot;] = &quot;@sy&quot;
b[&quot;@sy&quot;] = y
b[&quot;@sy_Holt&quot;] = @sy_H
setnote(b, &quot;@sy&quot;, &quot;original series&quot;)
setnote(b, &quot;@sy_Holt&quot;, &quot;Holt's linear smoother&quot;)
b[&quot;pred&quot;] = pred
b[&quot;u1&quot;] = u1
Holt_print(&amp;b)
return b
</code>
</gretl-function>
<gretl-function name="Holt_print" type="void" pkg-role="bundle-print">
 <params count="1">
  <param name="b" type="bundleref"/>
 </params>
<code>string sy = b[&quot;yname&quot;]
series @sy = b[&quot;@sy&quot;]
series @sy_Holt = b[&quot;@sy_Holt&quot;]
scalar pred = b[&quot;pred&quot;]
scalar u1 = b[&quot;u1&quot;]
print @sy @sy_Holt --byobs
if pred&gt;0
  scalar MSE = b[&quot;MSE&quot;]
  scalar MAE = b[&quot;MAE&quot;]
  printf &quot;\nStatistics for the quality of predictions:\n\n&quot;
  printf &quot;         Mean Sq. Err. \t Mean. Abs. Err. \n&quot;
  printf &quot;         --------------\t--------------\n&quot;
  printf &quot;HOLT:    %4.4f \t %4.4f\n\n&quot;, MSE, MAE
  printf &quot;Number of predictions: %.0f (%s-%s) \n\n&quot;, pred, obslabel(u1+1), obslabel(u1+pred)
endif
delete b[&quot;pred&quot;]
delete b[&quot;u1&quot;]
</code>
</gretl-function>
<gretl-function name="Holt_plot" type="void" no-print="1" pkg-role="bundle-plot">
 <params count="1">
  <param name="b" type="bundleref"/>
 </params>
<code>string sy = b[&quot;yname&quot;]
series @sy = b[&quot;@sy&quot;]
series @sy_Holt = b[&quot;@sy_Holt&quot;]
gnuplot @sy @sy_Holt --with-lines --time-series --output=display
</code>
</gretl-function>
<sample-script>
include Holt.gfn

open data3-6.gdt

#Calculate the local linear trend and
#MSE and MAE for last 3 obs in the sample
bundle bHolt=Holt(Ct,0.3,0.1,1,3)

#Internally the smoothed series is saved in the bundle as name_Holt
#to extract it you may execute
series Ct_Holt = bHolt.Ct_Holt

#forecast 4 observations
dataset addobs +4
bundle bHolt=Holt(Ct,0.3,0.1,2)
series Ct_Holtpred = bHolt.Ct_Holt
</sample-script>
</gretl-function-package>
</gretl-functions>
