<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="suradf" ID="1427125707" needs-time-series-data="true" minver="1.9.92">
<author email="cottrell@wfu.edu">Allin Cottrell</author>
<version>0.2</version>
<date>2015-03-23</date>
<description>SUR-based ADF-type test for multiple time series</description>
<help>
This package implements the unit root test defined by
Jan Boucher Breuer, Robert McNown and Myles Wallace
(&quot;Series-specific Unit Root Tests with Panel Data&quot;,
Oxford Bulletin of Economics and Statistics, 64:5,
2002, pp. 527-546).

The test gives a specific result for the unit-root null 
hypothesis for each series in a given list, exploiting
the cross-correlations of the series to gain greater power
than a regular univariate ADF test (provided that the
correlations -- which are exploited via SUR estimation --
are faily substantial).

The test statistic, labeled SURADF, follows a non-standard
distribution; this package will calculate critical values
and p-values via the Monte Carlo method with a chosen number
of replications.

Parameters of the suradf function:

xlist: The list of (at least two) series to be tested.

plags: Row vector containing lag orders for the series.
  You may give a specific lag length for each series, or
  may supply a 1-vector in which case the same order 
  is used for all.

t1: The 1-based index of the observation at which estimation
  should start. This should make allowance for observations
  lost by forming lags.

drift: Use 1 to allow for drift in the series or 0 to enforce 
  an intercept of zero in the null hypothesis.

nr: The number of Monte Carlo replications. If this is set to
  zero SURADF test statistics are calculated but no critical
  values are reported. A value of 1000 should be sufficient to
  get meaningful critical values, but use a higher value if you
  like.
</help>
<gretl-function name="suradf" type="matrix">
 <params count="5">
  <param name="xlist" type="list">
<description>set of series to test</description>
  </param>
  <param name="plags" type="matrix">
<description>per-series lag orders</description>
  </param>
  <param name="t1" type="obs" min="2">
<description>starting observation</description>
  </param>
  <param name="drift" type="bool" default="0">
<description>include an intercept?</description>
  </param>
  <param name="nr" type="int" min="0" default="500">
<description>number of replications</description>
  </param>
 </params>
<code>scalar nc = nelem(xlist)
scalar np = cols(plags)
if nc == 1
  funcerr &quot;xlist must have at least 2 members&quot;
endif
if np == 1
  plags = plags[1] * ones(1, nc)
else
  if np != nc
    funcerr &quot;plags must have the same number of columns as xlist&quot;
  endif
endif
# max lag length for differences
scalar plagmax = maxr(plags)
# allow for dep var, const (if applicable) and lagged level
scalar listmax = plagmax + 3
matrix surt = zeros(1, nc)
matrix surmat = zeros(nc, listmax)
matrix surrow
string vname
# create series xdi for differences, xi for levels
loop foreach i xlist -q
  sprintf vname &quot;xd%d&quot;, i
  series @vname = diff(xlist.$i)
  sprintf vname &quot;x%d&quot;, i
  series @vname = xlist.$i
endloop
/* first construct equation lists and run the
&quot;SURADF&quot; regressions to get the test
statistics for the individual series
*/
# SURADF equation lists
loop i=1..nc -q
  scalar p = -plags[i]
  list eqlist = xd$i const x$i(-1) xd$i(-1 to p)
  surrow = eqlist
  k = nelem(eqlist)
  surmat[i,1:k] = surrow
endloop
smpl t1 ;
# SURADF estimation (get test stats)
printf &quot;\n== Initial SUR estimation to get test statistics ==\n&quot;
system method=SUR # --quiet
  equations surmat
end system
printf &quot;SUR-ADF: used %d observations\n&quot;, $T
k = 3
loop i=1..nc -q
  scalar lim = plags[i]
  scalar levpos = k - 1
  # record the test statistics
  surt[i] = $coeff[levpos] / $stderr[levpos]
  k += plags[i] + 2
endloop
if nr &gt; 0
  /* Now build lists and run SUR again, to get the
  &quot;gamma&quot; matrix of AR coefficients for the
  Monte Carlo process. The estimation here omits
  the lagged levels, since according to the null
  hypothesis these have zero coefficients.
  */
  listmax = plagmax + 1 + drift
  surmat = zeros(nc, listmax)
  # &quot;gamma&quot; equation lists
  loop i=1..nc -q
    scalar p = -plags[i]
    if drift
      list eqlist = xd$i const xd$i(-1 to p)
    else
      list eqlist = xd$i xd$i(-1 to p)
    endif
    surrow = eqlist
    k = nelem(eqlist)
    surmat[i,1:k] = surrow
  endloop
  # SUR-H0 estimation
  printf &quot;\n== Estimating the system as specified by H0 ==\n&quot;
  system method=SUR # --quiet
    equations surmat
  end system
  printf &quot;SUR-H0: used %d observations\n&quot;, $T
  matrix S = $sigma
  matrix G = zeros(nc, plagmax)
  matrix mu = zeros(1, nc)
  k = 1 + drift
  loop i=1..nc -q
    scalar lim = plags[i]
    G[i,1:lim] = $coeff[k:k+lim-1]'
    if drift
      mu[i] = $coeff[k-1]
    endif
    k += plags[i] + drift
  endloop
  printf &quot;\n== Matrices for Monte Carlo replications ==\n&quot;
  printf &quot;\nGamma (H0)\n\n%#12.5g&quot;, G
  if drift
    printf &quot;\nMu (H0)\n\n%#12.5g&quot;, mu
  endif
  matrix avgcorr = do_cov_corr(&amp;S, &quot;Sigma (H0)&quot;)
  if nr &gt; 1
    smpl --full
    matrix cv = suradf_critvals(&amp;G, &amp;S, &amp;plags, &amp;mu, &amp;surt, t1, nr)
  endif
endif # nr &gt; 0
if nr &gt; 100
  printf &quot;== Results based on %d replications ==\n\n&quot;, nr
  printf &quot;%10s%10s%10s%10s%10s%10s\n\n&quot;, &quot; &quot;, &quot;AVGCORR&quot;, &quot;SURADF&quot;, &quot;.01&quot;, &quot;.05&quot;, &quot;.10&quot;
else
  printf &quot;== Results, without critical values ==\n\n&quot;
  printf &quot;%10s%10s%10s\n\n&quot;, &quot; &quot;, &quot;AVGCORR&quot;, &quot;SURADF&quot;
endif
loop foreach i xlist -q
  printf &quot;%10s%10.3f%10.3f&quot;, &quot;$i&quot;, avgcorr[i], surt[i]
  if nr &gt; 100
    printf &quot;%10.3f%10.3f%10.3f  [%.3f]&quot;, cv[1,i], cv[2,i], cv[3,i], cv[4,i]
  endif
  printf &quot;\n&quot;
endloop
printf &quot;\n&quot;
return surt
</code>
</gretl-function>
<gretl-function name="do_cov_corr" type="matrix" private="1">
 <params count="2">
  <param name="V" type="matrixref" const="true"/>
  <param name="s" type="string"/>
 </params>
<code>matrix m = V
scalar n = rows(m)
matrix avgcorr = zeros(1, n)
loop i=1..n -q
  scalar jmin = i+1
  loop j=jmin..n -q
    m[i,j] = V[i,j] / sqrt(V[i,i] * V[j,j])
    avgcorr[i] += m[i,j]
    avgcorr[j] += m[i,j]
  endloop
endloop
printf &quot;\n%s, showing correlations above the diagonal\n\n%#12.5g\n&quot;, s, m
avgcorr /=  n - 1
return avgcorr
</code>
</gretl-function>
<gretl-function name="suradf_critvals" type="matrix" private="1">
 <params count="7">
  <param name="gam" type="matrixref" const="true"/>
  <param name="sig" type="matrixref"/>
  <param name="plags" type="matrixref" const="true"/>
  <param name="mu" type="matrixref" const="true"/>
  <param name="sampt" type="matrixref" const="true"/>
  <param name="t1" type="int"/>
  <param name="nr" type="int"/>
 </params>
<code>scalar nc = rows(sig)
scalar Tinit = 50
scalar Ttot = Tinit + $nobs
scalar plagmax = maxr(plags)
scalar dstart = plagmax + 1
# printf &quot;critval: t1=%d, nobs=%d, Ttot=%d\n&quot;, t1, $nobs, Ttot
if (cols(gam) != plagmax)
  funcerr &quot;size of gam does not match plags&quot;
endif
# coeffs on lagged level (0.0 for unit root case)
matrix delta = zeros(1, nc)
matrix et
matrix y = zeros(Ttot, nc)
matrix yd = zeros(Ttot, nc)
matrix surt = zeros(nr, nc)
matrix pvals = zeros(1, nc)
scalar listmax = plagmax + 3
matrix surmat = zeros(nc, listmax)
matrix surrow
sig = cholesky(sig)
# begin replication loop
loop ir=1..nr --quiet
  smpl --full
  # initialize
  y = zeros(Ttot, nc)
  yd = zeros(Ttot, nc)
  # generate data
  loop it=dstart..Ttot -q
    et = sig * mnormal(nc, 1)
    yd[it,] = mu + delta .* y[it-1,] + et'
    loop i=1..nc -q
      p = plags[i]
      loop j=1..p -q
        yd[it,i] += gam[i,j] * yd[it-j,i]
      endloop
    endloop
    y[it,] = y[it-1,] + yd[it,]
  endloop
  # print yd y
  # create series xdi for differences, xi for levels,
  # skipping the first Tinit values
  loop i=1..nc -q
    series xd$i = yd[Tinit+1:,i]
    series x$i = y[Tinit+1:,i]
  endloop
  # model lists for SUR
  loop i=1..nc -q
    p = -plags[i]
    list eqlist = xd$i const x$i(-1) xd$i(-1 to p)
    surrow = eqlist
    k = nelem(eqlist)
    surmat[i,1:k] = surrow
  endloop
  # SUR estimation (in loop)
  smpl t1 ;
  system method=SUR --quiet
    equations surmat
  end system
  k = 2
  loop i=1..nc -q
    surt[ir,i] = $coeff[k] / $stderr[k]
    # printf &quot;SUR tau = %g\n&quot;, $coeff[k] / $stderr[k]
    if surt[ir,i] &lt; sampt[i]
      pvals[i] += 1
    endif
    k += plags[i] + 2
  endloop
endloop # end of main replication loop
pvals /= nr
# summary --matrix=surt
pct = quantile(surt, {0.01, 0.05, 0.1}) | pvals
return pct
</code>
</gretl-function>
<sample-script>
include suradf.gfn

/* The following replicates the results shown in
   Breuer, McNown and Wallace (2002)
*/

open http://ricardo.ecn.wfu.edu/pub/gretldata/boucher_exrates.gdt

# generate logs of the exchange-rate series
logs UKEXR FRAEXR GEREXR JAPEXR

# construct list of series for testing
list X = l_JAPEXR l_UKEXR l_GEREXR l_FRAEXR

# vector of ADF-style lags, per series
matrix plags = {5, 5, 4, 1}

# observation at which to start estimation (this should
# allow for the loss of observations due to lags)
scalar t1 = obsnum(&quot;1975:3&quot;)

# invoke suradf function and save the results to a matrix;
# here we specify only 500 replications, 5000 would produce
# a closer approximation to the published results
matrix test = suradf(X, plags, t1, 0, 500)
</sample-script>
</gretl-function-package>
</gretl-functions>

