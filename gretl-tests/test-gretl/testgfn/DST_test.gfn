<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="DST_test" ID="1281539180" needs-time-series-data="true" minver="1.8.4">
<author email="mblazejowski@wsb.torun.pl">Marcin Błażejowski</author>
<version>1.05</version>
<date>2011-10-01</date>
<description>Dickey's Stationarity Test fot High Frequency Data</description>
<help>
This package implemets Dickey's Stationarity Testing in High-Frequency Seasonal Time Series procedure. Code of this package is based on the paper D. A. Dickey, Y.Zhang, &quot;Seasonal unit root tests in long periodicity cases&quot;, Journal of the Korean Statistical Society 39 (2010), pp. 271-279 as well as D.A. Dickey &quot;Stationarity Testing in High-Frequency Seasonal Time Series&quot; (http://support.sas.com/resources/papers/proceedings09/235-2009.pdf) and original SAS code which Prof. Dickey kindly sent to me and let me have a look at it.

The main function gets following variables:
'x' - series to test

'ar_filter_order' - order of AR(p) filter

'ar_order_fix' - if No, ar_filter_order is selected by estimating AR(p) models for p=1..ar_filter_order and chosing p that minimizes BIC criterion

'deterministic' - list of deterministic elements, such as seasonal dummies, harmonics, trend

'lag_order' - periodicity (lag) at which we look for unit root

'verbose' - print results of all stages or not

Function returns p-value or number of error:
 '-1' - missing values encountered

H0: series is nonstationary at given periodicity (is SI(1)).

If you have any suggestions, you found a bug, etc, feel free to write:
marcin.blazejowski@wsb.torun.pl
</help>
<gretl-function name="DST_test" type="scalar">
 <params count="6">
  <param name="x" type="series">
<description>Series to test</description>
  </param>
  <param name="ar_filter_order" type="int" min="1" max="10000" default="1">
<description>Order of autoregressive filter</description>
  </param>
  <param name="ar_order_fix" type="bool" default="1">
<description>Is that order fixed or maximal? (defult: fixed)</description>
  </param>
  <param name="deterministic" type="list" optional="true">
<description>List of deterministic components</description>
  </param>
  <param name="lag_order" type="int" min="1" max="10000" default="1">
<description>Seasonal unit root periodicity</description>
  </param>
  <param name="verbose" type="bool" default="1">
<description>Be verbose?</description>
  </param>
 </params>
<code># This function realizes Dickey's high frequency data statinarity test
#
# x         		- series to test
# ar_filter_order - order of AR(p) filter
# ar_order_fix 	- if Yes, ar_filter_order is selected by estimating AR(p) models for p=1..ar_filter_order
#						and chosing p that minimizes BIC criterion
# deterministic   - list of deterministic elements, such seasonal dummies, harmonics, trend
# lag_order		- periodicity (lag) at which we look for unit root
# verbose			- printing results of all stages or not
#
#	returns p-value, H0: series is nonstationary at given periodicity (is SI(1))
#
series det_clean			# series cleand by deterministic elements
series sd_det_clean		# seasonal (at given lag_order) differences of series det_clean
matrix Phi				# vector of coefficients of AR(p) filter
series FY					# series det_clean cleaned by AR(p) filter with Phi coefficients
scalar DST_statistic		# main test statistic
scalar DST_statistic_p	# returned p-value of DST_statistic
scalar shift = 0			# do we have lagged or differenced series?
# We check structure of the sample
DST_statistic_p = DST_check_sample(&amp;x, $nobs, $t1, &amp;shift, verbose)
if (DST_statistic_p != 0)
  return DST_statistic_p
endif
# We filter tested series by deterministic components
if (nelem(deterministic) != 0)
  det_clean = DST_det_filter(&amp;x, deterministic, verbose)
else
  det_clean = x
endif
# We now create seasonal diffrencss of &quot;cleaned&quot; series for further anaysis
sd_det_clean = DST_sdiff(&amp;det_clean, &amp;lag_order)
# STEP 1 of DHF - looking for autoregressive filter
Phi = DST_ar_filter(&amp;sd_det_clean, &amp;ar_filter_order, ar_order_fix, verbose)
# STEP 2 of DHF - cleaning series det_clean by autoregressive filter with Phi coefficients
FY = DST_ar_clean(&amp;det_clean, &amp;Phi, &amp;ar_filter_order, &amp;shift)
# Retrive main test statistic (corrected) DST_statistic ~ N(0,1)
DST_statistic = DST_stat(&amp;FY, &amp;sd_det_clean, &amp;lag_order, ar_filter_order, nelem(deterministic), verbose)
if (DST_statistic &lt; 0)
  DST_statistic_p = 2*(1-pvalue(z, DST_statistic))
elif (DST_statistic &gt; 0)
  DST_statistic_p = (1-2*pvalue(z, DST_statistic))
else
  DST_statistic_p = pvalue(z, DST_statistic)
endif
if (verbose == 1)
  printf &quot;#################################################################\n&quot;
  printf &quot;H0: series is nonstationary at given periodicity t-%d (is SI(1))\n\n&quot;, lag_order
  if ar_order_fix == 0
    printf &quot;Final AR(p) order selected by BIC:\t%d\n&quot;, ar_filter_order
  endif
  printf &quot;DST statistic (corrected):\t\t%f\n&quot;, DST_statistic
  printf &quot;p-value of DST:\t\t\t\t%.12f\n&quot;, DST_statistic_p
endif
return DST_statistic_p
</code>
</gretl-function>
<gretl-function name="DST_det_filter" type="series" private="1">
 <params count="3">
  <param name="x" type="seriesref"/>
  <param name="deterministic" type="list"/>
  <param name="verbose" type="bool" default="NA"/>
 </params>
<code># This function regres tested series with deterministic elements
# and returns residuals
#
# *x				- pointer to tested series
# deterministic	- list of deterministic components
#
# returns $uhat
#
if (verbose == 1)
  ols x deterministic --simple-print
else
  ols x deterministic --quiet
endif
return $uhat
</code>
</gretl-function>
<gretl-function name="DST_ar_filter" type="matrix" private="1">
 <params count="4">
  <param name="x" type="seriesref"/>
  <param name="order" type="scalarref"/>
  <param name="fixed" type="bool" default="NA"/>
  <param name="verbose" type="bool" default="NA"/>
 </params>
<code># This function estimates AR(p) filter and returs Phi coefficients
#
# *x			- pointer to series for which we estimate ARIMA(order,0,0) model
# *order		- pointer to given AR(p) order
# fixed		- boolean variable: if given order is fixed or maximal, so we
#				have to find such ARIMA(p,0,0) specification that minimaze BIC criterion
#
# returns vector with AR(p) coefficients (Phi)
#
# We look for the best ARIMA(p,0,0) specification (in light of BIC criterion)
if (fixed == 0)
  scalar BIC = 100000000000
  loop for i=1..order --quiet
    arima $i 0 0 ; x --nc --quiet
    if $bic &lt; BIC
      BIC = $bic
      order = i
    endif
  endloop
endif
# Estimate AR(order) model to retrive coefficients Phi
if (verbose == 1)
  arima order 0 0 ; x --nc
else
  arima order 0 0 ; x --nc --quiet
endif
return $coeff
</code>
</gretl-function>
<gretl-function name="DST_ar_clean" type="series" private="1">
 <params count="4">
  <param name="x" type="seriesref"/>
  <param name="beta" type="matrixref"/>
  <param name="order" type="scalarref"/>
  <param name="shift" type="scalarref"/>
 </params>
<code># This function cleans given series by autoregressive filter
#
# *x		- pointer to series to clean
# *beta	- pointer to vector with coefficients (Phi)
# *order	- poinetr to scalar with selected order of AR(p) filter
# *shift	- pointer to scalar with shift of start of the series
#
# returns cleaned series FY
#
list X_lag = lags(order, x)		# list of lagged series x
matrix x_lag = { X_lag }			# matrix of lagged series x
matrix x_mat = x        			# vector of series x
x_mat = x_mat[order+shift+1:$t2]	# subvector of x, where we omit first (order) observations
x_mat -= x_lag * beta				# we now clean given series
# Now we create series FY to return
series FY = NA
s = $t1+order # the start of the sample range
r = rows(x_mat)
loop for (i=1; i&lt;=r; i++) --quiet
  FY[s] = x_mat[i]
  s++
endloop
return FY
</code>
</gretl-function>
<gretl-function name="DST_sdiff" type="series" private="1">
 <params count="2">
  <param name="x" type="seriesref"/>
  <param name="lag" type="scalarref"/>
 </params>
<code># Obvious...
return x - x(-lag)
</code>
</gretl-function>
<gretl-function name="DST_stat" type="scalar" private="1">
 <params count="6">
  <param name="x" type="seriesref"/>
  <param name="sd_det_clean" type="seriesref"/>
  <param name="lag_order" type="scalarref"/>
  <param name="ar_filter_order" type="scalar"/>
  <param name="nelem_deter" type="int" default="NA"/>
  <param name="verbose" type="bool" default="NA"/>
 </params>
<code># This function estimates main regression and retrive main test statistic
#
# *x	- pointer to cleaned series to test (by deterministic and AR(p) filter)
# *sd_det_clean	- pointer to seasonal (at lag lag_order) differences of cleaned
#					series to test (by deterministic elements)
# *lag_order	- periodicity od unit root we look for (lag)
# ar_filter_order	- selected order of AR(p) filter
# nelem_deter		- number of deterministic elements
#
# returns corrected main test statistic
#
scalar DST_st = 0
# Main test regression
ar_filter_order *= -1
sd_x = DST_sdiff(&amp;x, &amp;lag_order)
if (verbose == 1)
  ols sd_x const x(-lag_order) sd_det_clean(-1 to ar_filter_order) --simple-print
else
  ols sd_x const x(-lag_order) sd_det_clean(-1 to ar_filter_order) --quiet
endif
# t statistic of x(-lag_order) variable
DST_st = $coeff[2]/$stderr[2]
# Correction of t statistics to N(0,1)
DST_st += (1 + nelem_deter*sqrt(2))/(2*sqrt(lag_order))
return DST_st
</code>
</gretl-function>
<gretl-function name="DST_check_sample" type="scalar" private="1">
 <params count="5">
  <param name="x" type="seriesref"/>
  <param name="nob" type="int" default="NA"/>
  <param name="startobs" type="int" default="NA"/>
  <param name="shift" type="scalarref"/>
  <param name="verbose" type="bool" default="NA"/>
 </params>
<code># This function checks structure of sample and
scalar ret = 0
#Now check for any NAs embedded in the sample
smpl --contiguous
shift = nob - $nobs
if (nob != $nobs)
  # check if we have lagged or differenced series
  if ((shift + startobs) != $t1)
    # time-series structure gone: must be missing values
    ret = -1
    if (verbose == 1)
      printf &quot;Missing values encountered!!!\n&quot;
    endif
    return ret
  endif
endif
return ret
</code>
</gretl-function>
<sample-script>
include DST_test.gfn
open http://www.uni.torun.pl/~tkufel/DST/natural_gas.gdt

list DET = time s1 c1 s2 c2

# If we want to replicate results of Dickey's Natural Gas exmaple we just
# have to run DST_test package with following parameters. We then can see t-statistic
# -25.14 (which is slightly higher than Dickey's -26.25), value of this statistic
# corrected to N(0,1) and its p-value.
DST_test(Total, 2, 1, DET, 52, 1)

# If we just want to know p-value, we can run the procedure like this:
printf &quot;p-val: %f\n&quot;, DST_test(Total, 2, 1, DET, 52, 0)
##########################################################################################

# In the above examples we filtered the series by AR(2) filter. If we don't know which exactly
# AR(p) filter to use, however we know that p should be i.e. 1&lt;= p &lt;= 10, then we can run
# the procedure as below. All possible ARIMA(p,0,0) models will be estimated and for further
# analysis specification with the lowest BIC criterion will we selected (this order will be
# printed in summary).
DST_test(Total, 10, 0, DET, 52, 1)

# List of deterministic elements is not mandatory, so we can run the procedure with &quot;null&quot;:
DST_test(Total, 10, 0, null, 52, 1)
</sample-script>
</gretl-function-package>
</gretl-functions>

