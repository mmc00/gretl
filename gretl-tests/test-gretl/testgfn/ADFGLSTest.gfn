<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="ADFGLSTest" ID="1428864691" needs-time-series-data="true" minver="1.8.4">
<author email="oleg_komashko@ukr.net">Oleh Komashko</author>
<version>0.055</version>
<date>2015-04-12</date>
<description>ADF-GLS test with interpolated p-values</description>
<label>ADF-GLS test 2</label>
<menu-attachment>MAINWIN/Variable/URTests</menu-attachment>
<help>
Usage:
ADFGLSTest(Y,trend,maxlag,down,crit,pq)
ADFGLSTest(Y)
Parameters: 
 Y (series: series to test)
 trend (bool: include a trend) default is no (trend = 0)
 maxlag (int: Lag order for the ADF-GLS test) default is -1,
      in that case round((12*$nobs/100)^0.25) is used
 downward (bool: test down from maximum lag order)
      default is yes (downward = 1)
 crit (int: criterion) options: MAIC(default, crit =1) and MBIC (crit =0)
 pq (bool: use Perron-Qu method) default is no (pq = 0)

The function is a wrapper to gretl &quot;adf&quot; command, but it
adds additional output to it. It computes p-values, using
full-blown (modified) MacKinnon's(1994) approach based on
our own simulations of sample quantiles.
Output is a matrix containing test statictic and associated 
p-value.

References: 
MacKinnon, J. G. 1994. Approximate asymptotic distribution functions for unit-root and cointegration tests. Journal
of Business and Economic Statistics 12: 167â€“176.

http://ricardo.ecn.wfu.edu/~cottrell/gretl/adfgls-komashko.pdf
</help>
<gretl-function name="ADFGLSTest" type="matrix">
 <params count="6">
  <param name="Y" type="series">
<description>series to test</description>
  </param>
  <param name="trend" type="bool" default="0">
<description>include a trend</description>
  </param>
  <param name="maxlag" type="int" default="-1">
<description>Lag order for the ADF-GLS test</description>
  </param>
  <param name="downward" type="bool" default="1">
<description>test down from maximum lag order</description>
  </param>
  <param name="crit" type="int" min="0" max="1" default="1">
<description>criterion</description>
<labels count="2">
"modified BIC" "modified AIC" </labels>
  </param>
  <param name="pq" type="bool" default="0">
<description>use Perron-Qu method</description>
  </param>
 </params>
<code>if trend = 0
  ret = ADFGLSReg3(Y,maxlag,downward,crit,pq)
else
  ret = ADFGLSReg2(Y,maxlag,downward,crit,pq)
endif
return ret
</code>
</gretl-function>
<gretl-function name="CV" type="matrix" private="1">
 <params count="1">
  <param name="n" type="scalar"/>
 </params>
<code>matrix Q = { 0.4529548801097418, -7.985490009926286, 5.28100588201542, -1.800821096200565; -0.2136030708160094, -5.859704779329829, 3.485273203318237, -1.219572911440313; -0.3108566748600743, -5.247085293334763, 2.94923190839751, -1.004123236647106; -0.3893874617981508, -4.595291384645188, 2.353703970422966, -0.7713214319754254; -0.1314301628877247, -4.498601446747753, 2.144400002581628, -0.6135748306341253; 0.3392090397369993, -4.981811366644166, 2.396870820558403, -0.5982973496542952; 0.6559452100524452, -5.306244356932331, 2.562704897262744, -0.5931679059904142; 0.9540100527773058, -5.683036210933031, 2.788909829669142, -0.6166760831840866; 1.186897878519917, -5.960394367555707, 2.948381497105387, -0.6302912766068333; 1.902308979611512, -6.997156777940726, 3.612063068572172, -0.7382283174365499; 2.831830473321395, -8.508122806920463, 4.623902668473733, -0.9348309528775066; 3.785794501359554, -10.16914296928723, 5.762357524364952, -1.17290094614273; 4.823543875685704, -12.06983765239638, 7.091642681064118, -1.464035650279539; 7.313826281773615, -16.82970027533496, 10.47293642430124, -2.229381035597584; 11.04381893500459, -24.09074814322771, 15.69099825933116, -3.435977633470841 }
scalar z = (n&lt;$huge) ? 1 + 10/n : 1
matrix ret = (z .^ seq(0,3))
return Q * ret'
</code>
</gretl-function>
<gretl-function name="ADFpvals" type="scalar" private="1">
 <params count="2">
  <param name="T" type="scalar"/>
  <param name="tau" type="scalar"/>
 </params>
<code>matrix gp = {0.001,0.0025,0.005,0.01,0.025,0.05,0.075,0.1,0.125,0.2,0.3,0.4,0.5,0.7,0.9}
matrix z = CV(T)
matrix b = mols(invcdf(z,gp)', z .^ seq(0,3))
matrix tt = (tau .^ seq(0,3))
return cnorm(tt*b)
</code>
</gretl-function>
<gretl-function name="nsolveADF" type="scalar" private="1">
 <params count="2">
  <param name="n" type="scalar"/>
  <param name="p" type="scalar"/>
 </params>
<code>set  fdjac_quality 2
if n&lt;=200
  matrix xm = -2
else
  matrix xm = -1
endif
string equa2 = &quot;&quot;
scalar fun = 0
#print fun
scalar der = 0
#print der
scalar x = xm
scalar xplus1 = 0
matrix xplus1m = 0
scalar delta = $huge
loop while delta &gt; 10^-14 --quiet
  equa2 = &quot;allin_Cpval_tr(xm,n)-p&quot;
  fun = @equa2
  der = fdjac(xm,equa2)
  xplus1 = x -fun/der
  delta = abs(xplus1 - x)
  #print delta
  x = xplus1
  xm = x
endloop
return x
</code>
</gretl-function>
<gretl-function name="ADFGLSReg2" type="matrix" private="1">
 <params count="5">
  <param name="Y" type="series"/>
  <param name="p" type="scalar" default="-1"/>
  <param name="down" type="bool" default="1"/>
  <param name="crit" type="scalar" default="1"/>
  <param name="pq" type="bool" default="0"/>
 </params>
<code>if  p = -1
  p =  round(12*($nobs/100)^(1/4))
endif
if  down
  if crit
    if pq
      adf p Y --ct --gls --test-down=AIC --perron-qu
      scalar tau = $test
    else
      adf p Y --ct --gls --test-down=AIC
      scalar tau = $test
    endif
  else
    if pq
      adf p Y --ct --gls --test-down=BIC --perron-qu
      scalar tau = $test
    else
      adf p Y --ct --gls --test-down=BIC
      scalar tau = $test
    endif
  endif
else
  adf p Y --ct --gls
  scalar tau = $test
endif
scalar test = allin_Cpval_tr(tau,$nobs)
matrix vv = zeros(1,4)
#scalar v1 = nsolveADF($nobs, 0.1)
v1 = nsolveADF($nobs, 0.1)
v2 = nsolveADF($nobs, 0.05)
v3 = nsolveADF($nobs, 0.025)
v4 = nsolveADF($nobs, 0.01)
printf &quot;  Interpolated\n&quot;
printf &quot;  critical values:%6.2f %7.2f %7.2f %7.2f\n&quot;,v1,v2,v3,v4
printf &quot;\n  Estimated p-value = %4.4f\n\n&quot;,test
matrix ret = {tau,test}
return ret
</code>
</gretl-function>
<gretl-function name="CVc" type="matrix" private="1">
 <params count="1">
  <param name="n" type="scalar"/>
 </params>
<code>matrix Q = { -1.105258003158007, -4.053344484443159, 2.85336361236462, -1.056453181769411; -1.929288964039759, -1.59593687445697, 0.9247374655905843, -0.5002066598419327; -2.156984291387941, -0.5770241853213853, 0.07254041407389747, -0.226453634204237; -2.367075631362532, 0.4424588839240222, -0.7817097811913036, 0.04500566615448559; -2.623442046052164, 1.808022994196736, -1.913503196036494, 0.3951094963188986; -2.582871241901641, 2.39115125284217, -2.446321435501794, 0.5813616508551759; -2.55052280211334, 2.754829941536706, -2.779551613586909, 0.6959445093166277; -2.352879991813527, 2.613164230302114, -2.700703155744948, 0.6964160714572184; -2.198748288110984, 2.518434611430606, -2.653468985613409, 0.7012290820029506; -1.744627477218004, 2.038666602349609, -2.316287475165335, 0.6495271996530617; -0.9722438664244272, 0.7329715008527546, -1.274634611128354, 0.4093260689375858; -0.3554892462905041, -0.420888623649136, -0.2279528936483537, 0.140000290177543; -0.3586388089832671, -0.2002938924681621, -0.1302982326189588, 0.08199550486705443; -0.3985611662173799, 1.040555144511097, -0.7757583554605111, 0.2021363044339179; 0.6320580729379242, 1.124097675360034, -0.8492705175846201, 0.2364987722285747 }
scalar z = (n&lt;$huge) ? 1 + 10/n : 1
matrix ret = (z .^ seq(0,3))
return Q * ret'
</code>
</gretl-function>
<gretl-function name="ADFCpvals" type="scalar" private="1">
 <params count="2">
  <param name="T" type="scalar"/>
  <param name="tau" type="scalar"/>
 </params>
<code>matrix gp = {0.001,0.0025,0.005,0.01,0.025,0.05,0.075,0.1,0.125,0.2,0.3,0.4,0.5,0.7,0.9}
matrix z = CVc(T)
matrix b = mols(invcdf(z,gp)', z .^ seq(0,3))
matrix tt = (tau .^ seq(0,3))
return cnorm(tt*b)
</code>
</gretl-function>
<gretl-function name="nsolveADFC" type="scalar" private="1">
 <params count="2">
  <param name="n" type="scalar"/>
  <param name="p" type="scalar"/>
 </params>
<code>set  fdjac_quality 2
if n&lt;=200
  matrix xm = -2
else
  matrix xm = -1
endif
string equa2 = &quot;&quot;
scalar fun = 0
#print fun
scalar der = 0
#print der
scalar x = xm
scalar xplus1 = 0
matrix xplus1m = 0
scalar delta = $huge
loop while delta &gt; 10^-14 --quiet
  equa2 = &quot;allin_Cpval(xm,n)-p&quot;
  fun = @equa2
  der = fdjac(xm,equa2)
  xplus1 = x -fun/der
  delta = abs(xplus1 - x)
  #print delta
  x = xplus1
  xm = x
endloop
return x
</code>
</gretl-function>
<gretl-function name="ADFGLSReg3" type="matrix" private="1">
 <params count="5">
  <param name="Y" type="series"/>
  <param name="p" type="scalar" default="-1"/>
  <param name="down" type="bool" default="1"/>
  <param name="crit" type="scalar" default="1"/>
  <param name="pq" type="bool" default="0"/>
 </params>
<code>if  p = -1
  p =  round(12*($nobs/100)^(1/4))
endif
if  down
  if crit
    if pq
      adf p Y --c --gls --test-down=AIC --perron-qu
      scalar tau = $test
    else
      adf p Y --c --gls --test-down=AIC
      scalar tau = $test
    endif
  else
    if pq
      adf p Y --c --gls --test-down=BIC --perron-qu
      scalar tau = $test
    else
      adf p Y --c --gls --test-down=BIC
      scalar tau = $test
    endif
  endif
else
  adf p Y --c --gls
  scalar tau = $test
endif
scalar test = allin_Cpval(tau,$nobs)
matrix vv = zeros(1,4)
#scalar v1 = nsolveADF($nobs, 0.1)
v1 = nsolveADFC($nobs, 0.1)
v2 = nsolveADFC($nobs, 0.05)
v3 = nsolveADFC($nobs, 0.025)
v4 = nsolveADFC($nobs, 0.01)
printf &quot;  Interpolated           10%%      5%%    2.5%%      1%%\n&quot;
printf &quot;  critical values:    %6.2f %7.2f %7.2f %7.2f\n&quot;,v1,v2,v3,v4
printf &quot;\n  Estimated p-value = %4.4f\n\n&quot;,test
matrix ret = {tau,test}
return ret
</code>
</gretl-function>
<gretl-function name="allin_Cpval" type="scalar" private="1">
 <params count="2">
  <param name="tau" type="scalar"/>
  <param name="T" type="int"/>
 </params>
<code>matrix theta = { -3.28453708, -21.3204557, 140.967704, -2109.36649 ; -3.01779011, -20.1180328, 157.88128, -2080.0782 ; -2.80102912, -19.5490516, 172.360854, -2059.78628 ; -2.56743507, -19.661989, 209.548925, -2369.50062 ; -2.22930959, -20.2062755, 257.1473, -2752.12017 ; -1.94350947, -21.1177948, 292.521454, -2974.96135 ; -1.75981609, -22.0082279, 321.095236, -3221.86542 ; -1.61973492, -22.8793274, 343.957687, -3393.66988 ; -1.50472325, -23.6342389, 360.61974, -3500.25451 ; -1.23718632, -26.0227429, 416.619417, -3960.26385 ; -0.966981216, -28.9525593, 469.467196, -4218.71432 ; -0.735060808, -32.1393597, 517.354387, -4240.65214 ; -0.50408985, -36.7088334, 603.061403, -4525.43709 ; 0.0552680084, -47.3985942, 776.805837, -4977.31288 ; 0.894597581, -51.8722834, 630.361061, -1606.26434 }
matrix P = {0.001,0.0025,0.005,0.01,0.025,0.05,0.075,0.1,0.125,0.2,0.3,0.4,0.5,0.7,0.9}
# compute all critical values for T
matrix C = theta * ((1/T) .^ seq(0,3))'
# get a suitable subset of points
scalar imin = iminc(abs(C - tau))
if imin &gt; 2 &amp;&amp; imin &lt; 14
  C = C[imin-2:imin+2]
  P = P[imin-2:imin+2]
elif imin &lt;= 2
  C = C[1:5]
  P = P[1:5]
else
  C = C[11:15]
  P = P[11:15]
endif
matrix b = mols(invcdf(z, P)', C .^ seq(0, 3))
matrix tt = tau .^ seq(0, 3)
return cnorm(tt*b)
</code>
</gretl-function>
<gretl-function name="allin_Cpval_tr" type="scalar" private="1">
 <params count="2">
  <param name="tau" type="scalar"/>
  <param name="T" type="int"/>
 </params>
<code>matrix theta = { -0.5675257939456984, -5.889280379805676, 3.791897637683687, -1.395250924578223; -0.7037682207649322, -4.967651554577271, 2.891910998706485, -1.033852370783428; -0.4728927576100489, -5.069711938088196, 2.869226357922746, -0.9420048472618128; -0.5409761765750492, -4.444143653541261, 2.300863996490794, -0.7218170188308294; -0.3899521321564801, -4.086566247066906, 1.894215769575821, -0.5211480159115833; -0.122032417461725, -4.084175732484658, 1.776325390009225, -0.4180239353096852; 0.3197592551560696, -4.704115616953786, 2.176054883586462, -0.4757762199415086; 0.5949495885381851, -5.021709088503859, 2.355687061653307, -0.4891157657417851; 0.8591588024169166, -5.365261706472793, 2.563718892184643, -0.516031636189927; 1.620554515377739, -6.495377273934912, 3.293856852759689, -0.6426215721604338; 2.695805404549369, -8.334444325542586, 4.552112346749025, -0.902747365259428; 3.668254528863699, -10.0282213376875, 5.712352583363974, -1.148013597927836; 4.730725699346213, -11.97877310963016, 7.077339468661078, -1.449622260871141; 7.283558462232163, -16.87012723557434, 10.55531154583769, -2.24219695699242; 11.06805194496295, -24.24036722859674, 15.85130131381983, -3.472015174306859}
matrix P = {0.001,0.0025,0.005,0.01,0.025,0.05,0.075,0.1,0.125,0.2,0.3,0.4,0.5,0.7,0.9}
# compute all critical values for T
scalar z = (T&lt;$huge) ? 1 + 10/T : 1
matrix C = theta * (z .^ seq(0,3))'
# get a suitable subset of points
scalar imin = iminc(abs(C - tau))
if imin &gt; 2 &amp;&amp; imin &lt; 14
  C = C[imin-2:imin+2]
  P = P[imin-2:imin+2]
elif imin &lt;= 2
  C = C[1:5]
  P = P[1:5]
else
  C = C[11:15]
  P = P[11:15]
endif
matrix b = mols(invcdf(z, P)', C .^ seq(0, 3))
matrix tt = tau .^ seq(0, 3)
return cnorm(tt*b)
</code>
</gretl-function>
<sample-script>
include ADFGLSTest.gfn
open denmark.gdt
ADFGLSTest(LRM)
ADFGLSTest(LRM,1)
</sample-script>
</gretl-function-package>
</gretl-functions>

