<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="vecmI2" ID="1353173492" needs-time-series-data="true" minver="1.8.4">
<author>Andreas Noack Jensen</author>
<version>0.1</version>
<date>2012-02-11</date>
<description>VECM for I(2) analysis</description>
<help>
Tools for analysing I(2) data
</help>
<gretl-function name="cointI2" type="void">
 <params count="3">
  <param name="k" type="int" min="2" default="NA" const="true">
<description>Lag order</description>
  </param>
  <param name="endogenous" type="list" const="true">
<description>Endogenous variables</description>
  </param>
  <param name="exogenous" type="list" optional="true" const="true">
<description>Exogenous variables</description>
  </param>
 </params>
<code>mX = {endogenous}
lDexo = diff(exogenous)
mU = {exogenous}
ip = cols(mX)
iT = rows(mX) - k
ip1 = ip - 1
fit = vecmI2(ip, 0, k, endogenous, exogenous)
llA = fit[&quot;ll&quot;]
mResult = zeros(ip, ip + 1)
loop i = 0..ip1 --quiet
  ipi = ip - i
  loop j = 0..ipi --quiet
    fit = vecmI2(i, j, k, endogenous, exogenous)
    ll0 = fit[&quot;ll&quot;]
    mResult[i + 1, j + i + 1] = 2 * (llA - ll0)
  endloop
endloop
print mResult
</code>
</gretl-function>
<gretl-function name="vecmI2" type="bundle">
 <params count="5">
  <param name="r" type="int" min="0" const="true">
<description>Rank of Pi</description>
  </param>
  <param name="s" type="int" min="0" const="true">
<description>Rank of alphaOrth*Gamma*betaOrth</description>
  </param>
  <param name="k" type="int" min="2" const="true">
<description>Lag order</description>
  </param>
  <param name="endogenous" type="list" const="true">
<description>Endogenous variables</description>
  </param>
  <param name="exogenous" type="list" optional="true" const="true">
<description>Exogenous variables</description>
  </param>
 </params>
<code>bundle ans
ip = nelem(endogenous)
set svd on
#    if (ip - r - s &lt; 0.5)
#        funcerr &quot;Model is I(1). Use coint2&quot;
#    endif
lD_endo = diff(endogenous)
lD_exo = diff(exogenous)
lDD_endo = diff(lD_endo)
lDD_exo = diff(lD_exo)
if k &gt; 2.5
  lLDD_endo = lags(k - 2, lDD_endo)
  if (nelem(exogenous) &gt; 0.5)
    lLDD_exo = lags(k - 2, lDD_exo)
  else
    list lLDD_exo = {}
  endif
endif
smpl --no-missing
mZ0 = {lDD_endo}
list lAll = endogenous exogenous
list lDall = lD_endo lD_exo
mZ1 = {lags(1, lDall)}
mZ2 = {lags(1, lAll)}
mZ3 = {lDD_exo}
iT = rows(mZ0)
if k &gt; 2.5
  mZ3 = mZ3~{lLDD_endo}~{lLDD_exo}
  mR0 = {}
  mR1 = {}
  mR2 = {}
  mols(mZ0, mZ3, &amp;mR0)
  mols(mZ1, mZ3, &amp;mR1)
  mols(mZ2, mZ3, &amp;mR2)
else
  mZ3 = {}
  mR0 = mZ0
  mR1 = mZ1
  mR2 = mZ2
endif
if (r + s &lt; 0.5)
  ll = -0.5 * iT * ldet(mR0'mR0 / iT)
  mTau = {}
  mRho = {}
else
  mTau = {}
  tmp1 = RRR(mR0, mR1, r + s, &amp;mTau)
  mRa = {}
  if r &lt; 0.5
    mols(mR0, mR1 * mTau, &amp;mRa)
    ll = -0.5 * iT * ldet(mRa'mRa / iT)
  elif r &gt; ip - 0.5
    mTau = mols(mR0, mR1~mR2, &amp;mRa)
    mRho = I(cols(mTau))
    mAlpha = mRho
    ll = -0.5 * iT * ldet(mRa'mRa / iT)
  else
    mRb = {}
    mVecs = {}
    mRes1 = {}
    mRes2 = {}
    ll = -1e9
    loop i = 1..5000 --quiet
      mols(mR0, mR2 * mTau ~ mR1, &amp;mRa)
      mols(mR0, mR1 * mTau, &amp;mRb)
      mRbRb = mRb'mRb / iT
      mVals = eigsolve(mRa'mRa / iT, mRbRb, &amp;mVecs)
      mAlphaOrth = mVecs[, seq(ip, r + 1)]
      mAlpha = mRbRb * mVecs[, seq(r, 1)]
      mCoef1 = mols(mR0 * mAlpha / (mAlpha'mAlpha), mR0 * mAlphaOrth ~ mR2 * mTau ~ mR1, &amp;mRes1)
      mSmallOmega = mCoef1[1:ip - r,]
      mRho = mCoef1[ip - r + 1:ip + s,]
      mPsi = mCoef1[ip + s + 1:,]
      matrix mOmega1 = mRes1'mRes1 / iT
      mKappa = mols(mR0 * mAlphaOrth, mR1 * mTau, &amp;mRes2)
      mOmega2 = mRes2'mRes2 / iT
      matrix mA = mRho / mOmega1 * mRho'
      mols(mR2, mR0 * mAlphaOrth ~ mR1, &amp;mRa)
      matrix mB = mRa'mRa / iT
      matrix mC = mKappa / mOmega2 * mKappa'
      matrix mD = mR1'mR1 / iT
      mols(mR0, mR0 * mAlphaOrth ~ mR1, &amp;mRb)
      matrix mE = mRho / mOmega1 / (mAlpha'mAlpha) * mAlpha' * mRb'mRa / iT + mKappa / mOmega2 * mAlphaOrth' * mR0'mR1 / iT
      mTau = mshape((mB ** mA + mD ** mC) \ vec(mE), cols(mTau), rows(mTau))'
      mAlphaOrthBar = mAlphaOrth / (mAlphaOrth'mAlphaOrth)
      mOmega = mAlphaOrthBar * mOmega2 * mAlphaOrthBar' + mAlphaOrthBar * mOmega2 * mSmallOmega * mAlpha' + mAlpha * mSmallOmega'mOmega2 * mAlphaOrthBar'+mAlpha * (mOmega1 + mSmallOmega'mOmega2 * mSmallOmega) * mAlpha'
      #mols(mR0, mR2 * mTau * mRho + mR1 * mPsi ~ mR1 * mTau * mKappa, &amp;mRa)
      ll0 = ll
      ll = -0.5 * iT * ldet(mOmega)
      if (abs((ll - ll0) / ll0) &lt; 1e-9)
        break
      endif
    endloop
    mRa = mR0 - mR2 * mTau * mRho * mAlpha' - mR1 * (mPsi * mAlpha' + mTau * mKappa * ((mAlphaOrth'mOmega * mAlphaOrth) \ (mAlphaOrth'mOmega)))
    #mR1 * (mPsi * mAlpha' + mTau * mKappa' * (mAlphaOrth'mOmega * mAlphaOrth) \ (mAlphaOrth'mOmega)) -
  endif
endif
if r &gt; 0.5
  mBeta = mTau * mRho
else
  mAlpha = {}
  mBeta = {}
endif
ans[&quot;ll&quot;] = ll - iT * ip * 0.5 * (log(2 * pi) + 1)
ans[&quot;alpha&quot;] = mAlpha
ans[&quot;beta&quot;] = mBeta
ans[&quot;tau&quot;] = mTau
return ans
</code>
</gretl-function>
<gretl-function name="RRR" type="matrix">
 <params count="4">
  <param name="Y" type="matrix"/>
  <param name="X" type="matrix"/>
  <param name="r" type="int" default="NA"/>
  <param name="V" type="matrixref" optional="true"/>
 </params>
<code>mUX = {}
mVX = {}
mUY = {}
mUZ = {}
mSX = svd(X, &amp;mUX, &amp;mVX)
mSY = svd(Y, &amp;mUY)
mSZ = svd(mUX'mUY, &amp;mUZ)
if !isnull(V)
  mS1 = zeros(1, cols(X))
  index = cum((mSX .&gt; 10e-9 * maxr(maxc(X)))')
  mS1[1, index] = 1 ./ mSX[1, index]
  mVec = sqrt(rows(X)) * (mVX' .* mS1) * mUZ
  V = mVec[,1:r]
endif
return mSZ[1:r]'.^2
</code>
</gretl-function>
<sample-script>
include vecmI2.gfn
open denmark
genr time
list yvars = LRM LRY IBO IDE
tmp = vecmI2(1, 2, 3, yvars, time)
cointI2(3, yvars, time)
print tmp
</sample-script>
</gretl-function-package>
</gretl-functions>

