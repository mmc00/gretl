<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="coint2finite" ID="1369744026" needs-time-series-data="true" minver="1.9.12">
<author email="svetosch@gmx.net">Andreas Noack Jensen and Sven Schreiber</author>
<version>1.1</version>
<date>2014-06-02</date>
<description>Small-sample additions to coint2</description>
<label>Finite-sample Johansen test</label>
<menu-attachment>MAINWIN/Model/TSModels/CointMenu</menu-attachment>
<help>
Package for supplying Bartlett corrected trace test statistics and bootstrapped p-values. Please send comments or questions to the gretl mailing list.

Andreas did most of the work, Sven finished the function interface and resolved some gretl-related details.

Distributed under the same license as the gretl program itself (GPL).  

-------------

Prints output and returns a bundle with:

(1) &quot;mresults&quot;:	main result matrix, 
  tested ranks 0..n-1 in rows;
  1st col: rank under H0,
  2nd col: standard trace stat,
  3rd col: standard (asympt.) p-value,
  4th col: corrected p-value.
and only in case of Bartlett:
  5th col: corrected trace stat
(2) &quot;strT1&quot;: obs string, sample start
(3) &quot;strT2&quot;: obs string, sample end
(4) &quot;dtrm&quot;: integer-coded deterministic spec
(5) &quot;nlags&quot;: integer num. of lags of the VAR
(6) &quot;warnings&quot;: string with misc. messages
and only in case of Bootstrap:
(7) &quot;breps&quot;: integer num. of bootstrap replications

Arguments (all except the first have default values and can be omitted in principle):

(1) list: &quot;List of endogenous variables&quot; 
(2) int: &quot;Number of lags in the (levels) VAR&quot; (default: 2)
(3) int: &quot;Deterministics&quot; {&quot;No const&quot;, &quot;Restr. const&quot;, &quot;Restr. trend&quot;} (default: 2)
(4) int: &quot;Number of bootstrap replications (zero for Bartlett correction)&quot; (default: 0)
(5) list: &quot;List of unrestricted variables&quot; (default: null)
(6) list: &quot;List of restricted exogenous variables&quot; (default: null)

-----------
These functions are implementations of

&quot;A Small Sample Correction for the Test of Cointegrating Rank in the Vector Autoregressive Model&quot; by Soren Johansen, Econometrica 2002

and

&quot;Bootstrap Determination of the Co-Integration Rank in Vector Autoregressive Models&quot;, by Guiseppe Cavaliere, Anders Rahbek and Robert Taylor, Econometrica 2012.

(Currently the wild bootstrap is used in this package.)

The p-values values of the trace test statistic are gamma distribution approximations from

&quot;Approximations to the Asymptotic Distributions of Cointegration Tests&quot;, by Jurgen Doornik, Journal of Economic Surveys 1998

-------------

Change log:
1.1 (June 2014): fix help-text typo and menu location
</help>
<gretl-function name="GUI_coint2finite_print" type="void" pkg-role="bundle-print">
 <params count="1">
  <param name="btrans" type="bundleref"/>
 </params>
<code>matrix m = btrans.mresults
if cols(m)==4	# This is the bootstrap case (4 cols)
  print &quot;CI test with bootstrapped p-values&quot;
  printf &quot;(%d replications)\n&quot;, btrans.breps
  printf &quot;Rank     trace  asy-p-val  boot-pval\n&quot;
  loop i = 1..rows(m) --quiet
    printf &quot;%4d %9.3f   %8.3f   %8.3f\n&quot;, m[i,1], m[i,2], m[i,3], m[i,4]
  endloop
elif cols(m)==5	# the Bartlett case
  print &quot;Bartlett-corrected CI test&quot;
  printf &quot;Rank     trace   asy-pval  bart-pval  bart-tr\n&quot;
  loop i = 1..rows(m) --quiet
    printf &quot;%4d  %8.3f %10.3f %10.3f %8.3f\n&quot;, m[i,1], m[i,2], m[i,3], m[i,4], m[i,5]
  endloop
else
  funcerr &quot;shouldn't happen&quot;
endif
# print warnings
printf &quot;%s\n&quot;, btrans.warnings
# print original arguments
printf &quot;Effective sample: %s-%s\n&quot;, btrans.strT1, btrans.strT2
printf &quot;Lags (levels) in VAR: %d\n&quot;, btrans.nlags
printf &quot;Deterministic spec (1=nc; 2=rc; 3=crt): %d\n&quot;, btrans.dtrm
print &quot;Endogenous variables:&quot;
printf &quot;%s\n&quot;, btrans.ynames
if strlen(btrans.xnames)
  print &quot;Unrestricted variables:&quot;
  printf &quot;%s\n&quot;, btrans.xnames
endif
if strlen(btrans.rxnames)
  print &quot;Restricted variables:&quot;
  printf &quot;%s\n&quot;, btrans.rxnames
endif
</code>
</gretl-function>
<gretl-function name="coint2finite" type="bundle" pkg-role="gui-main">
 <params count="6">
  <param name="ylist" type="list" const="true">
<description>List of endogenous variables</description>
  </param>
  <param name="nlags" type="int" min="1" default="2">
<description>Number of lags in the (levels) VAR</description>
  </param>
  <param name="dtrm" type="int" min="1" max="3" default="2">
<description>Deterministics</description>
<labels count="3">
"No const" "Restr. const" "Restr. trend" </labels>
  </param>
  <param name="breps" type="int" min="0" default="0">
<description>Number of bootstrap replications (zero for Bartlett correction)</description>
  </param>
  <param name="xlist" type="list" optional="true" const="true">
<description>List of unrestricted variables</description>
  </param>
  <param name="rxlist" type="list" optional="true" const="true">
<description>List of restricted exogenous variables</description>
  </param>
 </params>
<code># some input/error checking
roughcheck = nelem(ylist)*nlags
if roughcheck &gt;= $nobs-nlags
  funcerr &quot;Not enough observations&quot;
endif
if breps	# do the bootstrap
  bundle b = coint2boot(ylist,nlags,dtrm,breps,xlist,rxlist)
  b.breps = breps
  setnote(b, &quot;breps&quot;, &quot;Number of bootstrap replications&quot;)
else	# do the Bartlett correction
  bundle b = coint2bartlett(ylist,nlags,dtrm,xlist,rxlist)
endif
setnote(b, &quot;mresults&quot;, &quot;Main result matrix&quot;)
# add further stuff for printing etc.
strT1 = obslabel($t1)
strT2 = obslabel($t2)
b.strT1 = strT1		# string
setnote(b, &quot;strT1&quot;, &quot;Starting observation&quot;)
b.strT2 = strT2		# string
setnote(b, &quot;strT2&quot;, &quot;Last observation&quot;)
b.ynames = varname(ylist)		# string
setnote(b, &quot;ynames&quot;, &quot;Endogenous variables (names)&quot;)
b.xnames = varname(xlist)		# string
setnote(b, &quot;xnames&quot;, &quot;Unrestricted exog. variables (names)&quot;)
b.rxnames = varname(rxlist)	# string
setnote(b, &quot;rxnames&quot;, &quot;Restricted exog. variables (names)&quot;)
b.nlags = nlags		# int
setnote(b, &quot;nlags&quot;, &quot;Number of lags (levels) in VAR&quot;)
b.dtrm = dtrm		# int
setnote(b, &quot;dtrm&quot;, &quot;Integer-coded deterministic spec&quot;)
GUI_coint2finite_print(&amp;b)
return b
</code>
</gretl-function>
<gretl-function name="bartlett_g" type="scalar" private="1">
 <params count="2">
  <param name="ipr" type="scalar"/>
  <param name="dtrm" type="int" min="1" max="3" default="2">
<description>Deterministics</description>
<labels count="3">
"nc" "rc" "crt" </labels>
  </param>
 </params>
<code>#    string type)
if dtrm==1 #	&quot;nc&quot;
  g0 = -0.513
  g1 = 0.066
  g2 = -0.008
  g3 = -0.105
elif dtrm==2	# &quot;rc&quot;
  g0 = -0.513
  g1 = 0.299
  g2 = -0.193
  g3 = 0.082
elif dtrm==3	# &quot;crt&quot;
  g0 = -1.508
  g1 = 1.724
  g2 = -1.200
  g3 = 0.362
endif
return g0 + g1/ipr + g2/ipr^2 + g3/ipr^3
</code>
</gretl-function>
<gretl-function name="bartlett_a" type="scalar" private="1">
 <params count="3">
  <param name="T" type="scalar"/>
  <param name="ipr" type="scalar"/>
  <param name="dtrm" type="int" min="1" max="3" default="2">
<description>Deterministics</description>
<labels count="3">
"nc" "rc" "crt" </labels>
  </param>
 </params>
<code>#                          string type)
if dtrm==1 # &quot;nc&quot;
  a1 = 0.549
  a2 = 0.552
  a3 = 6.090
  b = -0.372
elif dtrm==2 # &quot;rc&quot;
  a1 = 0.541
  a2 = 0.539
  a3 = 9.956
  b = -0.285
elif dtrm==3 # &quot;crt&quot;
  a1 = 0.523
  a2 = 0.569
  a3 = 15.712
  b = -0.238
endif
return exp(a1*ipr/T+a2*(ipr/T)^2+a3*ipr^2/T^3+b/T)
</code>
</gretl-function>
<gretl-function name="bartlett_h" type="scalar" private="1">
 <params count="2">
  <param name="ipr" type="scalar"/>
  <param name="dtrm" type="int" min="1" max="3" default="2">
<description>Deterministics</description>
<labels count="3">
"nc" "rc" "crt" </labels>
  </param>
 </params>
<code>#                          string type)
if dtrm==1	# &quot;nc&quot;
  h1 = 0.016
  h2 = 0.121
  h3 = -0.050
elif dtrm==2	# &quot;rc&quot;
  h1 = -0.052
  h2 = 0.297
  h3 = -0.112
elif dtrm==3	# &quot;crt&quot;
  h1 = -0.053
  h2 = 3.297
  h3 = -1.492
endif
return h1/ipr + h2/ipr^2 + h3/ipr^3
</code>
</gretl-function>
<gretl-function name="gammapartracetest" type="matrix" private="1">
 <params count="2">
  <param name="dtrm" type="int" min="1" max="3" default="2">
<description>Deterministics</description>
<labels count="3">
"nc" "rc" "crt" </labels>
  </param>
  <param name="ipr" type="scalar"/>
 </params>
<code># former arg: string stype
if dtrm==1	# &quot;nc&quot;
  fmean = -ipr + 0.07 + 0.07*(ipr==1)
  fvar = -0.33*ipr - 0.55
elif dtrm==2	# &quot;rc&quot;
  fmean = 2.01*ipr + 0.06*(ipr==1) + 0.05*(ipr==2)
  fvar = 3.6*ipr + 0.75 - 0.40*(ipr==1) - 0.30*(ipr==2)
elif dtrm==3	# &quot;crt&quot;
  fmean = 4.05*ipr + 0.5 - 0.23*(ipr==1) - 0.07*(ipr==2)
  fvar = 5.7*ipr + 3.2 - 1.3*(ipr==1) - 0.5*(ipr==2)
endif
fmean += 2*ipr^2
fvar += 3*ipr^2
return {fmean^2/fvar, fvar/fmean}
</code>
</gretl-function>
<gretl-function name="coint2bartlett" type="bundle" private="1">
 <params count="5">
  <param name="ylist" type="list" const="true">
<description>List of endogenous variables</description>
  </param>
  <param name="nlags" type="int" min="0" default="2">
<description>Number of lags in the (levels) VAR</description>
  </param>
  <param name="dtrm" type="int" min="1" max="3" default="2">
<description>Deterministics</description>
<labels count="3">
"No const" "Restr. const" "Restr. trend" </labels>
  </param>
  <param name="xlist" type="list" optional="true" const="true">
<description>List of unrestricted variables</description>
  </param>
  <param name="rxlist" type="list" optional="true" const="true">
<description>List of restricted exogenous variables</description>
  </param>
 </params>
<code>string warnings = &quot;&quot;		# to be --possibly-- filled later
list diffy = diff(ylist) 	# needs to be created before the sample is changed
smpl +nlags +0			# to make sure only in-sample data is used
iT = $nobs
ip = nelem(ylist)
if nelem(xlist) &gt; 0
  string s1 = &quot;Warning: Method only valid for restricted determistic terms.&quot;
  string s2 = &quot;(But we proceed anyway...)&quot;
  warnings = sprintf(&quot;\n%s\n%s\n&quot;, s1, s2)
endif
km1 = int(nlags - 1)
ansmat = zeros(ip, 4)
if dtrm==1
  vecm nlags ip ylist; xlist; rxlist --nc --silent
elif dtrm==2
  vecm nlags ip ylist; xlist; rxlist --rc --silent
elif dtrm==3
  vecm nlags ip ylist; xlist; rxlist --crt --silent
endif
llA = $lnl
loop i=0..(ip-1) --quiet	# all ranks under H0
  if i==0
    if nlags == 1
      # Regress the diffs on just the (unrestr.) exog. terms (if any)
      matrix tmpres = {}
      matrix mdiffy = {diffy}
      if nelem(xlist) == 0
        mols(mdiffy, ones(rows(mdiffy), dtrm==3), &amp;tmpres)	# dtrm==3: crt
      else
        mols({diffy}, ones(rows(mdiffy), dtrm==3)~{xlist}[2:], &amp;tmpres)
      endif
      mOmega = tmpres'tmpres/rows(mdiffy)
      c1 = 0.0
      c2 = 0.0
      c3 = 0.0
      ll0 = -0.5*rows(mdiffy)*(ip*log(2*$pi) + ldet(mOmega) + ip)
    else	# more than 1 lag (but still rank=0)
      if dtrm==3	# crt, i.e. need a constant in diffs
        var km1 diffy; xlist --silent
      else
        var km1 diffy; xlist --nc --silent
      endif
      mCoeffs = $coeff
      mGamma = mCoeffs[vec(mshape( seq((dtrm==3)+1, ip*(nlags-1)+(dtrm==3)), nlags-1,ip)'),]'
      P = mGamma | (I(ip*(nlags-2)) ~ zeros(ip*(nlags-2),ip))
      Q = I(ip) | zeros(ip*(nlags-2),ip)
      mOmega = $sigma
      PiQ = (I(rows(P))-P)\Q
      PQOQP = PiQ*mOmega*PiQ'
      mSigma = mshape((I(rows(P)^2)-P**P)\vec(Q*mOmega*Q'), i+ip*(nlags-1), i+ip*(nlags-1))
      Vpsi = PQOQP/mSigma
      c1 = tr(Vpsi)
      c2 = tr(I(rows(P))-PQOQP/mSigma)
      c3 = tr((((I(rows(P))-P)*Vpsi)**P)/(I(rows(P)^2)-P**P))  + tr((P/(I(rows(P))+P))*Vpsi)
      ll0 = $lnl
    endif # lag cases
  else 	# rank &gt; 0
    if dtrm==1
      vecm nlags i ylist; xlist; rxlist --nc --silent
    elif dtrm==2
      vecm nlags i ylist; xlist; rxlist --rc --silent
    elif dtrm==3
      vecm nlags i ylist; xlist; rxlist --crt --silent
    endif
    mCoeffs = $coeff
    malpha = $jalpha
    tmpbeta = $jbeta
    mbeta = tmpbeta[1:ip,]
    if nlags == 1
      matrix P = I(i)+mbeta'malpha
      Q = mbeta'
    else
      mGamma = mCoeffs[vec(mshape( seq((dtrm==3)+1, ip*(nlags-1)+(dtrm==3)), nlags-1, ip)'),]'
      P = ((I(i)+mbeta'malpha) ~ (mbeta'mGamma)) | (malpha ~ mGamma) | (zeros(ip*(nlags-2),i) ~ I(ip*(nlags-2)) ~ zeros(ip*(nlags-2),ip))
      Q = (mbeta') | I(ip) | zeros(ip*(nlags-2),ip)
    endif
    mOmega = $sigma
    PiQ = (I(rows(P))-P)\Q
    matrix PQOQP = PiQ*mOmega*PiQ'
    matrix PQOalphaQP = PiQ*(malpha/(malpha'(mOmega\malpha)))*malpha'*PiQ'
    matrix mSigma = mshape((I(rows(P)^2)-P**P)\vec(Q*mOmega*Q'), i + ip*(nlags-1), i + ip*(nlags-1))
    matrix Vpsi = (PQOQP - PQOalphaQP) / mSigma
    c1 = tr(Vpsi)
    c2 = tr(I(rows(P))-PQOQP/mSigma)
    c3 = tr((((I(rows(P))-P)*Vpsi)**P)/(I(rows(P)^2)-P**P)) + tr((P/(I(rows(P))+P))*Vpsi)
    ll0 = $lnl
  endif	# H0 rank 0 or not
  # standard trace stat
  ansmat[i+1, 1] = 2 * (llA - ll0)
  # standard p-value
  tmppars = gammapartracetest(dtrm, ip-i)
  ansmat[i+1,2] = pvalue(G,tmppars[1],tmppars[2],ansmat[i+1,1])
  # Bartlett trace stat
  # (needs to be calc'ed first, but we put the result at the end,
  # because it's not there in the bootstrap case)
  b_theta = c1*(1+bartlett_h(ip-i,dtrm)) + ((ip-i)*c2 + 2*(c3 + (dtrm==3)*c1)) * bartlett_g(ip-i,dtrm) / (ip-i)^2
  bartlett_factor = bartlett_a(iT,ip-i,dtrm)*(1+b_theta/iT)
  ansmat[i+1,4] = ansmat[i+1,1] / bartlett_factor
  # Bartlett p-value (in penultimate position in output matrix)
  tmpmax = max(0~ansmat[i+1,4])
  ansmat[i+1,3] = pvalue(G,tmppars[1],tmppars[2],tmpmax)
  # tmp = bartlett_a(iT,ip-i,dtrm)	# seems redundant
endloop
matrix mout = transp(seq(0,ip-1)) ~ ansmat
# build return bundle
bundle bout
bout.mresults = mout	# main result matrix
bout.warnings = warnings	# string
return bout
</code>
</gretl-function>
<gretl-function name="coint2boot" type="bundle" private="1">
 <params count="6">
  <param name="ylist" type="list">
<description>List of endogenous variables</description>
  </param>
  <param name="nlags" type="int" min="0" default="2">
<description>Number of lags in the (levels) VAR</description>
  </param>
  <param name="dtrm" type="int" min="1" max="3" default="2">
<description>Deterministics</description>
<labels count="3">
"No const" "Restr. const" "Restr. trend" </labels>
  </param>
  <param name="breps" type="int" min="0" default="500">
<description>Number of bootstrap replications</description>
  </param>
  <param name="xlist" type="list" optional="true">
<description>List of unrestricted variables</description>
  </param>
  <param name="rxlist" type="list" optional="true">
<description>List of restricted exogenous variables</description>
  </param>
 </params>
<code>string warnings = &quot;&quot;		# to be filled later, if necessary
list diffy = diff(ylist) 	# needs to be created before the sample is changed
smpl +nlags +0			# to make sure only in-sample data is used
ip = nelem(ylist)
# iT = $t2 - $t1 - nlags + 1	# was wrong in general
if nelem(xlist) &gt; 0
  string s1 = &quot;Warning: Method only valid for restricted determistic terms.&quot;
  string s2 = &quot;(But we proceed anyway...)&quot;
  warnings = sprintf(&quot;\n%s\n%s\n&quot;, s1, s2)
endif
if dtrm==1
  coint2 nlags ylist; xlist; rxlist --nc --silent --asy
  pvals = $pvalue
  vecm nlags ip ylist; xlist; rxlist --nc --silent
elif dtrm==2
  coint2 nlags ylist; xlist; rxlist --rc --silent --asy
  pvals = $pvalue
  vecm nlags ip ylist; xlist; rxlist --rc --silent
elif dtrm==3
  coint2 nlags ylist; xlist; rxlist --crt --silent
  pvals = $pvalue
  vecm nlags ip ylist; xlist; rxlist --crt --silent
endif
llA = $lnl
matrix ans = zeros(ip, 4)
loop i = 0..ip-1 --quiet	# over all H0 ranks
  if i &gt; 0
    if dtrm==1
      vecm nlags i ylist; xlist; rxlist --nc --silent
    elif dtrm==2
      vecm nlags i ylist; xlist; rxlist --rc --silent
    elif dtrm==3
      vecm nlags i ylist; xlist; rxlist --crt  --silent
    endif
    matrix coefs = $compan
    ll0 = $lnl
    matrix resids = $uhat
  else	# rank 0
    if nlags == 1
      matrix resids = {}
      matrix mdiffy = {diffy}
      if nelem(xlist) == 0
        mols(mdiffy, ones(rows(mdiffy),dtrm==3), &amp;resids)
      else
        mols(mdiffy, ones(rows(mdiffy),dtrm==3)~{xlist}[2:,], &amp;resids)
      endif
      ll0 = -0.5*rows(mdiffy)*(ip*log(2*$pi) + ldet(resids'resids/rows(mdiffy)) + ip)
      matrix coefs = I(ip)
    else
      km1 = int(nlags - 1)
      if dtrm != 3	# i.e. no const in diffs
        var km1 diffy; xlist --nc --silent
      else
        var km1 diffy; xlist --silent
      endif
      tmpcoefs = $compan
      coefs = ((tmpcoefs[1:ip,] ~ zeros(ip,ip)) - (-I(ip) ~ tmpcoefs[1:ip,])) | (I(ip*(nlags-1)) ~ zeros(ip*(nlags-1),ip))
      ll0 = $lnl
      matrix resids = $uhat
    endif
  endif	# whether or not rank is 0 or positive
  if maxc(abs(eigengen(coefs))) &gt; 1.000000001
    sprintf errstring &quot;Model with rank %d has explosive roots. Largest root is %.20f&quot;, i, maxc(abs(eigengen(coefs)))
    funcerr &quot;@errstring&quot;
  endif
  QrT = 2*(llA - ll0)
  Qboot = zeros(breps,1)
  loop j = 1..breps --quiet		# the simulation loop
    booterror = resids .* mshape(mnormal(rows(resids),1), rows(resids),ip)
    simdat = varsimul(coefs[1:ip,], booterror, zeros(nlags,ip))
    smpl -nlags +0	# to match the simdat dims and the workfile sample
    series tmp1 = simdat[, 1]
    list tmpl = tmp1
    string sname = &quot;tmp&quot;
    loop l = 2..ip --quiet
      series @sname$l = simdat[, l]
      list tmpl = tmpl @sname$l
    endloop
    smpl +nlags +0	# undo the temp. sample change
    vecm nlags ip tmpl; xlist; rxlist --crt --silent
    llAboot = $lnl
    if i &gt; 0
      if dtrm==1
        vecm nlags i tmpl; xlist; rxlist --nc --silent
      elif dtrm==2
        vecm nlags i tmpl; xlist; rxlist --rc --silent
      else
        vecm nlags i tmpl; xlist; rxlist --crt --silent
      endif
      ll0boot = $lnl
    else
      list difftmpl = diff(tmpl)
      if nlags == 1
        matrix tmpresids = {}
        matrix mdifftmpl = {difftmpl}
        localiT = rows(mdifftmpl)
        if nelem(xlist) == 0
          mols(mdifftmpl, ones(localiT,dtrm==3), &amp;tmpresids)
        else
          mols(mdifftmpl, ones(localiT,dtrm==3)~{xlist}[2:,], &amp;tmpresids)
        endif
        ll0boot = -0.5*localiT*(ip*log(2*pi) + ldet(tmpresids'tmpresids/localiT) + ip)
      else
        var km1 difftmpl; xlist --silent
        ll0boot = $lnl
      endif
    endif
    Qboot[j, ] = 2 * (llAboot - ll0boot)
  endloop	# simulation
  ans[i + 1, ] = i ~ 2*(llA-ll0) ~ pvals[i + 1,1] ~ meanc(Qboot .&gt; QrT)
endloop # all ranks
# build the output bundle
bundle bout
bout.warnings = warnings	# string
bout.mresults = ans		# matrix
return bout
</code>
</gretl-function>
<sample-script>
include coint2finite.gfn
open australia

list endo = ius2 iau2

# Bartlett:
coint2finite(endo, 2, 3, 0, null, null)
# Bootstrap:
coint2finite(endo, 2, 3, 500, null, null)

diff e2
lags e2 d_e2
list exo = d_e2 d_e2_1
list rexo = e2_1

coint2finite(endo, 2, 3, 0, exo, rexo)
coint2finite(endo, 2, 3, 500, exo, rexo)
</sample-script>
</gretl-function-package>
</gretl-functions>

