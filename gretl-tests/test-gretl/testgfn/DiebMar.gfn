<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="DiebMar" ID="1438687207" needs-time-series-data="true" minver="1.9.0">
<author email="g.palomba@univpm.it">Giulio Palomba</author>
<version>1.0</version>
<date>2015-08-06</date>
<description>Diebold-Mariano test</description>
<label>Diebold-Mariano test</label>
<menu-attachment>MAINWIN/Model/TSModels</menu-attachment>
<help>
Diebold-Mariano (1995) test for predictive accuracy

Arguments:
1 - series --&gt; ACTUAL DATA SERIES: time series of interest 
2 - series --&gt; FORECAST 1 SERIES: 1st time series model
               available for forecasting
3 - series --&gt; FORECAST 2 SERIES: 2nd time series model 
               available for forecasting
4 - int    --&gt; LOSS FUNCTION: loss function type (see 
               Giacomini and White, 2006; Pesaran and
               Timmerman, 1992)
               0: the DM test is performed for all loss
                  functions; this is the default.
               1: U-shape loss function (symmetric)
               2: V-shape loss function (symmetric)
               3: Lin-Lin loss function (asymmetric) with 
                  order parameter given in Argument 5
               4: Linex loss function (asymmetric) with 
                  shape parameter given in Argument 6
               5: Direction-of-Change loss function    
                  (asymmetric)
               6: Forecast-direction loss function
                  (asymmetric)
5 - scalar --&gt; ORDER PARAMETER FOR LIN-LIN LOSS FUNCTION:
               this value must belong to [0,1] interval; 
               the default is 0.5 which assigns the same
 	       weight to positive and negative forecast 
	       errors
6 - scalar --&gt; SHAPE PARAMETER FOR LINEX LOSS FUNCTION:   
               this value must be different from zero.
               In general, with a shape parameter greater
               than 2, the Linex function could return 
               explosive values; the default is 1
7 - int    --&gt; BARTLETT WINDOWS SIZE: the default is the 
               greatest integer less than or equal to 
	       T^(1/3) 
8 - bool   --&gt; PREWHITENING: prewhitening correction for
               long-run variance robust to
               heteroskedasticity and autocorrelation 
               (see Andrews and Mohanan, 1992)

Output:
the package returns a matrix with 4 columns. 
The 1st column contains an integer id number which indicates the loss function:
id=1 - U-shape 
id=2 - V-shape 
id=3 - Lin-Lin with order parameter given in Argument 5  
id=4 - Linex with shape parameter given in Argument 6  
id=5 - Direction-of-Change
id=6 - Forecast-direction
id=7 - Maximum p-value Lin-Lin calculated via a grid     
       search for parameters in [0,1]  
id=8 - Minimum p-value Lin-Lin calculated via a grid 
       search for parameters in [0,1]  
id=9 - Maximum p-value Linex calculated via a grid search
       for parameters in [-M,M], where M=max{2,|p|} and |p|
       is the absolute value of the shape parameter 
       assigned by Argument 6 (it is reasonable to set 
       |p|&lt;2). 
id=10 - Minimum p-value Linex calculated via a grid search
        for parameters in [-M,M], where M=max{2,|p|} and |p|
        is the absolute value of the shape parameter 
        assigned by Argument 6 (it is reasonable to set 
	|p|&lt;2)
The 2nd column contains the test-statistic. If two forecast models have exactly the same predictive accuracy (the loss function returns a time series of zeros), the test-statistic is automatically zero. In this case, the following message appear: &quot;This test is not performed: both forecast series have exactly the same predictive accuracy.&quot; The same is for Linex loss function when some numerical problems are met in the exponential function. The message here is &quot;The test with Linex loss function is not performed: numerical results out of range for exp{%g*e}&quot;.

The 3rd column contains the p-values from a normal standard
distribution. If the test-statistic is zero, the corresponding p-value is obviously 1.

If id={3,4,7,8,9,10} the 4th column contains the parameters for the Lin-Lin and the Linex loss functions. Otherwise it returns zero.

The number of rows depend on the selection of the loss function:
-  1 row if Argument 4 is 1, 2, 5 or 6 (id={1,2,5,6})
-  3 rows if Argument 4 is 3 (id={3,7,8}) or 4 (id={4,9,10})
- 10 rows if Argument 4 is 0 (id={1,2,3,4,5,6,7,8,9,10})

--------------------------------------------------------------------------
Given 
y=actual time series, 
f1=forecast 1 time series,
f2=forecast 2 time series,
define the forecast error as
e1=f1-y
e2=f1-y.
The loss associated with the two forecasts is assumed to be a function of the forecast error and is denoted by L(e), with e={e1,e2}.
The function L(e) is a loss function, that is a function such that
(a) takes the value zero when no error is made;
(b) is never negative;
(c) is increasing in size as the errors become larger in
    magnitude.

The loss differential between the two forecasts is
d=L(e1)-L(e2);
the two forecasts have equal accuracy if and only
if the above loss differential has zero expectation for all t.

Loss Functions:
1. U-shape L(e)=e^2
2. V-shape L(e)=|e|
3. Lin-Lin L(e)=[p-(e&lt;0)]e (p is order the parameter)
4. Linex L(e)=p*exp(e)-1-p*e (p is the shape parameter)
5. Direction-of-Change L(e)=|1(y-y_1&gt;0)-1(f-y_1&gt;0)| where y_1 is y at time t-1 and 1(.) is the indicator function
6. Forecast-Direction L(e)=1(y*f&lt;0)


Bibliography

Andrews D.W.K. and Mohanan J.C. (1992), An improved heteroskedasticity and autocorrelation consistent covariance matrix estimation, Econometrica 59, pp.818-858

Diebold F.X. and Mariano, R. (1995), Comparing predictive
accuracy. Journal of Business Economic Statistics 13, pp. 253-265

Giacomini and White (2006), Tests of Conditional Predictive Ability, Econometrica 74(6), pp. 1545-1578

Pesaran H. and Timmermann A. (1992), A Simple Nonparametric Test of Predictive Performance, Journal of Business &amp; Economic Statistics, 10(4), pp. 461-465
</help>
<gretl-function name="DiebMar" type="matrix">
 <params count="8">
  <param name="y" type="series">
<description>actual data series</description>
  </param>
  <param name="f1" type="series">
<description>forecast 1 series</description>
  </param>
  <param name="f2" type="series">
<description>forecast 2 series</description>
  </param>
  <param name="loss" type="int" min="0" max="6" default="0">
<description>loss function</description>
<labels count="7">
"All" "U-shape" "V-shape" "Lin-Lin" "Linex" "Direction-of-change" "Change in sign" </labels>
  </param>
  <param name="LLorder" type="scalar" min="0" max="1" default="0.5">
<description>parameter for Lin-Lin loss function</description>
  </param>
  <param name="LXshape" type="scalar" default="1">
<description>parameter for Linex loss function</description>
  </param>
  <param name="m" type="int" min="-1" default="-1">
<description>Bartlett window size</description>
  </param>
  <param name="prewhit" type="bool" default="0">
<description>Prewhitening</description>
  </param>
 </params>
<code>print &quot;&quot;
print &quot;==================================================================&quot;
print &quot;Diebold-Mariano (DM) test for forecasting accuracy&quot;
matrix id=loss
matrix lambda=0
if loss==0
  series US=Ushape(y,f1,f2)
  series VS=Vshape(y,f1,f2)
  series LL=LinLin(y,f1,f2,LLorder)
  series LX=Linex(y,f1,f2,LXshape)
  series DC=Doc(y,f1,f2)
  series CS=CFD(y,f1,f2)
  list dt = US VS LL LX DC CS
  matrix lambda=zeros(2,1)|LLorder|LXshape|zeros(2,1)
  id=seq(1,nelem(dt))'
elif loss==1
  print &quot;   U-shaped loss function&quot;
  series US=Ushape(y,f1,f2)
  list dt = US
elif loss==2
  print &quot;   V-shaped loss function&quot;
  series VS=Vshape(y,f1,f2)
  list dt = VS
elif loss==3
  if LLorder&gt;=0 &amp;&amp; LLorder&lt;=1
    printf &quot;   Lin-Lin loss function with order parameter %g\n&quot;,LLorder
  endif
  series LL=LinLin(y,f1,f2,LLorder)
  list dt = LL
  lambda=LLorder
elif loss==4
  printf &quot;   Linex loss function with shape parameter %g\n&quot;,LXshape
  series LX=Linex(y,f1,f2,LXshape)
  list dt = LX
  lambda=LXshape
elif loss==5
  print &quot;   Direction-of-change loss function&quot;
  series DC=Doc(y,f1,f2)
  list dt = DC
elif loss=6
  print &quot;   Forecast-direction loss function&quot;
  series CS=CFD(y,f1,f2)
  list dt = CS
endif
matrix d={}
matrix stderr={}
scalar stop=0
loop foreach i dt --quiet
  stop=missing(mean($i))
  if stop!=1
    d|=mean($i)
    if prewhit==1
      stderr|=Prewhitening($i,m)
    else
      stderr|=sqrt(lrvar($i,m))
    endif
  else
    d|=0
    stderr|=-1
  endif
endloop
if m==-1
  printf &quot;   Bartlett windows size: %g (default)\n&quot;,floor($nobs^(1/3))
else
  printf &quot;   Bartlett windows size: %g\n&quot;,m
endif
if prewhit
  print &quot;   Prewhitening correction&quot;
endif
matrix DMtest=d./stderr
matrix DM=(id~DMtest~2*pvalue(z,abs(DMtest))~lambda)
if loss==0 || loss==3
  if LLorder&gt;=0 &amp;&amp; LLorder&lt;=1
    matrix LLG=LinLinGrid(y,f1,f2,m,prewhit)
  endif
else
  matrix LLG={}
endif
if loss==0 || loss==4
  matrix LXG=LinexGrid(y,f1,f2,LXshape,m,prewhit)
else
  matrix LXG={}
endif
DM|=LLG|LXG
PrintResults(DM)
return DM
</code>
</gretl-function>
<gretl-function name="ScaleSeries" type="series" private="1">
 <params count="1">
  <param name="Y" type="series"/>
 </params>
<code>scalar V=sqrt(var(Y))
series Z=Y/V
return Z
</code>
</gretl-function>
<gretl-function name="Prewhitening" type="scalar" private="1">
 <params count="2">
  <param name="X" type="series"/>
  <param name="lag" type="scalar"/>
 </params>
<code>ols X 0 X(-1) --quiet
scalar a=$coeff(X_1)
scalar denom=(1-a)^2
scalar out=sqrt(lrvar($uhat,lag)/denom)
#pre-whitened quadratic spectral kernel introduced by Andrews and Monahan (1992) to correct
#the standard errors for heteroskedasticity and autocorrelation.
return out
</code>
</gretl-function>
<gretl-function name="Check" type="series" private="1">
 <params count="1">
  <param name="X" type="series"/>
 </params>
<code>scalar control=isconst(X)
series out=X
if control==1
  out=NA
endif
return out
</code>
</gretl-function>
<gretl-function name="Ushape" type="series" private="1">
 <params count="3">
  <param name="y" type="series"/>
  <param name="x1" type="series"/>
  <param name="x2" type="series"/>
 </params>
<code>series e1=x1-y
series e2=x2-y
series out=ScaleSeries(e1^2-e2^2)
out=Check(out)
return out
</code>
</gretl-function>
<gretl-function name="Vshape" type="series" private="1">
 <params count="3">
  <param name="y" type="series"/>
  <param name="x1" type="series"/>
  <param name="x2" type="series"/>
 </params>
<code>series e1=x1-y
series e2=x2-y
series out=ScaleSeries(abs(e1)-abs(e2))
out=Check(out)
return out
</code>
</gretl-function>
<gretl-function name="LinLin" type="series" private="1">
 <params count="4">
  <param name="y" type="series"/>
  <param name="x1" type="series"/>
  <param name="x2" type="series"/>
  <param name="lambda" type="scalar"/>
 </params>
<code>series e1=x1-y
series e2=x2-y
series g1=(lambda-(e1&lt;0?1:0))*e1
series g2=(lambda-(e2&lt;0?1:0))*e2
series out=ScaleSeries(g1-g2)
if lambda&lt;0 || lambda&gt;1
  out=NA
endif
out=Check(out)
return out
</code>
</gretl-function>
<gretl-function name="Linex" type="series" private="1">
 <params count="4">
  <param name="y" type="series"/>
  <param name="x1" type="series"/>
  <param name="x2" type="series"/>
  <param name="lambda" type="scalar"/>
 </params>
<code>series e1=x1-y
series e2=x2-y
scalar M1=lambda*max(abs(e1))
scalar M2=lambda*max(abs(e2))
series out=NA
if M1&lt;=350 &amp;&amp; M2&lt;=350
  out=exp(lambda*e1)-exp(lambda*e2)-lambda*(x1-x2)
  out=ScaleSeries(out)
  out=Check(out)
endif
return out
</code>
</gretl-function>
<gretl-function name="Doc" type="series" private="1">
 <params count="3">
  <param name="y" type="series"/>
  <param name="x1" type="series"/>
  <param name="x2" type="series"/>
 </params>
<code>series y1=y(-1)
g1=abs(((y-y1)&gt;0?1:0)-((x1-y1)&gt;0?1:0))
g2=abs(((y-y1)&gt;0?1:0)-((x2-y1)&gt;0?1:0))
series out=g1-g2
out=Check(out)
return out
</code>
</gretl-function>
<gretl-function name="CFD" type="series" private="1">
 <params count="3">
  <param name="y" type="series"/>
  <param name="x1" type="series"/>
  <param name="x2" type="series"/>
 </params>
<code># See Pesaran and Timmermann (1992),
series g1=(y*x1)&lt;0
series g2=(y*x2)&lt;0
series out=g1-g2
out=Check(out)
return out
</code>
</gretl-function>
<gretl-function name="LinLinGrid" type="matrix" private="1">
 <params count="5">
  <param name="y" type="series"/>
  <param name="x1" type="series"/>
  <param name="x2" type="series"/>
  <param name="lag" type="scalar"/>
  <param name="prewhit" type="scalar"/>
 </params>
<code>matrix ref=0.01*seq(0,100)'
scalar c=rows(ref)
series e1=x1-y
series e2=x2-y
series g1=0
series g2=0
series Loss=0
scalar d=0
scalar se=0
scalar pvmax=0
scalar pvmin=1
scalar test=NA
scalar maxtest=NA
scalar mintest=NA
scalar parmax=NA
scalar parmin=NA
scalar pval=NA
loop for i=1..c --quiet
  g1=(ref[i]-(e1&lt;0?1:0))*e1
  g2=(ref[i]-(e2&lt;0?1:0))*e2
  Loss=Check(g1-g2)
  d=misszero(mean(Loss))
  if d!=0
    if prewhit==1
      stderr=Prewhitening(Loss,lag)
    else
      stderr=sqrt(lrvar(Loss,lag))
    endif
    test=d/stderr
    pval=2*pvalue(z,abs(test))
    if pval&gt;=pvmax
      pvmax=pval
      parmax=ref[i]
      maxtest=test
    endif
    if pval&lt;=pvmin
      pvmin=pval
      parmin=ref[i]
      mintest=test
    endif
  endif
endloop
matrix out=(7~maxtest~pvmax~parmax)|(8~mintest~pvmin~parmin)
return out
</code>
</gretl-function>
<gretl-function name="LinexGrid" type="matrix" private="1">
 <params count="6">
  <param name="y" type="series"/>
  <param name="x1" type="series"/>
  <param name="x2" type="series"/>
  <param name="par" type="scalar"/>
  <param name="lag" type="scalar"/>
  <param name="prewhit" type="scalar"/>
 </params>
<code>scalar Apar=abs(par)
scalar M=(Apar&gt;2?Apar:2)
matrix ref=0.01*(seq(-100*M,-1)~seq(1,100*M))'
series e1=x1-y
series e2=x2-y
# check for numerical problems in exp{x} =&gt; -350&lt;x&lt;350
matrix Active=(max(abs(e1))*abs(ref).&gt;350.?0.:1).*(max(abs(e2))*abs(ref).&gt;350.?0.:1)
ref=selifr(ref,Active)
scalar c=rows(ref)
series Loss=0
scalar d=0
scalar se=0
scalar pvmax=0
scalar pvmin=1
scalar test=NA
scalar maxtest=NA
scalar mintest=NA
scalar parmax=NA
scalar parmin=NA
scalar pval=NA
loop for i=1..c --quiet
  Loss=ScaleSeries(exp(ref[i]*e1)-exp(ref[i]*e2)-ref[i]*(x1-x2))
  Loss=Check(Loss)
  d=misszero(mean(Loss))
  if prewhit==1
    stderr=Prewhitening(Loss,lag)
  else
    stderr=sqrt(lrvar(Loss,lag))
  endif
  test=d/stderr
  pval=2*pvalue(z,abs(test))
  if pval&gt;=pvmax
    pvmax=pval
    maxtest=test
    parmax=ref[i]
  endif
  if pval&lt;=pvmin
    pvmin=pval
    mintest=test
    parmin=ref[i]
  endif
endloop
matrix out=(9~maxtest~pvmax~parmax)|(10~mintest~pvmin~parmin)
return out
</code>
</gretl-function>
<gretl-function name="PrintResults" type="void" private="1">
 <params count="1">
  <param name="IN" type="matrix"/>
 </params>
<code>matrix id_orig=IN[,1]
matrix test=IN[,2]
matrix pval=IN[,3]
matrix par=IN[,4]
scalar k=rows(IN)
if k&lt;=3
  if test[1]==0
    if id_orig[1]==4
      print &quot; &quot;
      print &quot;The test is not performed:&quot;
      printf &quot;  numerical results out of range for exp{%g*e}.\n&quot;,par[1]
    else
      print &quot; &quot;
      print &quot;This test is not performed: both forecast &quot;
      print &quot;   series have exactly the same predictive accuracy.&quot;
    endif
  elif test[1]!=0
    print &quot; &quot;
    printf &quot;   DM test statistic: %.4f \n&quot;,test[1]
    printf &quot;   p-value: %.4f\n&quot;,pval[1]
  endif
  if k==3
    if id_orig[k]==8
      print &quot; &quot;
      printf &quot; Highest p-value=%.4f for order parameter %g.\n&quot;,pval[2],par[2]
      printf &quot; Lowest p-value=%.4f for order parameter %g.\n&quot;,pval[3],par[3]
    elif id_orig[k]==10
      print &quot; &quot;
      printf &quot; Highest p-value=%.4f for shape parameter %g.\n&quot;,pval[2],par[2]
      printf &quot; Lowest p-value=%.4f for shape parameter %g.\n&quot;,pval[3],par[3]
    endif
  endif
elif k&gt;3
  matrix id=selifr(id_orig,test)
  k=rows(id)
  print &quot; &quot;
  if id[1]==1 || id[1]==2
    print &quot;Symmetric loss functions                  DM test    p-value&quot;
  endif
  loop for i=1..k --quiet
    if id[i]==1
      printf &quot;   U-shape                             %10.4f     %.4f\n&quot;,test[1],pval[1]
    elif id[i]==2
      printf &quot;   V-shape                             %10.4f     %.4f\n&quot;,test[2],pval[2]
    endif
  endloop
  scalar asy=sumc(test[3:6].=0?1:0)
  print &quot; &quot;
  if asy&lt;4
    print &quot;Asymmetric loss functions                 DM test    p-value&quot;
  endif
  loop for i=1..k --quiet
    if id[i]==3
      printf &quot;   Lin-Lin (order parameter %.2f)*     %10.4f     %.4f\n&quot;,par[3],test[3],pval[3]
    elif id[i]==4
      if par[4]&gt;=10
        printf &quot;   Linex (shape parameter %5.2f)**     %10.4f     %.4f\n&quot;,par[4],test[4],pval[4]
      elif par[4]&lt;=-10
        printf &quot;   Linex (shape parameter %6.2f)**    %10.4f     %.4f\n&quot;,par[4],test[4],pval[4]
      elif par[4]&gt;-10 &amp;&amp; par[4]&lt;10
        printf &quot;   Linex (shape parameter %5.2f)**     %10.4f     %.4f\n&quot;,par[4],test[4],pval[4]
      endif
    elif id[i]==5
      printf &quot;   Direction-of-change                 %10.4f     %.4f\n&quot;,test[5],pval[5]
    elif id[i]==6
      printf &quot;   Forecast-direction                  %10.4f     %.4f\n&quot;,test[6],pval[6]
    endif
  endloop
  loop for i=1..k --quiet
    if id[i]==3
      print &quot; &quot;
      printf &quot; * The highest p-value=%.4f is for order parameter %g.\n&quot;,pval[7],par[7]
      printf &quot;   The lowest p-value=%.4f is for order parameter %g.\n&quot;,pval[8],par[8]
    endif
    if id[i]==4
      print &quot; &quot;
      printf &quot;** The highest p-value=%.4f is for shape parameter %g.\n&quot;,pval[9],par[9]
      printf &quot;   The lowest p-value=%.4f is for shape parameter %g.\n&quot;,pval[10],par[10]
    endif
  endloop
  loop for i=1..6 --quiet
    if test[i]==0
      if id_orig[i]==1
        print &quot; &quot;
        print &quot;The test with U-shape loss function is not performed:&quot;
        print &quot;  both forecast series have exactly the same predictive accuracy.&quot;
      elif id_orig[i]==2
        print &quot; &quot;
        print &quot;The test with V-shape loss function is not performed:&quot;
        print &quot;  both forecast series have exactly the same predictive accuracy.&quot;
      elif id_orig[i]==3
        print &quot; &quot;
        print &quot;The test with Lin-Lin loss function is not performed:&quot;
        print &quot;  both forecast series have exactly the same predictive accuracy.&quot;
      elif id_orig[i]==4
        print &quot; &quot;
        print &quot;The test with Linex loss function is not performed:&quot;
        printf &quot;  numerical results out of range for exp{%g*e}.\n&quot;,par[4]
      elif id_orig[i]==5
        print &quot; &quot;
        print &quot;The test with Direction-of-sign loss function is not performed:&quot;
        print &quot;  both forecast series have exactly the same predictive accuracy.&quot;
      elif id_orig[i]==6
        print &quot; &quot;
        print &quot;The test with Forecast-direction loss function is not performed:&quot;
        print &quot;  both forecast series have exactly the same predictive accuracy.&quot;
      endif
    endif
  endloop
endif
print &quot;==================================================================&quot;
print &quot;&quot;
</code>
</gretl-function>
<sample-script>
set echo off
set messages off
include DiebMar.gfn

open AWM --quiet
e = ln(EER)  #Exchange rate (in logs)
x = ln(XTR)  #Export (in logs)
d = ln(YWRX) #World demand
smpl 1970:1 1997:4 

# Model 1
ols x 0 e d --quiet 
fcast fore1 

# Model 2
arma 1 1 ; x 0 --quiet
fcast fore2 

scalar LL_param=0.7    # parameter for Lin-Lin loss function
scalar LX_param=0.8    # parameter for Linex loss function

# Default
matrix DB=DiebMar(x,fore1,fore2,0,LL_param,LX_param,-1,1)

# Test DM for each single loss function

DB=DiebMar(x,fore1,fore2,1,LL_param,LX_param,-1,1)
DB=DiebMar(x,fore1,fore2,2,LL_param,LX_param,-1,1)
DB=DiebMar(x,fore1,fore2,3,LL_param,LX_param,-1,1)
DB=DiebMar(x,fore1,fore2,4,LL_param,LX_param,-1,1)
DB=DiebMar(x,fore1,fore2,5,LL_param,LX_param,-1,1)
DB=DiebMar(x,fore1,fore2,6,LL_param,LX_param,-1,1)
</sample-script>
</gretl-function-package>
</gretl-functions>

