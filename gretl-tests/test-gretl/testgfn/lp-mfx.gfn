<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="lp-mfx" ID="1427123354" minver="1.9.12">
<author email="cottrell@wfu.edu">Allin Cottrell</author>
<version>0.2</version>
<date>2013-06-27</date>
<description>logit/probit marginal effects</description>
<label>Marginal effects</label>
<menu-attachment>MODELWIN/Analysis</menu-attachment>
<help>
This package serves to calculate marginal effects and associated
statistics (standard errors, z-values and p-values) for logit and
probit models: it covers binary logit and probit, ordered logit
and probit, and multinomial logit. 

The package offers a graphical interface which is designed to appear 
under the Analysis menu in gretl's model window; this is hard-wired
to produce marginal effects at the sample means of all the regressors.
In addition it provides a set of functions which can be used to
calculate marginal effects at any vector of regressor values. 

For each sort of dependent variable (binary, ordered, multinomial)
two public functions are available. Those named *_mfx calculate
marginal effects for each possible outcome at the sample means, 
along with standard errors via the delta method, and they return a 
bundle containing all the results. The other functions accept a 
k-vector, x, containing the values of the regressors at which the 
marginal effects should be found, and they return the k-vector of 
effects pertaining to a specific selected outcome.

Dummy variables (0/1) are detected and the marginal effect is
calculated as the effect of a discrete change from 0 to 1.

* For binary logit and probit:

function bundle binary_mfx (series y &quot;dependent variable&quot;,
    list XL &quot;list of regressors&quot;, 
    matrix theta &quot;parameter estimates&quot;,
    matrix V &quot;estimated variance matrix&quot;,
    series sample &quot;model sample&quot;,
    int dist[1:2:1] &quot;distribution&quot; \
    {&quot;logit&quot;, &quot;probit&quot;})

function matrix binary_dp_dx (matrix b &quot;parameter estimates&quot;, 
    list XL &quot;list of regressors&quot;, 
    matrix x &quot;vector of x-values&quot;, 
    int dist[1:2:1] &quot;distribution&quot; \
    {&quot;logit&quot;, &quot;probit&quot;})

* For ordered logit and probit:

function bundle ordered_mfx (series y &quot;dependent variable&quot;,
    list XL &quot;list of regressors&quot;, 
    matrix theta &quot;parameter estimates&quot;,
    matrix V &quot;estimated variance matrix&quot;,
    series sample &quot;model sample&quot;,
    int dist[1:2:1] &quot;distribution&quot; \
    {&quot;logit&quot;, &quot;probit&quot;})

function matrix ordered_dp_dx (matrix theta &quot;parameter estimates&quot;, 
    list XL &quot;list of regressors&quot;, 
    matrix x &quot;vector of regressors&quot;,
    int j &quot;1-based index of outcome&quot;,
    int m &quot;number of possible outcomes&quot;,
    int dist[1:2:1] &quot;distribution&quot; \
    {&quot;logit&quot;, &quot;probit&quot;})

* For multinomial logit:

function bundle mlogit_mfx (series y &quot;dependent variable&quot;,
    list XL &quot;list of regressors&quot;, 
    matrix theta &quot;parameter estimates&quot;,
    matrix V &quot;estimated variance matrix&quot;,
    series sample &quot;model sample&quot;)

function matrix mlogit_dpj_dx (matrix b &quot;parameter estimates&quot;, 
    list XL &quot;list of regressors&quot;, 
    matrix x &quot;vector of x-values&quot;,
    int j &quot;1-based index of outcome&quot;, 
    int m &quot;number of possible outcomes&quot;)
</help>
<gretl-function name="GUI_lp_mfx" type="bundle" no-print="1" menu-only="1" pkg-role="gui-main">
<code>## no-print ##
list Y = $ylist
string yname = $depvar
loop foreach i Y
  series @yname = Y.$i
endloop
bundle b
catch scalar mn = $[&quot;multinom&quot;]
scalar err = $error
if !err
  b = mlogit_mfx(@yname, $xlist, $coeff, $vcv, $sample)
else
  string cmd = $command
  scalar dist = (cmd == &quot;logit&quot;)? 1 : 2
  catch scalar mn = $[&quot;ordered&quot;]
  scalar err = $error
  if !err
    b = ordered_mfx(@yname, $xlist, $coeff, $vcv, $sample, dist)
  else
    b = binary_mfx(@yname, $xlist, $coeff, $vcv, $sample, dist)
  endif
endif
return b
</code>
</gretl-function>
<gretl-function name="lp_mfx_print" type="void" pkg-role="bundle-print">
 <params count="1">
  <param name="b" type="bundleref"/>
 </params>
<code>string model = b[&quot;model&quot;]
scalar dist = b[&quot;dist&quot;]
if model != &quot;Binary&quot;
  scalar m = b[&quot;n_outcomes&quot;]
  matrix yvals = b[&quot;yvals&quot;]
  matrix mp = b[&quot;meanprob&quot;]
else
  scalar m = 1
  scalar mp = b[&quot;meanprob&quot;]
endif
string yname = b[&quot;yname&quot;]
catch string Dnames = b[&quot;Dnames&quot;]
string dstr = (dist == 1)? &quot;logit&quot; : &quot;probit&quot;
printf &quot;\n%s %s marginal effects\n&quot;, model, dstr
printf &quot;(evaluated at means of regressors)\n&quot;
if !isnull(Dnames)
  printf &quot;\nnote: dp/dx based on discrete change for %s\n&quot;, Dnames
endif
printf &quot;\n&quot;
if m == 1
  matrix res = b[&quot;mfx&quot;]
  printf &quot;%s = 1, Pr = %.4f\n\n%#12.5g\n&quot;, yname, mp, res
else
  loop j=1..m -q
    string matname = &quot;mfx_$j&quot;
    matrix res = b[matname]
    printf &quot;Outcome %d: (%s = %d, Pr = %.4f)\n\n%#12.5g\n&quot;, j, yname, yvals[j], mp[j], res
  endloop
endif
</code>
</gretl-function>
<gretl-function name="mlogit_mfx" type="bundle">
 <params count="5">
  <param name="y" type="series">
<description>dependent variable</description>
  </param>
  <param name="XL" type="list">
<description>list of regressors</description>
  </param>
  <param name="theta" type="matrix">
<description>parameter estimates</description>
  </param>
  <param name="V" type="matrix">
<description>estimated variance matrix</description>
  </param>
  <param name="sample" type="series">
<description>model sample</description>
  </param>
 </params>
<code># ensure we're using the model's estimation sample
smpl sample --dummy
string yname = argname(y)
matrix yvals = values(y)
scalar m = rows(yvals)
bundle ret
ret[&quot;model&quot;] = &quot;Multinomial&quot;
ret[&quot;dist&quot;] = 1
ret[&quot;n_outcomes&quot;] = m
ret[&quot;yname&quot;] = yname
ret[&quot;yvals&quot;] = yvals
# compute mean X and assemble list of dummies
matrix x = ones(1, nelem(XL))
list D = null
loop foreach i XL -q
  if varnum(XL.$i) &gt; 0
    x[i] = mean(XL.$i)
    if is_dummy(XL.$i)
      D += XL.$i
    endif
  endif
endloop
if nelem(D) &gt; 0
  ret[&quot;Dnames&quot;] = varname(D)
endif
matrix meanprob = mlogit_pj(&amp;theta, &amp;x, m)
ret[&quot;meanprob&quot;] = meanprob
matrix xbar = inlist(XL, 0) ? (x[2:]') : x'
# now compute marginal effects for each outcome
loop j=1..m -q
  matrix dpj = mlogit_dpj_dx(theta, XL, x, j, m)'
  matrix J = fdjac(theta, mlogit_dpj_dx(theta, XL, x, j, m))
  matrix Vdpj = qform(J, V)
  matrix se = sqrt(diag(Vdpj))
  matrix zval = dpj ./ se
  matrix pval = 2 * pvalue(z, abs(zval))
  matrix res = dpj ~ se ~ zval ~ pval ~ xbar
  colnames(res, &quot;dp/dx s.e. z pval xbar&quot;)
  rownames(res, XL - 0)
  string matname = &quot;mfx_$j&quot;
  ret[matname] = res
endloop
return ret
</code>
</gretl-function>
<gretl-function name="mlogit_dpj_dx" type="matrix">
 <params count="5">
  <param name="b" type="matrix">
<description>parameter estimates</description>
  </param>
  <param name="XL" type="list">
<description>list of regressors</description>
  </param>
  <param name="x" type="matrix">
<description>vector of x-values</description>
  </param>
  <param name="j" type="int">
<description>1-based index of outcome</description>
  </param>
  <param name="m" type="int">
<description>number of possible outcomes</description>
  </param>
 </params>
<code># Computes the &quot;slope&quot; of the probability that outcome j
# occurs with respect to each regressor
#
# Returns a (row) k-vector, where k is the number of
# regressors (omitting the constant, if present)
matrix p = mlogit_pj(&amp;b, &amp;x, m)
scalar nb = rows(b) / (m-1)
scalar ifc = inlist(XL, 0)
scalar nx = nb - ifc
matrix bbar = zeros(nx, 1)
scalar k
if j &gt; 1
  k = (j-2)*nb + 1
  matrix bj = b[k+ifc:k+nb-1]
endif
k = 1
loop l=2..m -q
  matrix bk = b[k+ifc:k+nb-1]
  bbar += p[l] * bk
  k += nb
endloop
if j == 1
  # the baseline case
  matrix d = (p[j] * -bbar)'
else
  matrix d = (p[j] * (bj - bbar))'
endif
loop foreach i XL -q
  # special handling for dummy regressors
  if varnum(XL.$i) &gt; 0 &amp;&amp; is_dummy(XL.$i)
    x[i] = 0
    matrix p0 = mlogit_pj(&amp;b, &amp;x, m)
    x[i] = 1
    matrix p1 = mlogit_pj(&amp;b, &amp;x, m)
    d[i-ifc] = p1[j] - p0[j]
  endif
endloop
return d
</code>
</gretl-function>
<gretl-function name="ordered_mfx" type="bundle">
 <params count="6">
  <param name="y" type="series">
<description>dependent variable</description>
  </param>
  <param name="XL" type="list">
<description>list of regressors</description>
  </param>
  <param name="theta" type="matrix">
<description>parameter estimates</description>
  </param>
  <param name="V" type="matrix">
<description>estimated variance matrix</description>
  </param>
  <param name="sample" type="series">
<description>model sample</description>
  </param>
  <param name="dist" type="int" min="1" max="2" default="1">
<description>distribution</description>
<labels count="2">
"logit" "probit" </labels>
  </param>
 </params>
<code># ensure we're using the model's estimation sample
smpl sample --dummy
string yname = argname(y)
matrix yvals = values(y)
scalar m = rows(yvals)
bundle ret
ret[&quot;model&quot;] = &quot;Ordered&quot;
ret[&quot;dist&quot;] = dist
ret[&quot;n_outcomes&quot;] = m
ret[&quot;yname&quot;] = yname
ret[&quot;yvals&quot;] = yvals
# compute mean X and assemble list of dummies
matrix x = ones(1, nelem(XL))
list D = null
loop foreach i XL -q
  if varnum(XL.$i) &gt; 0
    x[i] = mean(XL.$i)
    if is_dummy(XL.$i)
      D += XL.$i
    endif
  endif
endloop
if nelem(D) &gt; 0
  ret[&quot;Dnames&quot;] = varname(D)
endif
matrix meanprob = ordered_pj(&amp;theta, &amp;x, m, dist)
ret[&quot;meanprob&quot;] = meanprob
matrix xbar = inlist(XL, 0) ? (x[2:]') : x'
# now compute marginal effects for each outcome
loop j=1..m -q
  matrix dpj = ordered_dpj_dx(theta, XL, x, j, m, dist)'
  matrix J = fdjac(theta, ordered_dpj_dx(theta, XL, x, j, m, dist))
  matrix Vdpj = qform(J, V)
  matrix se = sqrt(diag(Vdpj))
  matrix zval = dpj ./ se
  matrix pval = 2 * pvalue(z, abs(zval))
  matrix res = dpj ~ se ~ zval ~ pval ~ xbar
  colnames(res, &quot;dp/dx s.e. z pval xbar&quot;)
  rownames(res, XL - 0)
  string matname = &quot;mfx_$j&quot;
  ret[matname] = res
endloop
return ret
</code>
</gretl-function>
<gretl-function name="ordered_dpj_dx" type="matrix">
 <params count="6">
  <param name="theta" type="matrix">
<description>parameter estimates</description>
  </param>
  <param name="XL" type="list">
<description>list of regressors</description>
  </param>
  <param name="x" type="matrix">
<description>vector of regressors</description>
  </param>
  <param name="j" type="int">
<description>1-based index of outcome</description>
  </param>
  <param name="m" type="int">
<description>number of possible outcomes</description>
  </param>
  <param name="dist" type="int" min="1" max="2" default="1">
<description>distribution</description>
<labels count="2">
"logit" "probit" </labels>
  </param>
 </params>
<code># Computes the &quot;slope&quot; of the probability that outcome j
# occurs, with respect to each regressor
#
# Returns a (row) k-vector, where k is the number of
# regressors (omitting the constant, if present)
scalar k = cols(x)
matrix b = theta[1:k]
matrix cut = theta[k+1:]
matrix dfc = ordered_func(x*b, &amp;cut, dist, 1)
matrix dp = zeros(1, k)
loop i=1..k -q
  if j == 1
    dp[i] = -b[i] * dfc[j]
  elif j &lt; m
    dp[i] = -b[i] * (dfc[j] - dfc[j-1])
  else
    dp[i] = b[i] * dfc[j-1]
  endif
endloop
loop foreach i XL -q
  if is_dummy(XL.$i)
    x[i] = 0
    matrix p0 = ordered_pj(&amp;theta, &amp;x, m, dist)
    x[i] = 1
    matrix p1 = ordered_pj(&amp;theta, &amp;x, m, dist)
    dp[i] = p1[j] - p0[j]
  endif
endloop
return dp
</code>
</gretl-function>
<gretl-function name="binary_mfx" type="bundle">
 <params count="6">
  <param name="y" type="series">
<description>dependent variable</description>
  </param>
  <param name="XL" type="list">
<description>list of regressors</description>
  </param>
  <param name="theta" type="matrix">
<description>parameter estimates</description>
  </param>
  <param name="V" type="matrix">
<description>estimated variance matrix</description>
  </param>
  <param name="sample" type="series">
<description>model sample</description>
  </param>
  <param name="dist" type="int" min="1" max="2" default="1">
<description>distribution</description>
<labels count="2">
"logit" "probit" </labels>
  </param>
 </params>
<code>bundle ret
if nelem(XL) != rows(V)
  funcerr &quot;Length of X list does not match dimension of V&quot;
endif
# ensure we're using the model's estimation sample
smpl sample --dummy
string yname = argname(y)
ret[&quot;model&quot;] = &quot;Binary&quot;
ret[&quot;dist&quot;] = dist
ret[&quot;yname&quot;] = yname
# compute mean X and assemble list of dummies
matrix x = ones(1, nelem(XL))
list D = null
loop foreach i XL -q
  if varnum(XL.$i) &gt; 0
    x[i] = mean(XL.$i)
    if is_dummy(XL.$i)
      D += XL.$i
    endif
  endif
endloop
if nelem(D) &gt; 0
  ret[&quot;Dnames&quot;] = varname(D)
endif
scalar meanprob = binary_prob(&amp;theta, &amp;x, dist)
ret[&quot;meanprob&quot;] = meanprob
matrix xbar = inlist(XL, 0) ? (x[2:]') : x'
# now compute marginal effects
matrix dp = binary_dp_dx(theta, XL, x, dist)'
matrix J = fdjac(theta, binary_dp_dx(theta, XL, x, dist))
matrix Vdp = qform(J, V)
matrix se = sqrt(diag(Vdp))
matrix zval = dp ./ se
matrix pval = 2 * pvalue(z, abs(zval))
matrix res = dp ~ se ~ zval ~ pval ~ xbar
colnames(res, &quot;dp/dx s.e. z pval xbar&quot;)
rownames(res, XL - 0)
ret[&quot;mfx&quot;] = res
return ret
</code>
</gretl-function>
<gretl-function name="binary_dp_dx" type="matrix">
 <params count="4">
  <param name="b" type="matrix">
<description>parameter estimates</description>
  </param>
  <param name="XL" type="list">
<description>list of regressors</description>
  </param>
  <param name="x" type="matrix">
<description>vector of x-values</description>
  </param>
  <param name="dist" type="int" min="1" max="2" default="1">
<description>distribution</description>
<labels count="2">
"logit" "probit" </labels>
  </param>
 </params>
<code># Computes the &quot;slope&quot; of the probability that y = 1
# with respect to each regressor
#
# Returns a (row) k-vector, where k is the number of
# regressors (omitting the constant, if present)
scalar ifc = inlist(XL, 0)
scalar xb = x*b
scalar fxb = (dist == 1)? logit_pdf(xb) : dnorm(xb)
scalar nx = nelem(XL) - ifc
matrix d = zeros(1, nx)
loop foreach i XL -q
  if varnum(XL.$i) &gt; 0 &amp;&amp; is_dummy(XL.$i)
    x[i] = 0
    scalar p0 = binary_prob(&amp;b, &amp;x, dist)
    x[i] = 1
    scalar p1 = binary_prob(&amp;b, &amp;x, dist)
    d[i-ifc] = p1 - p0
  elif varnum(XL.$i) &gt; 0
    d[i-ifc] = b[i] * fxb
  endif
endloop
return d
</code>
</gretl-function>
<gretl-function name="is_dummy" type="scalar" private="1">
 <params count="1">
  <param name="x" type="series"/>
 </params>
<code># detect whether or not series x is a dummy variable
scalar v0 = sum(x == 0)
scalar v1 = sum(x == 1)
return v0 &gt; 0 &amp;&amp; v1 &gt; 0 &amp;&amp; sum(ok(x)) == v0 + v1
</code>
</gretl-function>
<gretl-function name="logit_pdf" type="scalar" private="1">
 <params count="1">
  <param name="x" type="scalar"/>
 </params>
<code>scalar z = exp(-x)
return z / (1+z)^2
</code>
</gretl-function>
<gretl-function name="binary_prob" type="scalar" private="1">
 <params count="3">
  <param name="b" type="matrixref"/>
  <param name="x" type="matrixref"/>
  <param name="dist" type="int"/>
 </params>
<code>scalar xb = x*b
return (dist == 1)? (1 / (1 + exp(-xb))) : cnorm(xb)
</code>
</gretl-function>
<gretl-function name="ordered_func" type="matrix" private="1">
 <params count="4">
  <param name="xb" type="scalar"/>
  <param name="cut" type="matrixref"/>
  <param name="dist" type="int"/>
  <param name="deriv" type="bool"/>
 </params>
<code>scalar n = rows(cut)
matrix ret = zeros(1, n)
scalar arg
loop j=1..n -q
  arg = cut[j] - xb
  if dist == 1
    ret[j] = deriv ? logit_pdf(arg) : 1 / (1 + exp(-arg))
  else
    ret[j] = deriv ? dnorm(arg) : cnorm(arg)
  endif
endloop
return ret
</code>
</gretl-function>
<gretl-function name="ordered_pj" type="matrix" private="1">
 <params count="4">
  <param name="theta" type="matrixref"/>
  <param name="x" type="matrixref"/>
  <param name="m" type="int"/>
  <param name="dist" type="int"/>
 </params>
<code># Computes the probability of each outcome, j=1,...,m, for
# the given parameter vector and regressor vector.
#
#  theta = parameter vector from ordered model
#  x = vector of x-values (including the constant, if present)
#  m = number of possible outcomes
#  dist = 1 for logit, 2 for probit
#
# Returns a (row) m-vector of probabilities
scalar k = cols(x)
matrix b = theta[1:k]
matrix cut = theta[k+1:]
matrix fc = ordered_func(x*b, &amp;cut, dist, 0)
matrix prob = zeros(1, m)
loop j=1..m -q
  if j == 1
    prob[j] = fc[j]
  elif j &lt; m
    prob[j] = fc[j] - fc[j-1]
  else
    prob[j] = 1 - fc[j-1]
  endif
endloop
return prob
</code>
</gretl-function>
<gretl-function name="mlogit_pj" type="matrix" private="1">
 <params count="3">
  <param name="b" type="matrixref"/>
  <param name="x" type="matrixref"/>
  <param name="m" type="int"/>
 </params>
<code># Compute the probability of each outcome, j=1,...,m, for
# the given parameter vector and regressor vector.
#
#  b = parameter vector from mlogit model
#  x = vector of x-values (including the constant, if present)
#  m = number of possible outcomes
#
# Returns a (row) m-vector of probabilities
# nb = number of parameters per outcome
scalar nb = rows(b) / (m-1)
# to hold exp(x*b_j) per outcome
matrix num = ones(1, m)
# to hold \sum_j Xb_j
scalar den = 1
k = 1
loop j=2..m -q
  matrix bj = b[k:k+nb-1]
  num[j] = exp(x*bj)
  den += num[j]
  k += nb
endloop
return num / den
</code>
</gretl-function>
<gretl-function name="lp_mfx_precheck" type="scalar" private="1" pkg-role="gui-precheck">
<code>scalar err = 0
string cmd = $command
if cmd != &quot;logit&quot; &amp;&amp; cmd != &quot;probit&quot;
  print &quot;lp_mfx: not a logit or probit model&quot;
  err = 1
else
  catch scalar qp = $[&quot;quadpoints&quot;]
  scalar err = ($error == 0)
  if err
    print &quot;lp_mfx: can't handle random effects probit yet&quot;
  endif
endif
return err
</code>
</gretl-function>
<sample-script>
include lp-mfx.gfn

open keane.gdt -q
smpl (year==87) --restrict
logit status 0 educ exper expersq black --multinomial
bundle b = mlogit_mfx(status, $xlist, $coeff, $vcv, $sample)
lp_mfx_print(&amp;b)
</sample-script>
</gretl-function-package>
</gretl-functions>

