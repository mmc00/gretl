<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="Canova_Hansen" ID="1378138928" needs-time-series-data="true" minver="1.10.0" lives-in-subdir="true">
<author email="ignacio.diaz-emparanza@ehu.eus">Ignacio Diaz-Emparanza, Mª Paz Moral</author>
<version>1.2</version>
<date>2015-03-13</date>
<description>Seasonal stability tests</description>
<label>Canova-Hansen</label>
<menu-attachment>MAINWIN/Variable/URTests</menu-attachment>
<help>
This function computes the Canova-Hansen (1995) seasonal stability tests for a series and their p-values based on a surface-regression approach. A detailed explanation is in I. Díaz-Emparanza, M. Paz Moral, &quot;Numerical distribution functions for seasonal stability tests&quot;, Statistics &amp; Probability Letters, Volume 86, March 2014, Pages 44-49, http://dx.doi.org/10.1016/j.spl.2013.12.002.

Public interfaces:
  Canova_Hansen()

Execution:

matrix CH=Canova_Hansen(y, diffy, sdum, trendroot, mprint, X_list, mlatex)  

Parameters:

y 		series 	dependent variable
diffy		boolean Use[1]/[0]No use first diffenrences
sdum 		integer	Type of seasonal component (O: dummies; 1: trigonometric terms)
trendroot	integer	Trend component (0: no trend; 1: linear trend; 2: y(-1); 3: trend+y(-1))
mprint    	boolean Print[1]/No print[0] the auxiliary regression
X_list		list of regressors
mlatex 		boolean Create[1]/No create[0] Latex table wtih results


Result: a bundle. Matrix SCH in this bundle has 2 columns: 
CH statistics in first column and P-values in the second one.

Note: This package makes use of 16 (221 x 6 or 8) coefficient matrices which are placed in the &quot;coeffs&quot; subdirectory of the package directory.
</help>
<data-files count="1">
coeffs </data-files>
<gretl-function name="CH_bundle_print" type="void" pkg-role="bundle-print">
 <params count="3">
  <param name="b" type="bundleref"/>
  <param name="modelprint" type="int" min="0" max="1" default="0"/>
  <param name="mlatex" type="int" min="0" max="1" default="0"/>
 </params>
<code>matrix SCH = b[&quot;SCH&quot;]
string sdeterm = b[&quot;sdeterm&quot;]
scalar Nc = b[&quot;Nc&quot;]
scalar m = b[&quot;m&quot;]
scalar sdum = b[&quot;sdum&quot;]
scalar pd=rows(SCH)
string dol=&quot;$&quot;
string yname = b[&quot;yname&quot;]
set echo off
if mlatex==0
  print &quot; &quot;
  print &quot;Canova-Hansen tests of seasonal stability for @yname&quot;
  print &quot;---------------------------------------------------&quot;
  print &quot; &quot;
  print &quot;Regressors in the auxiliary regression: &quot;
  print &quot;@sdeterm&quot;
  print &quot; &quot;
  printf &quot;Degrees of freedom (T-k) = %g, lag order = %g\n&quot;, Nc, m
  print &quot; &quot;
else
  #print &quot;\begin{table}&quot;
  print &quot;\begin{center}&quot;
  #print &quot;\caption{Canova-Hansen test of seasonal stability for @yname.} &quot;
  print &quot;Canova-Hansen test of seasonal stability for \verb&quot; @yname&quot;.\\ &quot;
  print &quot;Regressors in the auxiliary regression: @sdeterm.\\&quot;
  printf &quot;Degrees of freedom (T-k) = %g, lag order = %g. \\\ \n&quot;, Nc, m
  print &quot;\vspace{1em}&quot;
  print &quot;&quot;
endif
if (sdum==0)
  if mlatex==0
    print &quot;Statistic       p-value       season      &quot;
    print &quot;------------------------------------------&quot;
  else
    print &quot;\begin{tabular}{lllr@{\qquad}}&quot;
    print &quot; &amp; Statistic &amp; p-value &amp;   \multicolumn{1}{c}{Season}  \\ \hline &quot;
  endif
  loop i=1..pd  --quiet
    string ask = asterisk(SCH[$i,2])
    if mlatex==0
      printf &quot;L$i = %4.4f    \t%.5f @ask      %g      \n&quot;, SCH[$i,1], SCH[$i,2], $i
    else
      printf &quot;L$i = &amp; %4.4f &amp; %.5f @ask  &amp;    %g \\\\ \n&quot;, SCH[$i,1], SCH[$i,2], $i
    endif
  endloop
else
  if (mlatex==0)
    print &quot;   Statistic    p-value     Ang. Frequency     Period     &quot;
    print &quot;--------------------------------------------------------&quot;
  else
    print &quot;\begin{tabular}{lllrr@{$\,\pm\,$}r@{$\pi$/}lr}&quot;
    print &quot; &amp;  Statistic &amp;p-value &amp;&amp; \multicolumn{3}{c}{Ang. Frequency}  &amp; Period \\ \hline  &quot;
  endif
  loop i=1..(pd-1) --quiet
    scalar jota=i*2
    scalar mcd = Gcd($pd,jota)
    scalar denom = $pd/mcd
    scalar num = jota/mcd
    scalar per = 2*denom/num
    string ask = asterisk(SCH[$i,2])
    if  (denom==1 &amp;&amp; mlatex==0) # freq=pi, period =2
      printf &quot;L_pi= \t%4.4f \t%.5f @ask      pi     \t2         \n&quot;, SCH[pd-1,1], SCH[pd-1,2]
    elif (denom==1 &amp;&amp; mlatex!=0)
      printf &quot;@dolL_{\pi}@dol = &amp; \t%4.4f &amp; \t%.5f &amp; @ask &amp; \multicolumn{2}{r}{$\pi$}  &amp;&amp; \t%.2f \\\\  \n&quot;, SCH[pd-1,1], SCH[pd-1,2], per
    elif (num ==1 &amp;&amp; mlatex==0)  # freq = pi/d, period = 2d
      printf &quot;L_$i = \t%4.4f \t%.5f @ask    +-pi/%.0f     \t%.0f          \n&quot;, SCH[$i,1], SCH[$i,2], denom, per
    elif (num ==1 &amp;&amp; mlatex!=0)
      printf &quot;@dolL_{$i}@dol = &amp; \t%4.4f &amp; \t%.5f &amp;@ask &amp; &amp; &amp; %.0f &amp; \t%.2f \\\\ \n&quot;, SCH[$i,1], SCH[$i,2], denom, per
    else  # freq= pi n/d
      string snumper = ((2*denom)%num==0) ? &quot;%.0f&quot; : &quot;%.2f&quot;
      if (mlatex==0)
        printf &quot;L_$i = \t%4.4f \t%.5f @ask    +-%.0fpi/%.0f    \t@snumper         \n&quot;, SCH[$i,1], SCH[$i,2], num, denom, per
      else
        printf &quot;@dolL_{$i}@dol = &amp; \t%4.4f &amp; \t%.5f &amp;@ask &amp; &amp; %.0f &amp; %.0f &amp; \t%.2f  \\\\ \n&quot;, SCH[$i,1], SCH[$i,2], num, denom, per
      endif
    endif
  endloop
  string ask = asterisk(SCH[pd,2])
  if (mlatex==0)
    print &quot;------------------------------------------------------&quot;
    printf &quot;L_f = \t%4.4f \t%.5f @ask        Joint test\n&quot;, SCH[pd,1], SCH[pd,2]
    print &quot;------------------------------------------------------&quot;
    print &quot; &quot;
  else
    print &quot;\hline &quot;
    printf &quot;@dolL_f@dol = &amp; \t%4.4f &amp; \t%.5f &amp;@ask &amp; \multicolumn{4}{c}{Joint test} \\\\ \n&quot;, SCH[pd,1], SCH[pd,2]
  endif
endif
if (mlatex!=0)
  print &quot;\hline&quot;
  print &quot;\end{tabular}&quot;
  print &quot;\end{center}&quot;
  #print &quot;\end{table}&quot;
endif
if modelprint==1
  string modelop = readfile(&quot;@dotdir/CHregress.txt&quot;)
  print modelop
endif
# delete b[&quot;sdeterm&quot;]
# delete b[&quot;sdum&quot;]
# delete b[&quot;Nc&quot;]
</code>
</gretl-function>
<gretl-function name="Canova_Hansen" type="bundle" pkg-role="gui-main">
 <params count="7">
  <param name="y" type="series">
<description>Dependent variable</description>
  </param>
  <param name="diffy" type="bool" default="1">
<description>Use first differences</description>
  </param>
  <param name="sdum" type="int" min="0" max="1" default="1">
<description>Seasonal component</description>
<labels count="2">
"Dummies" "Trigonometric terms" </labels>
  </param>
  <param name="trendroot" type="int" min="0" max="3" default="0">
<description>Trend component</description>
<labels count="4">
"const" "const + t" "const + y(-1)" "const + t + y(-1)" </labels>
  </param>
  <param name="modelprint" type="bool" default="0">
<description>Print aux. regression</description>
  </param>
  <param name="X_list" type="list" optional="true">
<description>Exogenous regressors</description>
  </param>
  <param name="mlatex" type="bool" default="0">
<description>LaTeX output</description>
  </param>
 </params>
<code>string sername = (diffy==1) ? &quot;d_&quot;~argname(y) : argname(y)
series @sername = (diffy==1) ? diff(y) : y
scalar Tobs=nobs(@sername)
scalar m = ceil(0.75*Tobs^(1/3)) #maut
genr time
if trendroot==1
  list X_list += time
elif  trendroot==2
  list X_list += @sername(-1)
elif  trendroot==3
  list X_list += time @sername(-1)
endif
bundle bprep
bundle bprep = CH_calculo_prev(@sername, sdum, m, modelprint, X_list)
matrix SCH
scalar lim = (sdum==1) ? ceil($pd/2-1) : $pd
scalar Nc=Tobs-$pd-nelem(X_list)
scalar a = (sdum==0) ? 0 : 2
loop j=1..lim --quiet
  scalar ch = CH_test(&amp;bprep, mA(j,sdum))
  scalar pvalor = CH_pvalue(a, Nc, 13, ch, trendroot)
  matrix SCH = SCH | { ch, pvalor }
endloop
if ($pd % 2==0 &amp;&amp; sdum==1)
  scalar ch = CH_test(&amp;bprep, mA($pd/2,sdum))
  matrix SCH =  SCH | {ch , CH_pvalue(1, Nc, 13, ch, trendroot)}
endif
#Joint test:
if (sdum==1)
  scalar ch = CH_test(&amp;bprep, I($pd-1))
  matrix SCH =  SCH | {ch , CH_pvalue(3, Nc, 13, ch, trendroot)}
endif
#--------------------------
if (sdum==0)
  string sdeterm = &quot;Dummies&quot;
else
  string sdeterm = &quot;Trigonometric terms&quot;
endif
if (trendroot==0)
  string sdeterm += &quot;&quot;
elif (trendroot==1)
  string sdeterm += &quot; + linear trend&quot;
elif (trendroot==2)
  string sdeterm += &quot; + y(-1)&quot;
else
  string sdeterm += &quot; + linear trend + y(-1)&quot;
endif
series yhat = bprep[&quot;yhat&quot;]
series uhat = bprep[&quot;uhat&quot;]
bundle b
b[&quot;yname&quot;] = &quot;@sername&quot;
b[&quot;sdeterm&quot;] = &quot;@sdeterm&quot;
b[&quot;sdum&quot;] = sdum
b[&quot;Nc&quot;]= Nc
b[&quot;m&quot;] = m
b[&quot;SCH&quot;]=SCH
b[&quot;@sername&quot;]=@sername
b[&quot;yhat&quot;]=yhat
b[&quot;uhat&quot;]=uhat
CH_bundle_print(&amp;b, modelprint, mlatex)
return b
</code>
</gretl-function>
<gretl-function name="CH_test_bundle_plot" type="void" pkg-role="bundle-plot">
 <params count="2">
  <param name="b" type="bundleref"/>
  <param name="ptype" type="int" min="0" max="1" default="0">
<description>Plot type</description>
<labels count="2">
"Residuals" "Fitted series" </labels>
  </param>
 </params>
<code>string sy=b[&quot;yname&quot;]
series @sy=b[&quot;@sy&quot;]
series uhat=b[&quot;uhat&quot;]
series yhat=b[&quot;yhat&quot;]
#list varse=seasfSTB(&amp;@sy,1)
if ptype == 0
  gnuplot uhat --time-series --with-lines
else
  gnuplot @sy yhat --time-series --with-lines
endif
</code>
</gretl-function>
<gretl-function name="seasdeterm" type="list" private="1">
 <params count="1">
  <param name="sdum" type="int" min="0" max="1" default="0"/>
 </params>
<code>list deterministic = null
if (sdum == 0)
  if $pd!=5 &amp;&amp; $pd!=6 &amp;&amp; $pd!=7 &amp;&amp; $pd!=52
    series u=$obsminor
  else
    series u = (time-1)%$pd + 1
  endif
  discrete u
  list deterministic += dummify(u,NA)
elif (sdum==1)
  loop j=1..ceil($pd/2-1)  --quiet
    series cos$j = cos((2*pi*j/$pd)*t)
    series sin$j = sin((2*pi*j/$pd)*t)
    deterministic += cos$j sin$j
  endloop
  if ($pd % 2==0)
    series cospit = cos(pi*t)
    deterministic += cospit
  endif
endif
return deterministic
</code>
</gretl-function>
<gretl-function name="mA" type="matrix" private="1">
 <params count="2">
  <param name="j" type="scalar"/>
  <param name="sdum" type="int" min="0" max="1" default="1"/>
 </params>
<code>if sdum==1
  if j&gt;$pd/2
    funcerr &quot;scalar j must be smaller than or equal to floor($pd/2)&quot;
  endif
  matrix P = I($pd-1)
  matrix A = (j=$pd/2) ? P[2*j-1,] :  P[2*j-1:2*j,]
else
  if j&gt;$pd
    funcerr &quot;scalar j must be smaller than or equal to $pd&quot;
  endif
  matrix P = I($pd)
  matrix A = P[j,]
endif
return A
</code>
</gretl-function>
<gretl-function name="CH_test" type="scalar" private="1">
 <params count="2">
  <param name="bprep" type="bundleref"/>
  <param name="A" type="matrix"/>
 </params>
<code>matrix Omegaf = bprep[&quot;Omegaf&quot;]
matrix P = bprep[&quot;P&quot;]
scalar n = bprep[&quot;n&quot;]
# Computing  L statistic (eq 13, canova-hansen)
scalar L=tr(inv(qform(A,Omegaf))*qform(A,P))/n^2
return L
</code>
</gretl-function>
<gretl-function name="asterisk" type="string" private="1">
 <params count="1">
  <param name="pvalor" type="scalar"/>
 </params>
<code>string st = (pvalor&lt;0.01) ? &quot;***&quot; : (pvalor&lt;0.05) ? &quot;** &quot; : (pvalor&lt;0.1) ? &quot;*  &quot; : &quot;   &quot;
return st
</code>
</gretl-function>
<gretl-function name="Gcd" type="scalar" private="1">
 <params count="2">
  <param name="num" type="scalar"/>
  <param name="den" type="scalar"/>
 </params>
<code># Computing the greatest common divisor with Euclid's algorithm
genr scalar mcd=num
genr scalar den1=den
loop while (den1!=0) --quiet
  scalar r = mcd%den1
  scalar mcd = den1
  scalar den1 = r
endloop
return mcd
</code>
</gretl-function>
<gretl-function name="CH_pvalue" type="scalar" private="1">
 <params count="5">
  <param name="a" type="int" min="0" max="3"/>
  <param name="Nc" type="scalar"/>
  <param name="nobsreg" type="scalar"/>
  <param name="valor" type="scalar"/>
  <param name="casedeterm" type="int" min="0" max="3"/>
 </params>
<code>if ($pd % 2!=0 &amp;&amp; a==1)
  print &quot;Periodicity is odd, there is no root at w=\pi frequency&quot;
  scalar pvalor=NA
else
  #C is the matrix with the coeffs, similar to equation (6) in Harvey and van Dijk (2006) + sderr of the constant.
  # string CM = &quot;@pkgdir/matrices/&quot;
  #string CM = &quot;@workdir/matrices/&quot;
  string CM = &quot;&quot;
  #string CM += &quot;1_&quot;
  #Dummies:
  if (a==0)
    string CM += &quot;D&quot;
    #Pi frequency:
  elif (a==1)
    string CM += &quot;Pi&quot;
    #A pair of seasonal frequencies:
  elif (a==2)
    string CM += &quot;Dos&quot;
    #All seasonal frequencies:
  else
    string CM += &quot;Ft&quot;
  endif
  # only constant
  if (casedeterm==0)
    string CM += &quot;_q0.mat&quot;
    # constant + trend:
  elif (casedeterm==1)
    string CM += &quot;_qt.mat&quot;
    # constant + y(-1):
  elif (casedeterm==2)
    string CM += &quot;_qy.mat&quot;
    # constant + trend + y(-1)
  else
    string CM += &quot;_qyt.mat&quot;
  endif
  #matrix Coeffs = reading_coeff_matrices(&quot;@CM&quot;)
  string mname = sprintf(&quot;%s/coeffs/%s.gz&quot;, $pkgdir, CM)
  matrix Coeffs = mread(mname)
  scalar nc=cols(Coeffs)
  matrix SdErrs = Coeffs[,nc]
  scalar nc1=nc-1
  matrix Coeffs = Coeffs[,1:nc1]
  #matrix rq will have the 221 quantiles sugested in the above article and in McKinnon (2001)
  matrix r1 = { 0.0001; 0.0002; 0.0005} | seq(1,10)'/1000
  matrix r2 = sort(ones(13,1).-r1)
  matrix ri = seq(15,985,5)'/1000
  matrix rq = r1 | ri | r2
  scalar nrq=rows(rq)
  if (a==0)
    matrix xeplc = { 1 ; 1/Nc ; 1/(Nc^2) ; 1/(Nc^3) ; $pd/Nc ; $pd/(Nc^2) ; $pd/(Nc^3)}
  elif (a==1 || a==2)
    matrix xeplc = { 1 ; 1/Nc ; 1/(Nc^2) ; $pd/Nc ; $pd/(Nc^2)}
  else
    matrix xeplc = { 1 ; 1/Nc ; 1/(Nc^2) ; $pd/Nc ; $pd/(Nc^2) ; ($pd-1) ; ($pd-1)^2}
  endif
  matrix Q1 = sort(Coeffs*xeplc)
  /*
  if (maxc(Q1[,1]) &lt; 0)
    funcerr &quot;p or Pmax is too large, please select a smaller number&quot;
  endif
  */
  if valor&lt;Q1[1]
    scalar pvalor = 1
  elif valor&gt;Q1[nrq]
    scalar pvalor = 0
  else
    matrix Mdif=seq(1,rows(rq))' ~ abs(Q1-valor)
    matrix Msort = msortby(Mdif,2)
    scalar mascer = Msort[1,1]
    scalar swindow=(nobsreg-1)/2
    scalar minq = (mascer &lt;= swindow) ? 1 : mascer-swindow
    scalar maxq = (mascer+swindow &gt;=nrq) ? nrq : mascer+swindow
    scalar maxq = (minq==1) ? nobsreg : maxq
    scalar minq = (maxq==nrq) ? maxq-nobsreg+1 : minq
    #Regressions with nobsreg=9, 11, 13 or 15 obs
    matrix qi = Q1[minq:maxq]
    matrix pri =  rq[minq:maxq]
    matrix si = SdErrs[minq:maxq]
    matrix Y = invcdf(X,2,pri)
    matrix X = ones(nobsreg,1) ~ qi ~ qi.*qi ~ (qi.*qi).*qi
    # FGLS: Build the Sigma matrix
    matrix pri1 = sqrt(pri./(1-pri))
    matrix pri2=((1./pri1).*si)'
    matrix Sigma=upper((pri1.*si)*pri2)
    matrix Sigma=(Sigma')+Sigma-(si.*si).*I(nobsreg)
    #FGLS
    matrix P = cholesky(Sigma)
    matrix PY = inv(P)*Y
    matrix PX = inv(P)*X
    matrix co=mols(PY,PX) #This is the FGLS estimator
    scalar valorcomp = abs(co[1]+co[2]*valor+co[3]*(valor^2)+co[4]*(valor^3))
    scalar pvalor = 1-cdf(X,2,valorcomp)
  endif
endif
return pvalor
</code>
</gretl-function>
<gretl-function name="CH_calculo_prev" type="bundle" private="1">
 <params count="5">
  <param name="y" type="series"/>
  <param name="sdum" type="int" min="0" max="1"/>
  <param name="m" type="scalar"/>
  <param name="modelprint" type="bool" default="0"/>
  <param name="X_list" type="list" optional="true"/>
 </params>
<code>string yname = argname(y)
series @yname=y
bundle bprep
list dete=seasdeterm(sdum) # create trigonometric components
if sdum==0
  if modelprint==0
    ols @yname dete X_list --quiet
  else
    outfile &quot;@dotdir/CHregress.txt&quot; --write
    ols @yname dete X_list
    outfile --close
  endif
else
  if modelprint==0
    ols @yname 0 dete X_list --quiet
  else
    outfile &quot;@dotdir/CHregress.txt&quot; --write
    ols @yname 0 dete X_list
    outfile --close
  endif
endif
smpl --contiguous
matrix fe = ({ $uhat }.*{ dete })'	# matrix n x (s-1)
scalar n = cols(fe)
matrix Omegaf=fe*(fe')/n
#Bartlett window
#if m&gt;0
loop k=1..m --quiet
  scalar w= 1-k/(m+1)
  matrix OA = fe[,k+1:n]*fe[,1:n-k]'
  matrix Omegaf = Omegaf+w*(OA+OA')/n
endloop
#endif
bprep[&quot;Omegaf&quot;] = Omegaf
matrix P =cum(fe')'cum(fe')	      # matrix (s-1) x (s-1)
bprep[&quot;P&quot;] = P
bprep[&quot;n&quot;] = n
bprep[&quot;m&quot;] = m
bprep[&quot;yhat&quot;]=$yhat
bprep[&quot;uhat&quot;]=$uhat
return bprep
</code>
</gretl-function>
<sample-script>
include Canova_Hansen.gfn
open data9-9.gdt

list X_list = null

bundle CH=Canova_Hansen(nocars, 0, 0,0, 1, X_list,0)
bundle CH=Canova_Hansen(nocars, 0, 1,0, 1, X_list,0)
matrix MCH=CH[&quot;SCH&quot;]
MCH
</sample-script>
</gretl-function-package>
</gretl-functions>
